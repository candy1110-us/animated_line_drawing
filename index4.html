<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wiggly Outline Animator</title>
    <link rel="stylesheet" href="css/index8.css">
    <style>
        .preview-content {
            cursor: grab;
        }
        .preview-content:active {
            cursor: grabbing;
        }
        .setting-group {
            padding: 0 20px;
        }
        .setting-group input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            cursor: pointer;
        }
        #outlineThickness {
            height: 4px;
            border-radius: 2px;
            background: #e5e7eb;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }
        #outlineThickness::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-layout">
            <!-- LEFT - Sidebar -->
            <div class="sidebar">
                <a href="index.html" class="logo-link">
                    <img src="images/mefn.gif" alt="Logo" class="header-logo">
                    <span class="logo-title">Wiggly Outline Animator</span>
                </a>
                <div class="upload-section" id="uploadSection">
                    <input type="file" id="imageUpload" accept="image/*">
                    <div id="uploadPlaceholder">
                        <label for="imageUpload" class="upload-label">
                            Upload Your Image
                        </label>
                        <div class="helper-text">
                            Click to upload (PNG, JPG, GIF)
                        </div>
                    </div>
                    <div id="uploadPreview" class="hidden">
                        <div class="image-preview-container">
                            <img id="previewImg" class="image-preview" />
                        </div>
                        <div class="upload-actions">
                            <label for="imageUpload" class="helper-text" style="color: #f59e0b; cursor: pointer;">Change image</label>
                            <span class="helper-text" style="color: #9ca3af;">|</span>
                            <span id="removeImage" class="helper-text" style="color: #dd6143; cursor: pointer;">Remove</span>
                        </div>
                    </div>
                </div>

                <div class="setting-group hidden" id="thresholdGroup">
                    <div class="sidebar-control-row" style="margin-bottom: 6px;">
                        <span class="label-text">Edge Detection</span>
                        <span class="value-display" id="thresholdDisplay">128</span>
                    </div>
                    <input type="range" id="threshold" min="30" max="220" value="128">
                    <div class="helper-text" style="margin-top: 6px;">Higher = removes more background</div>
                </div>

                <!-- Canvas Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span>
                        Canvas
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="bgIndicator" style="cursor: pointer;">
                            <span class="label-text">Background</span>
                            <div id="bgPreview" class="color-preview-box" style="background: #00ff00;"></div>
                        </div>
                        <div id="bgPopup" class="popup-menu">
                            <div class="color-square" id="bgColorSquare">
                                <div class="color-overlay"></div>
                                <div id="bgColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="bgHueSlider">
                                <div id="bgHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="bgColorHexInput" value="#00ff00" class="hex-input">
                                <input type="color" id="bgColor" value="#00ff00" class="color-input">
                            </div>
                            <div style="border-top: 1px solid #e5e7eb; padding-top: 10px;">
                                <div style="font-size: 11px; color: #9ca3af; margin-bottom: 6px;">Or use background image:</div>
                                <div class="bg-upload-area" id="bgImageUploadArea">
                                    <input type="file" id="bgImageUpload" accept="image/*" style="display: none;">
                                    <div id="bgUploadPlaceholder">
                                        <span style="font-size: 12px; color: #f59e0b; font-weight: 600;">Click to upload</span>
                                    </div>
                                    <div id="bgImagePreview" style="display: none; text-align: center;">
                                        <img id="bgPreviewImg" class="bg-thumb" />
                                        <div class="bg-upload-actions">
                                            <span id="changeBgImage" style="color: #f59e0b;">Change</span>
                                            <span style="color: #d1d5db;">|</span>
                                            <span id="removeBgImage" style="color: #dd6143;">Remove</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Ratio</span>
                            <div class="aspect-ratio-group">
                                <button class="aspect-ratio-btn selected" id="ratio16x9" title="16:9 Landscape">
                                    <svg width="20" height="12" viewBox="0 0 20 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="0.5" y="0.5" width="19" height="11" rx="1" stroke="currentColor" fill="none"/>
                                    </svg>
                                    <span>16:9</span>
                                </button>
                                <button class="aspect-ratio-btn" id="ratio9x16" title="9:16 Portrait">
                                    <svg width="12" height="20" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="0.5" y="0.5" width="11" height="19" rx="1" stroke="currentColor" fill="none"/>
                                    </svg>
                                    <span>9:16</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Stroke Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></span>
                        Stroke
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Style</span>
                            <div class="style-toggle">
                                <button class="style-btn active" data-style="line">Simple</button>
                                <button class="style-btn" data-style="line-dash">Sketchy</button>
                            </div>
                            <input type="hidden" id="lineStyleSelect" value="line">
                        </div>
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="strokeIndicator" style="cursor: pointer;">
                            <span class="label-text">Color</span>
                            <div id="strokePreview" class="color-preview-box" style="background: #2d3436;"></div>
                        </div>
                        <div id="strokePopup" class="popup-menu">
                            <div class="color-square" id="strokeColorSquare">
                                <div class="color-overlay"></div>
                                <div id="strokeColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="strokeHueSlider">
                                <div id="strokeHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="strokeColorHexInput" value="#2d3436" class="hex-input">
                                <input type="color" id="outlineColor" value="#2d3436" class="color-input">
                            </div>
                            <div style="border-top: 1px solid #e5e7eb; padding-top: 10px;">
                                <div class="sidebar-control-row" style="margin-bottom: 8px;">
                                    <span class="label-text">Thickness</span>
                                    <span class="value-display" id="thicknessDisplay">3px</span>
                                </div>
                                <input type="range" id="outlineThickness" min="1" max="10" value="3" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Gap from object</span>
                            <input type="range" id="outlineGap" min="2" max="50" value="10" class="slider-compact">
                            <span class="value-display" id="gapDisplay">10</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Roughness</span>
                            <input type="range" id="wiggleAmount" min="0" max="15" value="4" class="slider-compact">
                            <span class="value-display" id="wiggleDisplay">4</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Length</span>
                            <input type="range" id="tailLength" min="1" max="20" value="8" class="slider-compact">
                            <span class="value-display" id="tailDisplay">8%</span>
                        </div>
                    </div>
                </div>

                <!-- Animation -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg></span>
                        Animation
                    </div>

                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Duration</span>
                            <input type="range" id="duration" min="0.5" max="5" step="0.1" value="2" class="slider-compact">
                            <span class="value-display" id="durationDisplay">2.0s</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <input type="checkbox" id="showImage" class="checkbox-input" checked>
                            <span class="label-text">Show Image</span>
                        </div>
                    </div>
                </div>

                <div class="export-buttons">
                    <button class="btn-primary" id="animateBtn" disabled>Start Animation</button>
                    <button class="btn-primary" id="exportGifBtn" disabled style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">Export GIF</button>
                </div>
            </div>

            <!-- RIGHT - Preview -->
            <div class="preview-section">
                <div class="preview-content-wrapper">
                    <div class="preview-content ratio-16-9" id="previewContent">
                        <canvas id="bgCanvas" class="preview-canvas"></canvas>
                        <canvas id="imageCanvas" class="preview-canvas"></canvas>
                        <canvas id="outlineCanvas" class="preview-canvas"></canvas>
                        <div class="placeholder" id="previewPlaceholder">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="17 8 12 3 7 8"></polyline>
                                <line x1="12" y1="3" x2="12" y2="15"></line>
                            </svg>
                            <p>Upload an image to get started</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <script>
        // State
        let uploadedImage = null;
        let processedImage = null; // For non-transparent images, this holds the processed version
        let outlinePoints = [];
        let maskBoundaryPoints = []; // Raw boundary points used for clipping mask (before wiggle)
        let isAnimating = false;
        let bgImageData = null; // Background image data URL
        let cachedBgImage = null; // Cached background image object
        let imageOffsetX = 0; // Drag offset for image
        let imageOffsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        // DOM Elements
        const imageUpload = document.getElementById('imageUpload');
        const uploadSection = document.getElementById('uploadSection');
        const uploadPlaceholder = document.getElementById('uploadPlaceholder');
        const uploadPreview = document.getElementById('uploadPreview');
        const previewImg = document.getElementById('previewImg');
        // imageName element removed in sidebar redesign
        const removeImage = document.getElementById('removeImage');
        const previewPlaceholder = document.getElementById('previewPlaceholder');
        const previewContent = document.getElementById('previewContent');
        const bgCanvas = document.getElementById('bgCanvas');
        const imageCanvas = document.getElementById('imageCanvas');
        const outlineCanvas = document.getElementById('outlineCanvas');
        const animateBtn = document.getElementById('animateBtn');
        const exportGifBtn = document.getElementById('exportGifBtn');
        const bgColor = document.getElementById('bgColor');
        const bgPreview = document.getElementById('bgPreview');
        const bgPopup = document.getElementById('bgPopup');
        const bgIndicator = document.getElementById('bgIndicator');

        // Sliders
        const outlineGap = document.getElementById('outlineGap');
        const wiggleAmount = document.getElementById('wiggleAmount');
        const outlineThickness = document.getElementById('outlineThickness');
        const tailLength = document.getElementById('tailLength');
        const duration = document.getElementById('duration');
        const outlineColor = document.getElementById('outlineColor');
        const showImage = document.getElementById('showImage');
        const threshold = document.getElementById('threshold');
        const thresholdGroup = document.getElementById('thresholdGroup');

        // Displays
        const gapDisplay = document.getElementById('gapDisplay');
        const wiggleDisplay = document.getElementById('wiggleDisplay');
        const thicknessDisplay = document.getElementById('thicknessDisplay');
        const tailDisplay = document.getElementById('tailDisplay');
        const durationDisplay = document.getElementById('durationDisplay');
        const strokePreview = document.getElementById('strokePreview');
        const strokePopup = document.getElementById('strokePopup');
        const strokeIndicator = document.getElementById('strokeIndicator');
        const lineStyleSelect = document.getElementById('lineStyleSelect');
        const thresholdDisplay = document.getElementById('thresholdDisplay');

        let animationId = null;
        let isNonTransparentImage = false;

        // Color picker state
        let strokeHue = 0;
        let strokeSaturation = 0;
        let strokeValue = 20;

        // Background color picker state
        let bgHue = 120; // Green
        let bgSaturation = 100;
        let bgValue = 100;

        // Update displays and auto-regenerate outline
        outlineGap.addEventListener('input', () => {
            gapDisplay.textContent = outlineGap.value;
            if (uploadedImage) generateWigglyOutline();
        });

        wiggleAmount.addEventListener('input', () => {
            wiggleDisplay.textContent = wiggleAmount.value;
            if (uploadedImage) generateWigglyOutline();
        });

        outlineThickness.addEventListener('input', () => {
            thicknessDisplay.textContent = outlineThickness.value + 'px';
            if (outlinePoints.length > 0) drawOutlineStatic();
        });

        tailLength.addEventListener('input', () => {
            tailDisplay.textContent = tailLength.value + '%';
        });

        duration.addEventListener('input', () => {
            durationDisplay.textContent = parseFloat(duration.value).toFixed(1) + 's';
        });

        threshold.addEventListener('input', async () => {
            thresholdDisplay.textContent = threshold.value;
            if (uploadedImage && isNonTransparentImage) {
                await processNonTransparentImage(uploadedImage);
                drawImageOnCanvas();
                generateWigglyOutline();
            }
        });

        outlineColor.addEventListener('input', () => {
            const hex = outlineColor.value;
            strokePreview.style.background = hex;
            document.getElementById('strokeColorHexInput').value = hex;
            const hsv = hexToHSV(hex);
            strokeHue = hsv.h;
            strokeSaturation = hsv.s;
            strokeValue = hsv.v;
            updateStrokeColorSquare();
            updateStrokeCursors();
            if (outlinePoints.length > 0) {
                drawOutlineStatic();
            }
        });

        showImage.addEventListener('change', () => {
            imageCanvas.style.display = showImage.checked ? 'block' : 'none';
        });

        // Stroke popup toggle
        strokeIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            strokePopup.classList.toggle('visible');
            bgPopup.classList.remove('visible');
        });

        // Background popup toggle
        bgIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            bgPopup.classList.toggle('visible');
            strokePopup.classList.remove('visible');
        });

        document.addEventListener('click', () => {
            strokePopup.classList.remove('visible');
            bgPopup.classList.remove('visible');
        });

        bgPopup.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Background color change
        bgColor.addEventListener('input', () => {
            bgPreview.style.background = bgColor.value;
            bgImageData = null; // Clear background image when color is changed
            cachedBgImage = null;
            document.getElementById('bgImagePreview').style.display = 'none';
            document.getElementById('bgUploadPlaceholder').style.display = '';
            drawBackground();
        });

        // Background image upload
        const bgImageUpload = document.getElementById('bgImageUpload');
        const bgImageUploadArea = document.getElementById('bgImageUploadArea');

        bgImageUploadArea.addEventListener('click', (e) => {
            if (e.target.id !== 'removeBgImage') {
                bgImageUpload.click();
            }
        });

        bgImageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    bgImageData = event.target.result;
                    document.getElementById('bgPreviewImg').src = bgImageData;
                    document.getElementById('bgUploadPlaceholder').style.display = 'none';
                    document.getElementById('bgImagePreview').style.display = '';

                    // Cache the background image
                    const img = new Image();
                    img.onload = () => {
                        cachedBgImage = img;
                        drawBackground();
                    };
                    img.src = bgImageData;
                };
                reader.readAsDataURL(file);
            }
        });

        document.getElementById('changeBgImage').addEventListener('click', (e) => {
            e.stopPropagation();
            bgImageUpload.click();
        });

        document.getElementById('removeBgImage').addEventListener('click', (e) => {
            e.stopPropagation();
            bgImageData = null;
            cachedBgImage = null;
            document.getElementById('bgImagePreview').style.display = 'none';
            document.getElementById('bgUploadPlaceholder').style.display = '';
            bgImageUpload.value = '';
            drawBackground();
        });

        // Style toggle buttons
        document.querySelectorAll('.style-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.style-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                lineStyleSelect.value = btn.dataset.style;
            });
        });

        // Aspect ratio buttons
        const ratio16x9Btn = document.getElementById('ratio16x9');
        const ratio9x16Btn = document.getElementById('ratio9x16');

        function selectAspectRatio(ratio) {
            const isVertical = ratio === '9:16';

            ratio16x9Btn.classList.toggle('selected', !isVertical);
            ratio9x16Btn.classList.toggle('selected', isVertical);

            previewContent.className = 'preview-content';
            if (isVertical) {
                previewContent.classList.add('ratio-9-16');
            } else {
                previewContent.classList.add('ratio-16-9');
            }

            // Redraw everything with new dimensions
            if (uploadedImage) {
                drawBackground();
                drawImageOnCanvas();
                generateWigglyOutline();
            } else {
                drawBackground();
            }
        }

        ratio16x9Btn.addEventListener('click', () => selectAspectRatio('16:9'));
        ratio9x16Btn.addEventListener('click', () => selectAspectRatio('9:16'));

        // Drag to reposition image
        previewContent.addEventListener('mousedown', (e) => {
            if (!uploadedImage) return;
            isDragging = true;
            dragStartX = e.clientX - imageOffsetX;
            dragStartY = e.clientY - imageOffsetY;
            previewContent.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            imageOffsetX = e.clientX - dragStartX;
            imageOffsetY = e.clientY - dragStartY;
            drawImageOnCanvas();
            generateWigglyOutline();
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                previewContent.style.cursor = 'grab';
            }
        });

        strokePopup.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Upload handling
        uploadSection.addEventListener('click', (e) => {
            if (!uploadSection.classList.contains('has-file')) {
                imageUpload.click();
            }
        });

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = async () => {
                        uploadedImage = img;
                        previewImg.src = event.target.result;
                        // file name display removed in sidebar redesign
                        uploadPlaceholder.classList.add('hidden');
                        uploadPreview.classList.remove('hidden');
                        uploadSection.classList.add('has-file');
                        previewPlaceholder.classList.add('hidden');

                        // Check if image has transparency
                        isNonTransparentImage = !checkImageHasTransparency(img);
                        if (isNonTransparentImage) {
                            thresholdGroup.classList.remove('hidden');
                        } else {
                            thresholdGroup.classList.add('hidden');
                        }

                        // Process non-transparent images to extract strokes
                        if (isNonTransparentImage) {
                            await processNonTransparentImage(img);
                        } else {
                            processedImage = null;
                        }

                        drawImageOnCanvas();
                        // Auto-generate outline
                        generateWigglyOutline();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Check if an image has transparency
        function checkImageHasTransparency(img) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = img.width;
            tempCanvas.height = img.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(img, 0, 0);
            const data = tempCtx.getImageData(0, 0, img.width, img.height).data;

            for (let i = 3; i < data.length; i += 4) {
                if (data[i] < 250) {
                    return true; // Has transparency
                }
            }
            return false; // No transparency (solid image like JPG)
        }

        // Process non-transparent image (JPG) to extract object with original colors
        function processNonTransparentImage(img) {
            return new Promise((resolve) => {
                const thresholdValue = parseInt(threshold.value);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = img.width;
                tempCanvas.height = img.height;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw original image
                tempCtx.drawImage(img, 0, 0);

                // Get image data
                const imageData = tempCtx.getImageData(0, 0, img.width, img.height);
                const data = imageData.data;

                // Sample background color from corners (average of corner pixels)
                const cornerSamples = [
                    0, // top-left
                    (img.width - 1) * 4, // top-right
                    (img.height - 1) * img.width * 4, // bottom-left
                    ((img.height - 1) * img.width + (img.width - 1)) * 4 // bottom-right
                ];

                let bgR = 0, bgG = 0, bgB = 0;
                for (const idx of cornerSamples) {
                    bgR += data[idx];
                    bgG += data[idx + 1];
                    bgB += data[idx + 2];
                }
                bgR = Math.round(bgR / 4);
                bgG = Math.round(bgG / 4);
                bgB = Math.round(bgB / 4);

                // Calculate color distance threshold based on the slider
                // Higher threshold value = more pixels removed (more aggressive background removal)
                const colorThreshold = thresholdValue;

                // Remove pixels similar to the background color
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];

                    // Calculate color distance from background
                    const colorDist = Math.sqrt(
                        Math.pow(r - bgR, 2) +
                        Math.pow(g - bgG, 2) +
                        Math.pow(b - bgB, 2)
                    );

                    if (colorDist < colorThreshold) {
                        // Similar to background - make transparent
                        data[i + 3] = 0;
                    } else {
                        // Different from background - keep with original colors
                        data[i + 3] = 255;
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);

                // Create new image from processed canvas
                const newImg = new Image();
                newImg.onload = () => {
                    processedImage = newImg;
                    resolve(newImg);
                };
                newImg.src = tempCanvas.toDataURL('image/png');
            });
        }

        // Remove image
        removeImage.addEventListener('click', (e) => {
            e.stopPropagation();
            clearAll();
        });

        function clearAll() {
            // Stop any running animation
            if (isAnimating) {
                stopAnimation();
            }

            uploadedImage = null;
            processedImage = null;
            outlinePoints = [];
            maskBoundaryPoints = [];
            isNonTransparentImage = false;
            imageOffsetX = 0;
            imageOffsetY = 0;
            uploadPlaceholder.classList.remove('hidden');
            uploadPreview.classList.add('hidden');
            uploadSection.classList.remove('has-file');
            previewPlaceholder.classList.remove('hidden');
            animateBtn.disabled = true;
            exportGifBtn.disabled = true;
            imageUpload.value = '';
            thresholdGroup.classList.add('hidden');

            const imageCtx = imageCanvas.getContext('2d');
            const outlineCtx = outlineCanvas.getContext('2d');
            imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            outlineCtx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);
            drawBackground();
        }

        // Draw background (color or image)
        function drawBackground() {
            const container = previewContent;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            bgCanvas.width = containerWidth;
            bgCanvas.height = containerHeight;

            const ctx = bgCanvas.getContext('2d');

            if (bgImageData && cachedBgImage) {
                ctx.drawImage(cachedBgImage, 0, 0, containerWidth, containerHeight);
            } else {
                ctx.fillStyle = bgColor.value;
                ctx.fillRect(0, 0, containerWidth, containerHeight);
            }
        }

        // Draw image on canvas
        function drawImageOnCanvas() {
            if (!uploadedImage) return;

            const container = previewContent;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            bgCanvas.width = containerWidth;
            bgCanvas.height = containerHeight;
            imageCanvas.width = containerWidth;
            imageCanvas.height = containerHeight;
            outlineCanvas.width = containerWidth;
            outlineCanvas.height = containerHeight;

            // Draw background first
            drawBackground();

            const ctx = imageCanvas.getContext('2d');
            ctx.clearRect(0, 0, containerWidth, containerHeight);

            // Calculate scaling to fit image in container
            const scale = Math.min(
                (containerWidth * 0.8) / uploadedImage.width,
                (containerHeight * 0.8) / uploadedImage.height
            );

            const drawWidth = uploadedImage.width * scale;
            const drawHeight = uploadedImage.height * scale;
            const x = (containerWidth - drawWidth) / 2 + imageOffsetX;
            const y = (containerHeight - drawHeight) / 2 + imageOffsetY;

            // For non-transparent images with computed boundary, use clipping mask
            // This clips the ORIGINAL image to the detected boundary shape
            if (isNonTransparentImage && maskBoundaryPoints.length > 2) {
                ctx.save();

                // Create clipping path from boundary points
                ctx.beginPath();
                ctx.moveTo(maskBoundaryPoints[0].x, maskBoundaryPoints[0].y);
                for (let i = 1; i < maskBoundaryPoints.length; i++) {
                    ctx.lineTo(maskBoundaryPoints[i].x, maskBoundaryPoints[i].y);
                }
                ctx.closePath();
                ctx.clip();

                // Draw the ORIGINAL image clipped to the boundary
                // This preserves all original colors (skin tones, etc.)
                ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);

                ctx.restore();
            } else if (isNonTransparentImage && processedImage) {
                // Before outline is generated, show processedImage as preview
                ctx.drawImage(processedImage, x, y, drawWidth, drawHeight);
            } else {
                // For transparent images, draw normally
                ctx.drawImage(uploadedImage, x, y, drawWidth, drawHeight);
            }
        }

        // Generate wiggly outline around the image
        function generateWigglyOutline() {
            if (!uploadedImage) return;

            const containerWidth = imageCanvas.width;
            const containerHeight = imageCanvas.height;

            // For outline detection, use processedImage for non-transparent images
            // This is because JPGs have no alpha channel, so we need the processed version
            // which has dark areas as opaque and light areas as transparent
            let imageData;
            if (isNonTransparentImage && processedImage) {
                // Create a temporary canvas with the processed image for edge detection
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = containerWidth;
                tempCanvas.height = containerHeight;
                const tempCtx = tempCanvas.getContext('2d');

                // Calculate same positioning as the displayed image
                const scale = Math.min(
                    (containerWidth * 0.8) / uploadedImage.width,
                    (containerHeight * 0.8) / uploadedImage.height
                );
                const drawWidth = uploadedImage.width * scale;
                const drawHeight = uploadedImage.height * scale;
                const x = (containerWidth - drawWidth) / 2 + imageOffsetX;
                const y = (containerHeight - drawHeight) / 2 + imageOffsetY;

                tempCtx.drawImage(processedImage, x, y, drawWidth, drawHeight);
                imageData = tempCtx.getImageData(0, 0, containerWidth, containerHeight);
            } else {
                // For transparent images, use the displayed canvas directly
                const ctx = imageCanvas.getContext('2d');
                imageData = ctx.getImageData(0, 0, containerWidth, containerHeight);
            }
            const data = imageData.data;

            // Find tight boundary points (gap=0) for the clipping mask
            // This ensures the mask fits exactly around the object
            const tightBoundaryPoints = findBoundaryPoints(data, containerWidth, containerHeight, 0);

            // Store tight boundary for use as clipping mask
            maskBoundaryPoints = tightBoundaryPoints;

            // Redraw image with the clipping mask applied
            if (isNonTransparentImage && maskBoundaryPoints.length > 2) {
                drawImageOnCanvas();
            }

            // Find boundary points with user-specified gap for the outline animation
            const gap = parseInt(outlineGap.value);
            const boundaryPoints = findBoundaryPoints(data, containerWidth, containerHeight, gap);

            if (boundaryPoints.length < 3) {
                alert('Could not detect image boundary.');
                return;
            }

            // Add wiggle to the points
            const wiggle = parseInt(wiggleAmount.value);
            outlinePoints = addWiggleToPoints(boundaryPoints, wiggle);

            // Draw the outline
            drawOutlineStatic();
            animateBtn.disabled = false;
            exportGifBtn.disabled = false;
        }

        // Find boundary points of image content (transparent or non-transparent)
        function findBoundaryPoints(data, width, height, gap) {
            // Create a binary mask based on alpha channel
            // For non-transparent images, processedImage has already converted them to transparent PNG
            // where dark strokes are opaque and light areas are transparent
            let mask = new Uint8Array(width * height);

            for (let i = 0; i < data.length; i += 4) {
                const alpha = data[i + 3];
                if (alpha > 20) {
                    mask[i / 4] = 1;
                }
            }

            // Dilate the mask by the gap amount
            const dilatedMask = dilateMask(mask, width, height, gap);

            // Find the boundary of the dilated mask using marching squares
            const contours = marchingSquares(dilatedMask, width, height);

            // Simplify and smooth the contour
            if (contours.length > 0) {
                return simplifyContour(contours, 3);
            }

            return [];
        }

        // Create a filled shape from dark pixels using convex hull
        // This finds all dark pixels and computes their convex hull boundary
        function fillInteriorFromLines(mask, width, height) {
            // Collect all dark pixel coordinates
            const points = [];
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (mask[y * width + x]) {
                        points.push({ x, y });
                    }
                }
            }

            if (points.length < 3) {
                return mask; // Not enough points
            }

            // Compute convex hull using Graham scan
            const hull = convexHull(points);

            if (hull.length < 3) {
                return mask;
            }

            // Fill the convex hull polygon into a new mask
            const result = new Uint8Array(width * height);
            fillPolygon(result, width, height, hull);

            return result;
        }

        // Graham scan convex hull algorithm
        function convexHull(points) {
            if (points.length < 3) return points;

            // Find the bottom-most point (or left-most in case of tie)
            let start = 0;
            for (let i = 1; i < points.length; i++) {
                if (points[i].y > points[start].y ||
                    (points[i].y === points[start].y && points[i].x < points[start].x)) {
                    start = i;
                }
            }

            // Swap start point to index 0
            [points[0], points[start]] = [points[start], points[0]];
            const pivot = points[0];

            // Sort points by polar angle with respect to pivot
            const sorted = points.slice(1).sort((a, b) => {
                const angleA = Math.atan2(a.y - pivot.y, a.x - pivot.x);
                const angleB = Math.atan2(b.y - pivot.y, b.x - pivot.x);
                if (angleA !== angleB) return angleA - angleB;
                // If same angle, closer point first
                const distA = (a.x - pivot.x) ** 2 + (a.y - pivot.y) ** 2;
                const distB = (b.x - pivot.x) ** 2 + (b.y - pivot.y) ** 2;
                return distA - distB;
            });

            // Build hull
            const hull = [pivot];
            for (const p of sorted) {
                while (hull.length > 1 && cross(hull[hull.length - 2], hull[hull.length - 1], p) <= 0) {
                    hull.pop();
                }
                hull.push(p);
            }

            return hull;
        }

        // Cross product of vectors OA and OB
        function cross(o, a, b) {
            return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
        }

        // Fill a polygon into a mask using scanline algorithm
        function fillPolygon(mask, width, height, vertices) {
            if (vertices.length < 3) return;

            // Find bounding box
            let minY = height, maxY = 0;
            for (const v of vertices) {
                minY = Math.min(minY, Math.floor(v.y));
                maxY = Math.max(maxY, Math.ceil(v.y));
            }

            // Scanline fill
            for (let y = minY; y <= maxY; y++) {
                const intersections = [];

                // Find intersections with polygon edges
                for (let i = 0; i < vertices.length; i++) {
                    const v1 = vertices[i];
                    const v2 = vertices[(i + 1) % vertices.length];

                    // Check if edge crosses this scanline
                    if ((v1.y <= y && v2.y > y) || (v2.y <= y && v1.y > y)) {
                        // Calculate x intersection
                        const t = (y - v1.y) / (v2.y - v1.y);
                        const x = v1.x + t * (v2.x - v1.x);
                        intersections.push(x);
                    }
                }

                // Sort intersections
                intersections.sort((a, b) => a - b);

                // Fill between pairs of intersections
                for (let i = 0; i < intersections.length - 1; i += 2) {
                    const x1 = Math.max(0, Math.floor(intersections[i]));
                    const x2 = Math.min(width - 1, Math.ceil(intersections[i + 1]));
                    for (let x = x1; x <= x2; x++) {
                        if (y >= 0 && y < height) {
                            mask[y * width + x] = 1;
                        }
                    }
                }
            }
        }

        // Dilate the mask
        function dilateMask(mask, width, height, radius) {
            const result = new Uint8Array(width * height);

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    if (mask[y * width + x]) {
                        // Set all pixels within radius
                        for (let dy = -radius; dy <= radius; dy++) {
                            for (let dx = -radius; dx <= radius; dx++) {
                                if (dx * dx + dy * dy <= radius * radius) {
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                        result[ny * width + nx] = 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            return result;
        }

        // Marching squares algorithm to find contour
        function marchingSquares(mask, width, height) {
            const points = [];

            // Find a starting point on the boundary
            let startX = -1, startY = -1;
            outer: for (let y = 0; y < height - 1; y++) {
                for (let x = 0; x < width - 1; x++) {
                    if (mask[y * width + x] && !mask[y * width + (x - 1)] && x > 0) {
                        startX = x;
                        startY = y;
                        break outer;
                    }
                    if (mask[y * width + x] && y === 0) {
                        startX = x;
                        startY = y;
                        break outer;
                    }
                }
            }

            if (startX === -1) return points;

            // Trace the boundary
            const visited = new Set();
            let x = startX, y = startY;
            let dir = 0; // 0=right, 1=down, 2=left, 3=up
            const dx = [1, 0, -1, 0];
            const dy = [0, 1, 0, -1];

            const maxIterations = width * height;
            let iterations = 0;

            do {
                const key = `${x},${y}`;
                if (!visited.has(key)) {
                    points.push({ x, y });
                    visited.add(key);
                }

                // Turn right and try to move
                let found = false;
                for (let i = 0; i < 4; i++) {
                    const newDir = (dir + 3 + i) % 4; // Try right, straight, left, back
                    const nx = x + dx[newDir];
                    const ny = y + dy[newDir];

                    if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                        if (mask[ny * width + nx]) {
                            x = nx;
                            y = ny;
                            dir = newDir;
                            found = true;
                            break;
                        }
                    }
                }

                if (!found) break;
                iterations++;
            } while ((x !== startX || y !== startY) && iterations < maxIterations);

            return points;
        }

        // Simplify contour by removing points that are too close
        function simplifyContour(points, minDist) {
            if (points.length < 3) return points;

            const result = [points[0]];
            for (let i = 1; i < points.length; i++) {
                const last = result[result.length - 1];
                const curr = points[i];
                const dist = Math.sqrt((curr.x - last.x) ** 2 + (curr.y - last.y) ** 2);
                if (dist >= minDist) {
                    result.push(curr);
                }
            }

            return result;
        }

        // Add wiggle effect to points
        function addWiggleToPoints(points, wiggleAmount) {
            if (wiggleAmount === 0) return points;

            return points.map((point, i) => {
                // Use noise based on position for consistent wiggle
                const noise1 = Math.sin(i * 0.3) * Math.cos(i * 0.7);
                const noise2 = Math.cos(i * 0.4) * Math.sin(i * 0.5);

                return {
                    x: point.x + noise1 * wiggleAmount,
                    y: point.y + noise2 * wiggleAmount
                };
            });
        }

        // Draw static outline
        function drawOutlineStatic() {
            const ctx = outlineCanvas.getContext('2d');
            ctx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);

            if (outlinePoints.length < 2) return;

            ctx.strokeStyle = outlineColor.value;
            ctx.lineWidth = parseInt(outlineThickness.value);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            ctx.beginPath();
            ctx.moveTo(outlinePoints[0].x, outlinePoints[0].y);

            for (let i = 1; i < outlinePoints.length; i++) {
                ctx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
            }

            ctx.closePath();
            ctx.stroke();
        }

        // Animate button
        animateBtn.addEventListener('click', () => {
            if (outlinePoints.length < 2) return;

            if (isAnimating) {
                // Stop animation
                stopAnimation();
            } else {
                // Start animation
                animateOutline();
            }
        });

        function stopAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            isAnimating = false;
            animateBtn.textContent = 'Start Animation';
            animateBtn.style.background = '';
            // Redraw static outline
            drawOutlineStatic();
        }

        // Get current line style
        function getLineStyle() {
            return lineStyleSelect.value;
        }

        // Draw running line segment with optional trailing dash
        function drawRunningSegment(ctx, startIdx, endIdx, totalPoints) {
            if (endIdx <= startIdx) return;

            const lineStyle = getLineStyle();
            const thickness = parseInt(outlineThickness.value);

            ctx.strokeStyle = outlineColor.value;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw the main line
            ctx.beginPath();
            ctx.moveTo(outlinePoints[startIdx].x, outlinePoints[startIdx].y);

            for (let i = startIdx + 1; i <= endIdx && i < totalPoints; i++) {
                ctx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
            }
            ctx.stroke();

            // Draw short trailing dash if line-dash style (almost like a dot)
            if (lineStyle === 'line-dash') {
                const gapSize = Math.max(3, Math.floor(totalPoints * 0.008)); // Small gap between line and dash
                const dashLength = Math.max(2, Math.floor(totalPoints * 0.004)); // Very short dash (almost a dot)

                const dashStart = endIdx + gapSize;
                const dashEnd = dashStart + dashLength;

                if (dashStart < totalPoints && dashEnd <= totalPoints) {
                    ctx.beginPath();
                    ctx.moveTo(outlinePoints[dashStart].x, outlinePoints[dashStart].y);
                    for (let i = dashStart + 1; i <= dashEnd && i < totalPoints; i++) {
                        ctx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
                    }
                    ctx.stroke();
                }
            }
        }

        // Animate the outline with running line effect
        function animateOutline() {
            isAnimating = true;
            animateBtn.textContent = 'Stop Animation';
            animateBtn.style.background = 'linear-gradient(135deg, #dd6143 0%, #c4533a 100%)';

            const ctx = outlineCanvas.getContext('2d');
            const durationMs = parseFloat(duration.value) * 1000;
            const totalPoints = outlinePoints.length;
            const tailPercent = parseInt(tailLength.value) / 100;
            const tailPoints = Math.floor(totalPoints * tailPercent);

            let startTime = null;
            let hasCompletedOneLoop = false;

            function animate(timestamp) {
                if (!isAnimating) return;

                if (!startTime) startTime = timestamp;
                const elapsed = timestamp - startTime;
                const rawProgress = elapsed / durationMs;

                // Check if we've completed one full loop - just restart without showing full outline
                if (rawProgress >= 1 && !hasCompletedOneLoop) {
                    hasCompletedOneLoop = true;
                    stopAnimation();
                    return;
                }

                const progress = rawProgress % 1;

                // Calculate head and tail for fixed-length segment
                // Head starts at tailPoints and moves to totalPoints
                const headIndex = tailPoints + Math.floor(progress * (totalPoints - tailPoints));
                // Tail is always tailPoints behind head
                const tailIndex = headIndex - tailPoints;

                ctx.clearRect(0, 0, outlineCanvas.width, outlineCanvas.height);

                // Draw the running line segment
                drawRunningSegment(ctx, tailIndex, headIndex, totalPoints);

                animationId = requestAnimationFrame(animate);
            }

            animationId = requestAnimationFrame(animate);
        }

        // Export GIF
        exportGifBtn.addEventListener('click', () => {
            if (outlinePoints.length < 2) return;
            exportAsGif();
        });

        // Draw running segment for GIF export (reuses the same logic)
        function drawRunningSegmentForExport(ctx, startIdx, endIdx, totalPoints) {
            if (endIdx <= startIdx) return;

            const lineStyle = getLineStyle();
            const thickness = parseInt(outlineThickness.value);

            ctx.strokeStyle = outlineColor.value;
            ctx.lineWidth = thickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw the main line
            ctx.beginPath();
            ctx.moveTo(outlinePoints[startIdx].x, outlinePoints[startIdx].y);

            for (let i = startIdx + 1; i <= endIdx && i < totalPoints; i++) {
                ctx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
            }
            ctx.stroke();

            // Draw short trailing dash if line-dash style (almost like a dot)
            if (lineStyle === 'line-dash') {
                const gapSize = Math.max(3, Math.floor(totalPoints * 0.008));
                const dashLength = Math.max(2, Math.floor(totalPoints * 0.004));

                const dashStart = endIdx + gapSize;
                const dashEnd = dashStart + dashLength;

                if (dashStart < totalPoints && dashEnd <= totalPoints) {
                    ctx.beginPath();
                    ctx.moveTo(outlinePoints[dashStart].x, outlinePoints[dashStart].y);
                    for (let i = dashStart + 1; i <= dashEnd && i < totalPoints; i++) {
                        ctx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
                    }
                    ctx.stroke();
                }
            }
        }

        function exportAsGif() {
            const frames = [];
            const durationMs = parseFloat(duration.value) * 1000;
            const fps = 20;
            const numFrames = Math.ceil((durationMs / 1000) * fps);
            const totalPoints = outlinePoints.length;
            const tailPercent = parseInt(tailLength.value) / 100;
            const tailPoints = Math.floor(totalPoints * tailPercent);
            const width = outlineCanvas.width;
            const height = outlineCanvas.height;

            const lineStyle = getLineStyle();
            const thickness = parseInt(outlineThickness.value);
            const color = outlineColor.value;

            // Helper function to draw background on a canvas context
            function drawBgOnContext(ctx) {
                if (bgImageData && cachedBgImage) {
                    ctx.drawImage(cachedBgImage, 0, 0, width, height);
                } else {
                    ctx.fillStyle = bgColor.value;
                    ctx.fillRect(0, 0, width, height);
                }
            }

            // Generate frames for the running line animation
            for (let frame = 0; frame < numFrames; frame++) {
                // Create a fresh canvas for each frame
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');

                // Draw background (color or image)
                drawBgOnContext(tempCtx);

                const progress = frame / numFrames;

                // Calculate head and tail for fixed-length segment
                // Head starts at tailPoints and moves to totalPoints
                const headIndex = tailPoints + Math.floor(progress * (totalPoints - tailPoints));
                // Tail is always tailPoints behind head
                const tailIndex = headIndex - tailPoints;

                // Draw image if checkbox is checked
                if (showImage.checked) {
                    tempCtx.drawImage(imageCanvas, 0, 0);
                }

                // Draw the running line segment directly
                if (headIndex > tailIndex) {
                    tempCtx.strokeStyle = color;
                    tempCtx.lineWidth = thickness;
                    tempCtx.lineCap = 'round';
                    tempCtx.lineJoin = 'round';

                    // Draw the main line
                    tempCtx.beginPath();
                    tempCtx.moveTo(outlinePoints[tailIndex].x, outlinePoints[tailIndex].y);
                    for (let i = tailIndex + 1; i <= headIndex && i < totalPoints; i++) {
                        tempCtx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
                    }
                    tempCtx.stroke();

                    // Draw short trailing dash if line-dash style
                    if (lineStyle === 'line-dash') {
                        const gapSize = Math.max(3, Math.floor(totalPoints * 0.008));
                        const dashLength = Math.max(2, Math.floor(totalPoints * 0.004));
                        const dashStart = headIndex + gapSize;
                        const dashEnd = dashStart + dashLength;

                        if (dashStart < totalPoints && dashEnd <= totalPoints) {
                            tempCtx.beginPath();
                            tempCtx.moveTo(outlinePoints[dashStart].x, outlinePoints[dashStart].y);
                            for (let i = dashStart + 1; i <= dashEnd && i < totalPoints; i++) {
                                tempCtx.lineTo(outlinePoints[i].x, outlinePoints[i].y);
                            }
                            tempCtx.stroke();
                        }
                    }
                }

                frames.push(tempCanvas.toDataURL('image/png'));
            }

            // No final frame with complete outline - GIF will loop seamlessly

            gifshot.createGIF({
                images: frames,
                gifWidth: width,
                gifHeight: height,
                interval: 1 / fps,
                numFrames: frames.length,
                frameDuration: 1,
                sampleInterval: 10
            }, function(obj) {
                if (!obj.error) {
                    const link = document.createElement('a');
                    link.href = obj.image;
                    link.download = 'wiggly-outline.gif';
                    link.click();
                }
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (uploadedImage) {
                drawImageOnCanvas();
                if (outlinePoints.length > 0) {
                    generateWigglyOutline();
                }
            }
        });

        // ========== COLOR PICKER FUNCTIONS ==========
        function hsvToRgb(h, s, v) {
            s /= 100;
            v /= 100;
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        function rgbToHex(r, g, b) {
            return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHsv(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            const d = max - min;
            let h, s, v = max;
            s = max === 0 ? 0 : d / max;
            if (max === min) {
                h = 0;
            } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return { h: h * 360, s: s * 100, v: v * 100 };
        }

        function hexToHSV(hex) {
            const rgb = hexToRgb(hex);
            return rgb ? rgbToHsv(rgb.r, rgb.g, rgb.b) : { h: 0, s: 0, v: 0 };
        }

        function updateStrokeColor(hex) {
            outlineColor.value = hex;
            document.getElementById('strokeColorHexInput').value = hex;
            strokePreview.style.background = hex;
            if (outlinePoints.length > 0) {
                drawOutlineStatic();
            }
        }

        function updateStrokeColorSquare() {
            const strokeColorSquare = document.getElementById('strokeColorSquare');
            strokeColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${strokeHue}, 100%, 50%))`;
        }

        function updateStrokeCursors() {
            const strokeColorSquare = document.getElementById('strokeColorSquare');
            const strokeColorCursor = document.getElementById('strokeColorCursor');
            const strokeHueCursor = document.getElementById('strokeHueCursor');
            const strokeHueSlider = document.getElementById('strokeHueSlider');

            const rect = strokeColorSquare.getBoundingClientRect();
            strokeColorCursor.style.left = (strokeSaturation / 100 * rect.width) + 'px';
            strokeColorCursor.style.top = ((100 - strokeValue) / 100 * rect.height) + 'px';

            const hueRect = strokeHueSlider.getBoundingClientRect();
            strokeHueCursor.style.left = (strokeHue / 360 * hueRect.width) + 'px';
        }

        // Initialize stroke color picker
        const strokeColorSquare = document.getElementById('strokeColorSquare');
        const strokeColorCursor = document.getElementById('strokeColorCursor');
        const strokeHueSlider = document.getElementById('strokeHueSlider');
        const strokeHueCursor = document.getElementById('strokeHueCursor');
        const strokeColorHexInput = document.getElementById('strokeColorHexInput');

        // Initialize from default color
        const initialHsv = hexToHSV('#2d3436');
        strokeHue = initialHsv.h;
        strokeSaturation = initialHsv.s;
        strokeValue = initialHsv.v;
        updateStrokeColorSquare();

        // Color square interaction
        strokeColorSquare.addEventListener('mousedown', (e) => {
            function updateFromMouse(e) {
                const rect = strokeColorSquare.getBoundingClientRect();
                let x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                let y = Math.max(0, Math.min(e.clientY - rect.top, rect.height));
                strokeSaturation = (x / rect.width) * 100;
                strokeValue = 100 - (y / rect.height) * 100;
                strokeColorCursor.style.left = x + 'px';
                strokeColorCursor.style.top = y + 'px';
                const rgb = hsvToRgb(strokeHue, strokeSaturation, strokeValue);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                updateStrokeColor(hex);
            }
            updateFromMouse(e);
            function onMouseMove(e) { updateFromMouse(e); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // Hue slider interaction
        strokeHueSlider.addEventListener('mousedown', (e) => {
            function updateFromMouse(e) {
                const rect = strokeHueSlider.getBoundingClientRect();
                let x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                strokeHue = (x / rect.width) * 360;
                strokeHueCursor.style.left = x + 'px';
                updateStrokeColorSquare();
                const rgb = hsvToRgb(strokeHue, strokeSaturation, strokeValue);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                updateStrokeColor(hex);
            }
            updateFromMouse(e);
            function onMouseMove(e) { updateFromMouse(e); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // Hex input interaction
        strokeColorHexInput.addEventListener('input', (e) => {
            let hex = e.target.value;
            if (!hex.startsWith('#')) hex = '#' + hex;
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                const hsv = hexToHSV(hex);
                strokeHue = hsv.h;
                strokeSaturation = hsv.s;
                strokeValue = hsv.v;
                outlineColor.value = hex;
                strokePreview.style.background = hex;
                updateStrokeColorSquare();
                updateStrokeCursors();
                if (outlinePoints.length > 0) {
                    drawOutlineStatic();
                }
            }
        });

        // ========== BACKGROUND COLOR PICKER ==========
        const bgColorSquare = document.getElementById('bgColorSquare');
        const bgColorCursor = document.getElementById('bgColorCursor');
        const bgHueSlider = document.getElementById('bgHueSlider');
        const bgHueCursor = document.getElementById('bgHueCursor');
        const bgColorHexInput = document.getElementById('bgColorHexInput');

        function updateBgColor(hex) {
            bgColor.value = hex;
            bgColorHexInput.value = hex;
            bgPreview.style.background = hex;
            bgImageData = null;
            cachedBgImage = null;
            document.getElementById('bgImagePreview').style.display = 'none';
            document.getElementById('bgUploadPlaceholder').style.display = '';
            drawBackground();
        }

        function updateBgColorSquare() {
            bgColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${bgHue}, 100%, 50%))`;
        }

        function updateBgCursors() {
            const rect = bgColorSquare.getBoundingClientRect();
            bgColorCursor.style.left = (bgSaturation / 100 * rect.width) + 'px';
            bgColorCursor.style.top = ((100 - bgValue) / 100 * rect.height) + 'px';

            const hueRect = bgHueSlider.getBoundingClientRect();
            bgHueCursor.style.left = (bgHue / 360 * hueRect.width) + 'px';
        }

        // Initialize background color picker
        updateBgColorSquare();

        // Background color square interaction
        bgColorSquare.addEventListener('mousedown', (e) => {
            function updateFromMouse(e) {
                const rect = bgColorSquare.getBoundingClientRect();
                let x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                let y = Math.max(0, Math.min(e.clientY - rect.top, rect.height));
                bgSaturation = (x / rect.width) * 100;
                bgValue = 100 - (y / rect.height) * 100;
                bgColorCursor.style.left = x + 'px';
                bgColorCursor.style.top = y + 'px';
                const rgb = hsvToRgb(bgHue, bgSaturation, bgValue);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                updateBgColor(hex);
            }
            updateFromMouse(e);
            function onMouseMove(e) { updateFromMouse(e); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // Background hue slider interaction
        bgHueSlider.addEventListener('mousedown', (e) => {
            function updateFromMouse(e) {
                const rect = bgHueSlider.getBoundingClientRect();
                let x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                bgHue = (x / rect.width) * 360;
                bgHueCursor.style.left = x + 'px';
                updateBgColorSquare();
                const rgb = hsvToRgb(bgHue, bgSaturation, bgValue);
                const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                updateBgColor(hex);
            }
            updateFromMouse(e);
            function onMouseMove(e) { updateFromMouse(e); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        // Background hex input interaction
        bgColorHexInput.addEventListener('input', (e) => {
            let hex = e.target.value;
            if (!hex.startsWith('#')) hex = '#' + hex;
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                const hsv = hexToHSV(hex);
                bgHue = hsv.h;
                bgSaturation = hsv.s;
                bgValue = hsv.v;
                bgColor.value = hex;
                bgPreview.style.background = hex;
                bgImageData = null;
                cachedBgImage = null;
                document.getElementById('bgImagePreview').style.display = 'none';
                document.getElementById('bgUploadPlaceholder').style.display = '';
                updateBgColorSquare();
                updateBgCursors();
                drawBackground();
            }
        });

        // Initialize with green background
        drawBackground();
    </script>
</body>
</html>
