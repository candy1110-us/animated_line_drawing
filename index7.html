<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Highlighter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        @font-face {
            font-family: 'Be Vietnam Pro';
            src: url('fonts/BeVietnamPro-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        @font-face {
            font-family: 'Hmt Regular';
            src: url('fonts/HmtRegular-WRrv.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #ecebe4;
            background-image: url('data:image/svg+xml;utf8,<svg width="28" height="28" xmlns="http://www.w3.org/2000/svg"><circle cx="14" cy="14" r="1" fill="%23d2d1c7"/></svg>');
            background-size: 28px 28px;
            min-height: 100vh;
            padding: 40px 20px;
            position: relative;
            overflow-x: hidden;
        }

        body::before,
        body::after {
            content: '';
            position: fixed;
            border-radius: 50%;
            opacity: 0.15;
            pointer-events: none;
            z-index: 0;
        }

        body::before {
            background: #fbbf24;
            width: 50vh;
            height: 50vh;
            top: 20%;
            left: -10vh;
            animation: float 6s ease-in-out infinite;
        }

        body::after {
            background: #f59e0b;
            width: 150px;
            height: 150px;
            bottom: 15%;
            right: 8%;
            animation: float 8s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .header {
            background: transparent;
            padding: 20px 30px;
            margin-bottom: 30px;
            text-align: center;
            position: relative;
        }

        .logo-link {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .logo-link:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
        }

        .header-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .header h1 {
            font-family: 'Hmt Regular', 'Inter', sans-serif;
            font-size: 3.5rem;
            color: #2d3436;
            margin-bottom: 12px;
            text-shadow: 3px 3px 0px rgba(251, 191, 36, 0.3);
        }

        .header p {
            color: #636e72;
            font-size: 1.1rem;
        }

        .main-layout {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        @media (min-width: 1024px) {
            .main-layout {
                flex-direction: row;
                align-items: stretch;
            }

            .sidebar {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 0;
            }

            .preview-section {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-width: 0;
            }
        }

        .sidebar, .preview-section {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow:
                3px 3px 0px rgba(0, 0, 0, 0.05),
                6px 6px 0px rgba(251, 191, 36, 0.08);
            border: 1px solid rgba(45, 52, 54, 0.15);
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 24px;
        }

        .numbered-badge {
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: white;
            font-size: 24px;
            box-shadow: 3px 3px 0px rgba(251, 191, 36, 0.3);
            flex-shrink: 0;
        }

        .gradient-text {
            margin: 0;
            padding: 0;
            font-family: 'Hmt Regular', 'Inter', sans-serif;
            font-size: 2.5rem;
            font-weight: 800;
            color: #2d3436;
            line-height: 50px;
            height: 50px;
            display: flex;
            align-items: center;
        }

        .upload-section {
            border: 2px dashed rgba(251, 191, 36, 0.4);
            border-radius: 20px;
            padding: 30px 20px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 3px 3px 0px rgba(251, 191, 36, 0.1);
            margin-bottom: 20px;
        }

        .upload-section:hover {
            border-color: #fbbf24;
            background: #fffbeb;
            transform: translateY(-3px) rotate(1deg);
            box-shadow: 5px 5px 0px rgba(251, 191, 36, 0.2);
        }

        .upload-section.has-file {
            border-style: solid;
            border-color: #fbbf24;
            padding: 15px;
            cursor: default;
        }

        .upload-section.has-file:hover {
            transform: none;
            box-shadow: 3px 3px 0px rgba(251, 191, 36, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        .upload-label {
            font-size: 16px;
            color: #f59e0b;
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
        }

        .helper-text {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
            line-height: 1.4;
        }

        .document-preview-container {
            position: relative;
            width: 100%;
            max-height: 600px;
            overflow: auto;
            background: #f9fafb;
            border-radius: 12px;
            padding: 12px;
        }

        .document-preview-wrapper {
            position: relative;
            display: inline-block;
        }

        .document-preview {
            display: block;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .upload-actions {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 10px;
        }

        .setting-group {
            margin-bottom: 18px;
        }

        .setting-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .setting-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #fef3c7;
            outline: none;
            -webkit-appearance: none;
        }

        .setting-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            cursor: pointer;
            transition: all 0.2s;
        }

        .value-display {
            display: inline-block;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            border: none;
            padding: 14px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 3px 3px 0px rgba(251, 191, 36, 0.3);
            width: 100%;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 5px 5px 0px rgba(251, 191, 36, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: white;
            color: #dd6143;
            border: 2px solid #dd6143;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 2px 2px 0px rgba(221, 97, 67, 0.2);
        }

        .btn-secondary:hover {
            background: #fff5f2;
            transform: translateY(-2px);
            box-shadow: 3px 3px 0px rgba(221, 97, 67, 0.3);
        }

        .btn-clear {
            background: white;
            color: #6b7280;
            border: 2px solid #e5e7eb;
            padding: 10px 16px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-clear:hover {
            border-color: #dd6143;
            color: #dd6143;
        }

        .preview-content-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
        }

        .preview-content {
            position: relative;
            background: #f9fafb;
            border-radius: 12px;
            width: 100%;
            max-width: 640px;
            aspect-ratio: 16 / 9;
            display: flex;
            overflow: hidden;
            background: repeating-conic-gradient(#e5e7eb 0% 25%, #f9fafb 0% 50%) 50% / 20px 20px;
        }

        .preview-content.ratio-16-9 {
            aspect-ratio: 16 / 9;
            max-width: 640px;
        }

        .preview-content.ratio-9-16 {
            aspect-ratio: 9 / 16;
            max-width: 280px;
        }

        .preview-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .placeholder {
            text-align: center;
            color: #9ca3af;
            margin: auto;
        }

        .placeholder svg {
            width: 100px;
            height: 100px;
            margin: 0 auto 16px;
            opacity: 0.3;
        }

        .controls-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 16px;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .label-text {
            font-size: 12px;
            font-weight: 600;
            color: #374151;
        }

        .slider-compact {
            width: 100px;
            height: 4px;
            border-radius: 2px;
            background: #fef3c7;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
        }

        .slider-compact::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            cursor: pointer;
        }

        .color-preview-box {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #e5e7eb;
            cursor: pointer;
        }

        .popup-menu {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: white;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            width: 280px;
            z-index: 1000;
        }

        .popup-menu.visible {
            display: block;
        }

        .color-square {
            position: relative;
            width: 100%;
            height: 150px;
            background: linear-gradient(to right, white, red);
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: crosshair;
            border: 2px solid #e5e7eb;
        }

        .color-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(to bottom, transparent, black);
            border-radius: 6px;
        }

        .color-cursor {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        .hue-slider {
            height: 20px;
            border-radius: 6px;
            background: linear-gradient(to right, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000);
            position: relative;
            cursor: pointer;
            border: 2px solid #e5e7eb;
            margin-bottom: 12px;
        }

        .hue-cursor {
            position: absolute;
            width: 4px;
            height: 24px;
            background: white;
            border: 2px solid #666;
            border-radius: 2px;
            top: -2px;
            transform: translateX(-50%);
            pointer-events: none;
        }

        .hex-input {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-family: monospace;
            font-size: 13px;
        }

        .color-input {
            width: 40px;
            height: 32px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            cursor: pointer;
            padding: 0;
        }

        .mb-12 {
            margin-bottom: 12px;
        }

        .settings-controls-row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 16px;
        }

        .slider-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: #f9fafb;
            border-radius: 8px;
            height: 36px;
        }

        .flex-center-gap-8 {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pos-relative {
            position: relative;
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 24px;
        }

        .hidden {
            display: none !important;
        }

        .checkbox-input {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #fbbf24;
        }

        .export-buttons {
            display: flex;
            gap: 10px;
            margin-top: 16px;
            justify-content: center;
        }

        .export-buttons .btn-primary {
            width: auto;
        }

        .aspect-ratio-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .aspect-ratio-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            padding: 4px 6px;
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.4;
            transition: opacity 0.2s;
        }

        .aspect-ratio-btn:hover {
            opacity: 0.7;
        }

        .aspect-ratio-btn.selected {
            opacity: 1;
        }

        .aspect-ratio-btn span {
            font-size: 9px;
            font-weight: 500;
        }

        .style-buttons-group {
            display: flex;
            gap: 8px;
        }

        .style-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 14px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
        }

        .style-btn:hover {
            border-color: #fbbf24;
            color: #f59e0b;
        }

        .style-btn.selected {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border-color: #fbbf24;
            color: #92400e;
        }

        .style-btn svg {
            flex-shrink: 0;
        }

        .speed-buttons {
            display: flex;
            gap: 4px;
        }

        .speed-btn {
            padding: 4px 10px;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            transition: all 0.2s;
        }

        .speed-btn:hover {
            border-color: #fbbf24;
            color: #f59e0b;
        }

        .speed-btn.selected {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            border-color: #f59e0b;
            color: white;
        }

        .style-settings-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f9fafb;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .style-settings-toggle:hover {
            background: #f3f4f6;
        }

        .popup-left {
            left: 0;
            right: auto;
        }

        .highlight-regions-list {
            margin-top: 16px;
            max-height: 150px;
            overflow-y: auto;
        }

        .highlight-region-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #fffbeb;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 12px;
        }

        .highlight-region-item .region-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .highlight-region-item .region-number {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 11px;
        }

        .highlight-region-item .delete-btn {
            background: none;
            border: none;
            color: #dd6143;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
        }

        .highlight-region-item .delete-btn:hover {
            color: #b91c1c;
        }

        .instructions {
            background: #fffbeb;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 20px;
        }

        .instructions h4 {
            color: #92400e;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .instructions ol {
            color: #78716c;
            font-size: 12px;
            padding-left: 20px;
            line-height: 1.6;
        }

        .page-navigation {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-top: 12px;
        }

        .page-btn {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: white;
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .page-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .page-info {
            font-size: 13px;
            color: #374151;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="index.html" class="logo-link">
                <img src="images/mefn.gif" alt="Logo" class="header-logo">
            </a>
            <div class="header-content">
                <h1>Text Highlighter</h1>
            </div>
        </div>

        <div class="main-layout">
            <!-- LEFT - Controls -->
            <div class="sidebar">
                <div class="section-header">
                    <div class="numbered-badge">1</div>
                    <h3 class="gradient-text">Upload & Draw</h3>
                </div>

                <div class="setting-group">
                    <label>Style</label>
                    <div class="style-buttons-group">
                        <button type="button" class="style-btn selected" id="styleBtnHighlight" data-style="highlight">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="3" y="8" width="18" height="8" rx="1" fill="currentColor" opacity="0.3"/>
                                <line x1="5" y1="12" x2="19" y2="12"/>
                            </svg>
                            Highlight
                        </button>
                        <button type="button" class="style-btn" id="styleBtnUnderline" data-style="underline">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"/>
                                <line x1="4" y1="21" x2="20" y2="21"/>
                            </svg>
                            Underline
                        </button>
                    </div>
                    <div class="pos-relative" style="margin-top: 10px;">
                        <div class="style-settings-toggle" id="styleSettingsToggle">
                            <div class="color-preview-box" id="highlightColorPreview" style="background: #ffeb3b;"></div>
                            <span class="label-text" id="styleSettingsLabel">Color & Intensity</span>
                            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="6 9 12 15 18 9"></polyline>
                            </svg>
                        </div>
                        <div id="styleSettingsPopup" class="popup-menu popup-left">
                            <div class="mb-12">
                                <div class="label-text" style="margin-bottom: 8px;">Color</div>
                                <div class="flex-center-gap-8">
                                    <input type="color" id="highlightColor" value="#ffeb3b" style="width: 50px; height: 36px; border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer;">
                                    <span class="helper-text" id="colorHint">Yellow works best for highlighting</span>
                                </div>
                            </div>
                            <div id="opacityGroup">
                                <div class="label-text" style="margin-bottom: 8px;">
                                    Highlight Intensity <span class="value-display" id="opacityDisplay">50%</span>
                                </div>
                                <input type="range" id="highlightOpacity" min="30" max="90" value="50" style="width: 100%;">
                            </div>
                            <div class="hidden" id="underlineThicknessGroup">
                                <div class="label-text" style="margin-bottom: 8px;">
                                    Underline Thickness <span class="value-display" id="underlineThicknessDisplay">3px</span>
                                </div>
                                <input type="range" id="underlineThickness" min="2" max="8" value="3" style="width: 100%;">
                            </div>
                        </div>
                    </div>
                </div>

                <div class="upload-section" id="uploadSection">
                    <input type="file" id="fileUpload" accept=".pdf,image/*">
                    <div id="uploadPlaceholder">
                        <label for="fileUpload" class="upload-label">
                            Upload PDF or Image
                        </label>
                        <div class="helper-text">
                            Click to upload (PDF, PNG, JPG)
                        </div>
                    </div>
                    <div id="uploadPreview" class="hidden">
                        <div class="document-preview-container">
                            <div class="document-preview-wrapper">
                                <canvas id="documentCanvas" class="document-preview"></canvas>
                                <canvas id="drawingCanvas" class="drawing-canvas"></canvas>
                            </div>
                        </div>
                        <div class="page-navigation hidden" id="pageNavigation">
                            <button class="page-btn" id="prevPage">&larr;</button>
                            <span class="page-info"><span id="currentPage">1</span> / <span id="totalPages">1</span></span>
                            <button class="page-btn" id="nextPage">&rarr;</button>
                        </div>
                        <div class="upload-actions">
                            <label for="fileUpload" class="helper-text" style="color: #f59e0b; cursor: pointer;">Change file</label>
                            <span class="helper-text" style="color: #9ca3af;">|</span>
                            <span id="clearRegions" class="helper-text" style="color: #6b7280; cursor: pointer;">Clear regions</span>
                            <span class="helper-text" style="color: #9ca3af;">|</span>
                            <span id="removeFile" class="helper-text" style="color: #dd6143; cursor: pointer;">Remove</span>
                        </div>
                    </div>
                </div>

                <div class="highlight-regions-list" id="regionsList"></div>
            </div>

            <!-- RIGHT - Preview -->
            <div class="preview-section">
                <div class="section-header">
                    <div class="numbered-badge">2</div>
                    <h3 class="gradient-text">Animate</h3>
                </div>

                <!-- Row 1: Duration, Background, Ratio -->
                <div class="controls-row">
                    <div class="slider-item">
                        <span class="label-text">Duration:</span>
                        <input type="range" id="duration" min="0.3" max="3" step="0.1" value="0.8" class="slider-compact">
                        <span class="value-display" id="durationDisplay">0.8s</span>
                    </div>
                    <div class="pos-relative">
                        <div class="control-group" id="bgIndicator" style="cursor: pointer;">
                            <span class="label-text">Background:</span>
                            <div id="bgPreview" class="color-preview-box" style="background: #00ff00;"></div>
                        </div>
                        <div id="bgPopup" class="popup-menu">
                            <div class="color-square" id="bgColorSquare">
                                <div class="color-overlay"></div>
                                <div id="bgColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="bgHueSlider">
                                <div id="bgHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="bgColorHexInput" value="#00ff00" class="hex-input">
                                <input type="color" id="bgColor" value="#00ff00" class="color-input">
                            </div>
                            <div style="border-top: 1px solid #e5e7eb; padding-top: 12px;">
                                <div class="label-text" style="margin-bottom: 6px; font-size: 11px; color: #6b7280;">Or use background image:</div>
                                <div class="bg-upload-area" id="bgImageUploadArea" style="border: 2px dashed #e5e7eb; border-radius: 8px; padding: 12px; cursor: pointer; text-align: center;">
                                    <input type="file" id="bgImageUpload" accept="image/*" style="display: none;">
                                    <div id="bgUploadPlaceholder" style="display: flex; flex-direction: column; align-items: center;">
                                        <span style="font-size: 12px; color: #f59e0b;">Click to upload</span>
                                    </div>
                                    <div id="bgImagePreview" style="display: none; flex-direction: column; align-items: center; gap: 4px;">
                                        <img id="bgPreviewImg" style="max-width: 60px; max-height: 40px; border-radius: 4px;" />
                                        <span style="font-size: 10px; color: #6b7280;" id="bgImageName"></span>
                                        <div style="display: flex; gap: 8px;">
                                            <span style="font-size: 10px; color: #f59e0b; cursor: pointer;" id="changeBgImage">Change</span>
                                            <span style="font-size: 10px; color: #dd6143; cursor: pointer;" id="removeBgImage">Remove</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="control-group">
                        <span class="label-text">Ratio:</span>
                        <div class="aspect-ratio-group">
                            <button class="aspect-ratio-btn selected" id="ratio16x9" title="16:9 Landscape">
                                <svg width="20" height="12" viewBox="0 0 20 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="0.5" y="0.5" width="19" height="11" rx="1" stroke="currentColor" fill="none"/>
                                </svg>
                                <span>16:9</span>
                            </button>
                            <button class="aspect-ratio-btn" id="ratio9x16" title="9:16 Portrait">
                                <svg width="12" height="20" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <rect x="0.5" y="0.5" width="11" height="19" rx="1" stroke="currentColor" fill="none"/>
                                </svg>
                                <span>9:16</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Row 2: Timing and Delay -->
                <div class="controls-row">
                    <div class="control-group">
                        <span class="label-text">Timing:</span>
                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                            <input type="radio" name="timingMode" id="timingSequential" value="sequential" checked style="accent-color: #f59e0b;">
                            <span style="font-size: 12px;">Sequential</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                            <input type="radio" name="timingMode" id="timingSimultaneous" value="simultaneous" style="accent-color: #f59e0b;">
                            <span style="font-size: 12px;">Simultaneous</span>
                        </label>
                    </div>
                    <div class="slider-item" id="delayGroup">
                        <span class="label-text">Delay:</span>
                        <input type="range" id="delay" min="0" max="1" step="0.1" value="0.2" class="slider-compact">
                        <span class="value-display" id="delayDisplay">0.2s</span>
                    </div>
                </div>

                <!-- Row 3: Jiggle and Paper Edges -->
                <div class="controls-row">
                    <div class="slider-item">
                        <span class="label-text">Jiggle:</span>
                        <input type="range" id="jiggleAmount" min="0" max="10" step="1" value="0" class="slider-compact">
                        <span class="value-display" id="jiggleDisplay">0</span>
                    </div>
                    <div class="control-group" id="jiggleSpeedGroup" style="display: none;">
                        <span class="label-text">Speed:</span>
                        <div class="speed-buttons">
                            <button type="button" class="speed-btn" id="speedSlow" data-speed="160">Slow</button>
                            <button type="button" class="speed-btn selected" id="speedMedium" data-speed="80">Medium</button>
                            <button type="button" class="speed-btn" id="speedFast" data-speed="40">Fast</button>
                        </div>
                    </div>
                    <div class="slider-item">
                        <span class="label-text">Paper Edges:</span>
                        <input type="range" id="paperEdges" min="0" max="6" step="1" value="0" class="slider-compact">
                        <span class="value-display" id="paperEdgesDisplay">0</span>
                    </div>
                </div>

                <div class="preview-content-wrapper">
                    <div class="preview-content ratio-16-9" id="previewContent">
                        <canvas id="bgCanvas" class="preview-canvas"></canvas>
                        <canvas id="animCanvas" class="preview-canvas"></canvas>
                        <div class="placeholder" id="previewPlaceholder">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                                <path d="M12 20h9"></path>
                                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                            </svg>
                            <p>Upload a document and draw highlight regions</p>
                        </div>
                    </div>
                </div>

                <div class="export-buttons">
                    <button class="btn-primary" id="exportGifBtn" disabled style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); box-shadow: 3px 3px 0px rgba(16, 185, 129, 0.3);">Export GIF</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <script>
        // Initialize PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State
        let uploadedFile = null;
        let documentImage = null;
        let pdfDocument = null;
        let currentPdfPage = 1;
        let totalPdfPages = 1;
        let highlightRegions = [];
        let isDrawing = false;
        let startX, startY;
        let currentRect = null;
        let isAnimating = false;
        let animationId = null;
        let bgImageData = null;
        let cachedBgImage = null;

        // DOM Elements
        const fileUpload = document.getElementById('fileUpload');
        const uploadSection = document.getElementById('uploadSection');
        const uploadPlaceholder = document.getElementById('uploadPlaceholder');
        const uploadPreview = document.getElementById('uploadPreview');
        const documentCanvas = document.getElementById('documentCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const removeFile = document.getElementById('removeFile');
        const clearRegions = document.getElementById('clearRegions');
        const regionsList = document.getElementById('regionsList');
        const pageNavigation = document.getElementById('pageNavigation');
        const prevPageBtn = document.getElementById('prevPage');
        const nextPageBtn = document.getElementById('nextPage');
        const currentPageSpan = document.getElementById('currentPage');
        const totalPagesSpan = document.getElementById('totalPages');

        const previewPlaceholder = document.getElementById('previewPlaceholder');
        const previewContent = document.getElementById('previewContent');
        const bgCanvas = document.getElementById('bgCanvas');
        const animCanvas = document.getElementById('animCanvas');
        const exportGifBtn = document.getElementById('exportGifBtn');

        // Controls
        const bgColor = document.getElementById('bgColor');
        const bgPreview = document.getElementById('bgPreview');
        const bgPopup = document.getElementById('bgPopup');
        const bgIndicator = document.getElementById('bgIndicator');
        const highlightColor = document.getElementById('highlightColor');
        const highlightOpacity = document.getElementById('highlightOpacity');
        const opacityDisplay = document.getElementById('opacityDisplay');
        const duration = document.getElementById('duration');
        const durationDisplay = document.getElementById('durationDisplay');
        const delay = document.getElementById('delay');
        const delayDisplay = document.getElementById('delayDisplay');
        const styleBtnHighlight = document.getElementById('styleBtnHighlight');
        const styleBtnUnderline = document.getElementById('styleBtnUnderline');
        const styleSettingsToggle = document.getElementById('styleSettingsToggle');
        const styleSettingsPopup = document.getElementById('styleSettingsPopup');
        const highlightColorPreview = document.getElementById('highlightColorPreview');
        const opacityGroup = document.getElementById('opacityGroup');
        const underlineThicknessGroup = document.getElementById('underlineThicknessGroup');
        const underlineThickness = document.getElementById('underlineThickness');
        const underlineThicknessDisplay = document.getElementById('underlineThicknessDisplay');
        const colorHint = document.getElementById('colorHint');
        const timingSequential = document.getElementById('timingSequential');
        const timingSimultaneous = document.getElementById('timingSimultaneous');
        const delayGroup = document.getElementById('delayGroup');
        const jiggleAmount = document.getElementById('jiggleAmount');
        const jiggleDisplay = document.getElementById('jiggleDisplay');
        const jiggleSpeedGroup = document.getElementById('jiggleSpeedGroup');
        const speedSlow = document.getElementById('speedSlow');
        const speedMedium = document.getElementById('speedMedium');
        const speedFast = document.getElementById('speedFast');
        const paperEdges = document.getElementById('paperEdges');
        const paperEdgesDisplay = document.getElementById('paperEdgesDisplay');

        // Color picker state
        let bgHue = 0;
        let bgSaturation = 0;
        let bgValue = 100;

        // Current style state
        let currentStyle = 'highlight';

        // Jiggle speed state (in ms)
        let currentJiggleSpeed = 80;

        // Get current style
        function getCurrentStyle() {
            return currentStyle;
        }

        // Easing functions
        const easingFunctions = {
            linear: t => t,
            easeIn: t => t * t,
            easeOut: t => t * (2 - t),
            easeInOut: t => t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t
        };

        // Event listeners for controls
        highlightOpacity.addEventListener('input', () => {
            opacityDisplay.textContent = highlightOpacity.value + '%';
            redrawRegions();
            restartAnimation();
        });

        duration.addEventListener('input', () => {
            durationDisplay.textContent = parseFloat(duration.value).toFixed(1) + 's';
            restartAnimation();
        });

        delay.addEventListener('input', () => {
            delayDisplay.textContent = parseFloat(delay.value).toFixed(1) + 's';
            restartAnimation();
        });

        highlightColor.addEventListener('input', () => {
            highlightColorPreview.style.background = highlightColor.value;
            redrawRegions();
            restartAnimation();
        });

        // Style button listeners
        function selectStyle(style) {
            currentStyle = style;
            styleBtnHighlight.classList.toggle('selected', style === 'highlight');
            styleBtnUnderline.classList.toggle('selected', style === 'underline');

            if (style === 'highlight') {
                opacityGroup.classList.remove('hidden');
                underlineThicknessGroup.classList.add('hidden');
                colorHint.textContent = 'Yellow works best for highlighting';
            } else {
                opacityGroup.classList.add('hidden');
                underlineThicknessGroup.classList.remove('hidden');
                colorHint.textContent = 'Any color works for underlines';
            }
            redrawRegions();
            restartAnimation();
        }

        styleBtnHighlight.addEventListener('click', () => selectStyle('highlight'));
        styleBtnUnderline.addEventListener('click', () => selectStyle('underline'));

        underlineThickness.addEventListener('input', () => {
            underlineThicknessDisplay.textContent = underlineThickness.value + 'px';
            redrawRegions();
            restartAnimation();
        });

        // Style settings popup toggle
        styleSettingsToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            styleSettingsPopup.classList.toggle('visible');
            bgPopup.classList.remove('visible');
        });

        // Timing mode listeners
        timingSequential.addEventListener('change', () => {
            delayGroup.style.display = 'flex';
            restartAnimation();
        });

        timingSimultaneous.addEventListener('change', () => {
            delayGroup.style.display = 'none';
            restartAnimation();
        });

        // Jiggle amount listener
        jiggleAmount.addEventListener('input', () => {
            jiggleDisplay.textContent = jiggleAmount.value;
            // Show/hide speed control based on jiggle amount
            jiggleSpeedGroup.style.display = parseInt(jiggleAmount.value) > 0 ? 'flex' : 'none';
            restartAnimation();
        });

        // Jiggle speed button listeners
        function selectJiggleSpeed(speed, btn) {
            currentJiggleSpeed = speed;
            speedSlow.classList.remove('selected');
            speedMedium.classList.remove('selected');
            speedFast.classList.remove('selected');
            btn.classList.add('selected');
            restartAnimation();
        }

        speedSlow.addEventListener('click', () => selectJiggleSpeed(160, speedSlow));
        speedMedium.addEventListener('click', () => selectJiggleSpeed(80, speedMedium));
        speedFast.addEventListener('click', () => selectJiggleSpeed(40, speedFast));

        // Paper edges listener
        paperEdges.addEventListener('input', () => {
            paperEdgesDisplay.textContent = paperEdges.value;
            // Reset paper edge seed when value changes to regenerate edges
            if (parseInt(paperEdges.value) > 0) {
                paperEdgeSeed = Math.floor(Math.random() * 100000);
            }
            restartAnimation();
        });

        // Background popup toggle
        bgIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            bgPopup.classList.toggle('visible');
            styleSettingsPopup.classList.remove('visible');
        });

        document.addEventListener('click', () => {
            bgPopup.classList.remove('visible');
            styleSettingsPopup.classList.remove('visible');
        });

        bgPopup.addEventListener('click', (e) => e.stopPropagation());
        styleSettingsPopup.addEventListener('click', (e) => e.stopPropagation());

        bgColor.addEventListener('input', () => {
            bgPreview.style.background = bgColor.value;
            document.getElementById('bgColorHexInput').value = bgColor.value;
            bgImageData = null;
            cachedBgImage = null;
            const bgImagePreviewEl = document.getElementById('bgImagePreview');
            const bgUploadPlaceholderEl = document.getElementById('bgUploadPlaceholder');
            if (bgImagePreviewEl) bgImagePreviewEl.style.display = 'none';
            if (bgUploadPlaceholderEl) bgUploadPlaceholderEl.style.display = 'flex';
            drawBackground();
            restartAnimation();
        });

        // Background color picker
        const bgColorSquare = document.getElementById('bgColorSquare');
        const bgColorCursor = document.getElementById('bgColorCursor');
        const bgHueSlider = document.getElementById('bgHueSlider');
        const bgHueCursor = document.getElementById('bgHueCursor');
        const bgColorHexInput = document.getElementById('bgColorHexInput');

        function hsvToHex(h, s, v) {
            s /= 100;
            v /= 100;
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            const toHex = (n) => Math.round((n + m) * 255).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function hexToHSV(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substr(0, 2), 16) / 255;
            const g = parseInt(hex.substr(2, 2), 16) / 255;
            const b = parseInt(hex.substr(4, 2), 16) / 255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            const d = max - min;
            let h = 0;
            if (d !== 0) {
                if (max === r) h = ((g - b) / d) % 6;
                else if (max === g) h = (b - r) / d + 2;
                else h = (r - g) / d + 4;
                h *= 60;
                if (h < 0) h += 360;
            }
            const s = max === 0 ? 0 : (d / max) * 100;
            const v = max * 100;
            return { h, s, v };
        }

        function updateBgColorSquare() {
            const hueColor = hsvToHex(bgHue, 100, 100);
            bgColorSquare.style.background = `linear-gradient(to right, white, ${hueColor})`;
        }

        function updateBgCursors() {
            bgColorCursor.style.left = (bgSaturation) + '%';
            bgColorCursor.style.top = (100 - bgValue) + '%';
            bgHueCursor.style.left = (bgHue / 360 * 100) + '%';
        }

        function updateBgColor() {
            const hex = hsvToHex(bgHue, bgSaturation, bgValue);
            bgColor.value = hex;
            bgPreview.style.background = hex;
            bgColorHexInput.value = hex;
            // Clear background image when color is changed
            bgImageData = null;
            cachedBgImage = null;
            const bgImagePreviewEl = document.getElementById('bgImagePreview');
            const bgUploadPlaceholder = document.getElementById('bgUploadPlaceholder');
            if (bgImagePreviewEl) bgImagePreviewEl.style.display = 'none';
            if (bgUploadPlaceholder) bgUploadPlaceholder.style.display = 'flex';
            drawBackground();
            restartAnimation();
        }

        // Background color square interaction
        let isDraggingBgSquare = false;
        bgColorSquare.addEventListener('mousedown', (e) => {
            isDraggingBgSquare = true;
            updateBgSquareFromEvent(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingBgSquare) updateBgSquareFromEvent(e);
        });

        document.addEventListener('mouseup', () => {
            isDraggingBgSquare = false;
        });

        function updateBgSquareFromEvent(e) {
            const rect = bgColorSquare.getBoundingClientRect();
            let x = (e.clientX - rect.left) / rect.width * 100;
            let y = (e.clientY - rect.top) / rect.height * 100;
            x = Math.max(0, Math.min(100, x));
            y = Math.max(0, Math.min(100, y));
            bgSaturation = x;
            bgValue = 100 - y;
            updateBgCursors();
            updateBgColor();
        }

        // Background hue slider interaction
        let isDraggingBgHue = false;
        bgHueSlider.addEventListener('mousedown', (e) => {
            isDraggingBgHue = true;
            updateBgHueFromEvent(e);
        });

        document.addEventListener('mousemove', (e) => {
            if (isDraggingBgHue) updateBgHueFromEvent(e);
        });

        document.addEventListener('mouseup', () => {
            isDraggingBgHue = false;
        });

        function updateBgHueFromEvent(e) {
            const rect = bgHueSlider.getBoundingClientRect();
            let x = (e.clientX - rect.left) / rect.width;
            x = Math.max(0, Math.min(1, x));
            bgHue = x * 360;
            updateBgColorSquare();
            updateBgCursors();
            updateBgColor();
        }

        bgColorHexInput.addEventListener('input', () => {
            let hex = bgColorHexInput.value;
            if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                const hsv = hexToHSV(hex);
                bgHue = hsv.h;
                bgSaturation = hsv.s;
                bgValue = hsv.v;
                bgColor.value = hex;
                bgPreview.style.background = hex;
                updateBgColorSquare();
                updateBgCursors();
                drawBackground();
                restartAnimation();
            }
        });

        // Initialize background color picker - set to greenscreen
        bgHue = 120;
        bgSaturation = 100;
        bgValue = 100;
        updateBgColorSquare();
        updateBgCursors();

        // Background image upload elements
        const bgImageUploadArea = document.getElementById('bgImageUploadArea');
        const bgImageUpload = document.getElementById('bgImageUpload');
        const bgUploadPlaceholder = document.getElementById('bgUploadPlaceholder');
        const bgImagePreviewEl = document.getElementById('bgImagePreview');
        const bgPreviewImg = document.getElementById('bgPreviewImg');
        const bgImageName = document.getElementById('bgImageName');
        const changeBgImage = document.getElementById('changeBgImage');
        const removeBgImage = document.getElementById('removeBgImage');

        // Background image upload handlers
        if (bgImageUploadArea && bgImageUpload) {
            bgImageUploadArea.addEventListener('click', (e) => {
                if (e.target.id === 'changeBgImage') {
                    bgImageUpload.click();
                } else if (e.target.id === 'removeBgImage') {
                    bgImageData = null;
                    cachedBgImage = null;
                    bgImagePreviewEl.style.display = 'none';
                    bgUploadPlaceholder.style.display = 'flex';
                    drawBackground();
                    restartAnimation();
                } else if (!e.target.closest('#bgImagePreview') || e.target.id === 'changeBgImage') {
                    bgImageUpload.click();
                }
            });

            bgImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        bgImageData = event.target.result;
                        bgPreviewImg.src = bgImageData;
                        bgImageName.textContent = file.name;
                        bgUploadPlaceholder.style.display = 'none';
                        bgImagePreviewEl.style.display = 'flex';

                        cachedBgImage = new Image();
                        cachedBgImage.onload = () => {
                            drawBackground();
                            restartAnimation();
                        };
                        cachedBgImage.src = bgImageData;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        // Aspect ratio buttons
        const ratio16x9Btn = document.getElementById('ratio16x9');
        const ratio9x16Btn = document.getElementById('ratio9x16');

        function selectAspectRatio(ratio) {
            const isVertical = ratio === '9:16';
            ratio16x9Btn.classList.toggle('selected', !isVertical);
            ratio9x16Btn.classList.toggle('selected', isVertical);
            previewContent.className = 'preview-content';
            previewContent.classList.add(isVertical ? 'ratio-9-16' : 'ratio-16-9');
            drawBackground();
            restartAnimation();
        }

        ratio16x9Btn.addEventListener('click', () => selectAspectRatio('16:9'));
        ratio9x16Btn.addEventListener('click', () => selectAspectRatio('9:16'));

        // File upload handling
        uploadSection.addEventListener('click', (e) => {
            if (e.target.id === 'removeFile' || e.target.id === 'clearRegions') return;
            if (!uploadSection.classList.contains('has-file')) {
                fileUpload.click();
            }
        });

        fileUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFileUpload(file);
        });

        async function handleFileUpload(file) {
            uploadedFile = file;
            highlightRegions = [];
            updateRegionsList();

            if (file.type === 'application/pdf') {
                await loadPdf(file);
            } else if (file.type.startsWith('image/')) {
                await loadImage(file);
            }

            uploadPlaceholder.classList.add('hidden');
            uploadPreview.classList.remove('hidden');
            uploadSection.classList.add('has-file');
            checkReadyState();
        }

        async function loadPdf(file) {
            const arrayBuffer = await file.arrayBuffer();
            pdfDocument = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            totalPdfPages = pdfDocument.numPages;
            currentPdfPage = 1;

            if (totalPdfPages > 1) {
                pageNavigation.classList.remove('hidden');
                totalPagesSpan.textContent = totalPdfPages;
                updatePageButtons();
            } else {
                pageNavigation.classList.add('hidden');
            }

            await renderPdfPage(currentPdfPage);
        }

        async function renderPdfPage(pageNum) {
            const page = await pdfDocument.getPage(pageNum);

            // Get the base viewport to determine natural page size
            const baseViewport = page.getViewport({ scale: 1 });

            // Calculate display size to fill available space (account for padding)
            const sidebar = document.querySelector('.sidebar');
            const sidebarWidth = sidebar ? sidebar.clientWidth - 80 : 500; // 50 + 24 padding + buffer
            const maxDisplayWidth = Math.max(sidebarWidth, 300);
            const maxDisplayHeight = 500; // reduced to account for container padding
            const scaleW = maxDisplayWidth / baseViewport.width;
            const scaleH = maxDisplayHeight / baseViewport.height;
            const displayScale = Math.min(scaleW, scaleH);
            const displayWidth = baseViewport.width * displayScale;
            const displayHeight = baseViewport.height * displayScale;

            // Use higher internal scale for sharp text (2x the display size)
            const dpr = window.devicePixelRatio || 1;
            const internalScale = displayScale * 2 * dpr;
            const viewport = page.getViewport({ scale: internalScale });

            // Set canvas internal resolution (high res for sharp text)
            documentCanvas.width = viewport.width;
            documentCanvas.height = viewport.height;
            drawingCanvas.width = viewport.width;
            drawingCanvas.height = viewport.height;

            // Set display size (CSS pixels) - use calculated size
            documentCanvas.style.width = displayWidth + 'px';
            documentCanvas.style.height = displayHeight + 'px';
            drawingCanvas.style.width = displayWidth + 'px';
            drawingCanvas.style.height = displayHeight + 'px';

            const ctx = documentCanvas.getContext('2d');
            await page.render({
                canvasContext: ctx,
                viewport: viewport
            }).promise;

            // Store the rendered image
            documentImage = new Image();
            documentImage.src = documentCanvas.toDataURL();

            currentPageSpan.textContent = pageNum;
            redrawRegions();
        }

        function updatePageButtons() {
            prevPageBtn.disabled = currentPdfPage <= 1;
            nextPageBtn.disabled = currentPdfPage >= totalPdfPages;
        }

        prevPageBtn.addEventListener('click', async () => {
            if (currentPdfPage > 1) {
                currentPdfPage--;
                await renderPdfPage(currentPdfPage);
                updatePageButtons();
            }
        });

        nextPageBtn.addEventListener('click', async () => {
            if (currentPdfPage < totalPdfPages) {
                currentPdfPage++;
                await renderPdfPage(currentPdfPage);
                updatePageButtons();
            }
        });

        async function loadImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        documentImage = img;

                        // Calculate display size to fill available space (account for padding)
                        const sidebar = document.querySelector('.sidebar');
                        const sidebarWidth = sidebar ? sidebar.clientWidth - 80 : 500; // 50 + 24 padding + buffer
                        const maxDisplayWidth = Math.max(sidebarWidth, 300);
                        const maxDisplayHeight = 500; // reduced to account for container padding
                        const scaleW = maxDisplayWidth / img.width;
                        const scaleH = maxDisplayHeight / img.height;
                        const displayScale = Math.min(scaleW, scaleH);
                        const displayWidth = img.width * displayScale;
                        const displayHeight = img.height * displayScale;

                        // Use higher internal resolution for sharp display (2x display size)
                        const dpr = window.devicePixelRatio || 1;
                        const internalScale = displayScale * 2 * dpr;

                        // Set canvas internal resolution
                        documentCanvas.width = img.width * internalScale;
                        documentCanvas.height = img.height * internalScale;
                        drawingCanvas.width = img.width * internalScale;
                        drawingCanvas.height = img.height * internalScale;

                        // Set display size (CSS pixels) - use calculated size
                        documentCanvas.style.width = displayWidth + 'px';
                        documentCanvas.style.height = displayHeight + 'px';
                        drawingCanvas.style.width = displayWidth + 'px';
                        drawingCanvas.style.height = displayHeight + 'px';

                        const ctx = documentCanvas.getContext('2d');
                        ctx.scale(internalScale, internalScale);
                        ctx.drawImage(img, 0, 0);

                        pageNavigation.classList.add('hidden');
                        pdfDocument = null;
                        redrawRegions();
                        resolve();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        // Drawing on canvas
        drawingCanvas.addEventListener('mousedown', (e) => {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            startX = (e.clientX - rect.left) * scaleX;
            startY = (e.clientY - rect.top) * scaleY;
            isDrawing = true;
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        });

        drawingCanvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            const currentX = (e.clientX - rect.left) * scaleX;
            const currentY = (e.clientY - rect.top) * scaleY;

            currentRect.width = currentX - startX;
            currentRect.height = currentY - startY;

            redrawRegions();
        });

        drawingCanvas.addEventListener('mouseup', () => {
            if (isDrawing && currentRect && Math.abs(currentRect.width) > 5 && Math.abs(currentRect.height) > 5) {
                // Normalize the rectangle (handle negative width/height)
                const normalizedRect = {
                    x: currentRect.width < 0 ? currentRect.x + currentRect.width : currentRect.x,
                    y: currentRect.height < 0 ? currentRect.y + currentRect.height : currentRect.y,
                    width: Math.abs(currentRect.width),
                    height: Math.abs(currentRect.height),
                    page: currentPdfPage
                };
                highlightRegions.push(normalizedRect);
                updateRegionsList();
                checkReadyState();
            }
            isDrawing = false;
            currentRect = null;
            redrawRegions();
        });

        drawingCanvas.addEventListener('mouseleave', () => {
            if (isDrawing) {
                isDrawing = false;
                currentRect = null;
                redrawRegions();
            }
        });

        function redrawRegions() {
            const ctx = drawingCanvas.getContext('2d');
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            const color = highlightColor.value;
            const opacity = parseInt(highlightOpacity.value) / 100;
            const dpr = window.devicePixelRatio || 1;
            const style = getCurrentStyle();
            const uThickness = parseInt(underlineThickness.value) * dpr * 3; // Scale for internal resolution

            // Draw existing regions for current page
            highlightRegions.forEach((region, index) => {
                if (!pdfDocument || region.page === currentPdfPage) {
                    if (style === 'underline') {
                        // Draw underline at bottom of region
                        ctx.fillStyle = color;
                        ctx.fillRect(region.x, region.y + region.height - uThickness, region.width, uThickness);
                    } else {
                        // Draw highlight
                        ctx.fillStyle = hexToRgba(color, opacity);
                        ctx.fillRect(region.x, region.y, region.width, region.height);
                    }

                    // Draw region number (scale font for high DPI)
                    ctx.fillStyle = '#000';
                    ctx.font = `bold ${14 * dpr}px sans-serif`;
                    ctx.fillText((index + 1).toString(), region.x + 5 * dpr, region.y + 18 * dpr);
                }
            });

            // Draw current rectangle being drawn
            if (currentRect) {
                if (style === 'underline') {
                    ctx.fillStyle = hexToRgba(color, 0.5);
                    ctx.fillRect(currentRect.x, currentRect.y + currentRect.height - uThickness, currentRect.width, uThickness);
                } else {
                    ctx.fillStyle = hexToRgba(color, opacity * 0.5);
                    ctx.fillRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                }
                ctx.strokeStyle = color;
                ctx.lineWidth = 2 * dpr;
                ctx.setLineDash([5 * dpr, 5 * dpr]);
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.setLineDash([]);
            }

            drawCurrentState();
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateRegionsList() {
            regionsList.innerHTML = '';
            highlightRegions.forEach((region, index) => {
                const item = document.createElement('div');
                item.className = 'highlight-region-item';
                item.innerHTML = `
                    <div class="region-info">
                        <span class="region-number">${index + 1}</span>
                        <span>Region ${index + 1}${pdfDocument ? ` (Page ${region.page})` : ''}</span>
                    </div>
                    <button class="delete-btn" data-index="${index}">&times;</button>
                `;
                regionsList.appendChild(item);
            });

            // Add delete handlers
            regionsList.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    highlightRegions.splice(index, 1);
                    updateRegionsList();
                    redrawRegions();
                    checkReadyState();
                });
            });
        }

        removeFile.addEventListener('click', (e) => {
            e.stopPropagation();
            clearAll();
        });

        clearRegions.addEventListener('click', (e) => {
            e.stopPropagation();
            highlightRegions = [];
            updateRegionsList();
            redrawRegions();
            checkReadyState();
        });

        function clearAll() {
            if (isAnimating) stopAnimation();
            uploadedFile = null;
            documentImage = null;
            pdfDocument = null;
            highlightRegions = [];
            uploadPlaceholder.classList.remove('hidden');
            uploadPreview.classList.add('hidden');
            uploadSection.classList.remove('has-file');
            pageNavigation.classList.add('hidden');
            fileUpload.value = '';
            updateRegionsList();
            checkReadyState();

            const ctx = animCanvas.getContext('2d');
            ctx.clearRect(0, 0, animCanvas.width, animCanvas.height);
            drawBackground();
        }

        function checkReadyState() {
            const isReady = documentImage && highlightRegions.length > 0;
            previewPlaceholder.classList.toggle('hidden', isReady);
            exportGifBtn.disabled = !isReady;

            if (isReady) {
                // Auto-start animation when ready
                restartAnimation();
            } else {
                stopAnimation();
            }
        }

        // Restart animation (used when settings change)
        function restartAnimation() {
            if (!documentImage || highlightRegions.length === 0) return;
            stopAnimation();
            startAnimation();
        }

        // Canvas setup
        function setupCanvases() {
            const container = previewContent;
            const rect = container.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;

            // Set high-res internal size
            bgCanvas.width = rect.width * dpr;
            bgCanvas.height = rect.height * dpr;
            animCanvas.width = rect.width * dpr;
            animCanvas.height = rect.height * dpr;

            // Set display size
            bgCanvas.style.width = rect.width + 'px';
            bgCanvas.style.height = rect.height + 'px';
            animCanvas.style.width = rect.width + 'px';
            animCanvas.style.height = rect.height + 'px';
        }

        function drawBackground() {
            setupCanvases();
            const ctx = bgCanvas.getContext('2d');
            if (bgImageData && cachedBgImage) {
                ctx.drawImage(cachedBgImage, 0, 0, bgCanvas.width, bgCanvas.height);
            } else {
                ctx.fillStyle = bgColor.value;
                ctx.fillRect(0, 0, bgCanvas.width, bgCanvas.height);
            }
        }

        // Generate paper edge path with torn/rough edges
        // seed allows consistent edges between frames
        let paperEdgeSeed = null;
        function generatePaperEdgePath(ctx, x, y, width, height, intensity, seed) {
            // Use seeded random for consistent edges
            const seededRandom = (function() {
                let s = seed || 12345;
                return function() {
                    s = (s * 1103515245 + 12345) & 0x7fffffff;
                    return s / 0x7fffffff;
                };
            })();

            const segments = Math.ceil((width + height) * 2 / 8); // More segments for detailed edges
            const points = [];

            // Helper to add noise to a point
            const addNoise = (baseX, baseY, maxOffset) => {
                const angle = seededRandom() * Math.PI * 2;
                const dist = seededRandom() * maxOffset;
                return {
                    x: baseX + Math.cos(angle) * dist,
                    y: baseY + Math.sin(angle) * dist
                };
            };

            // Top edge (left to right)
            const topSegments = Math.ceil(width / 8);
            for (let i = 0; i <= topSegments; i++) {
                const baseX = x + (width * i / topSegments);
                const baseY = y;
                const noise = addNoise(baseX, baseY, intensity);
                // Keep within bounds but allow inward tears
                noise.y = Math.max(y - intensity * 0.3, Math.min(y + intensity, noise.y));
                points.push(noise);
            }

            // Right edge (top to bottom)
            const rightSegments = Math.ceil(height / 8);
            for (let i = 1; i <= rightSegments; i++) {
                const baseX = x + width;
                const baseY = y + (height * i / rightSegments);
                const noise = addNoise(baseX, baseY, intensity);
                noise.x = Math.max(x + width - intensity, Math.min(x + width + intensity * 0.3, noise.x));
                points.push(noise);
            }

            // Bottom edge (right to left)
            const bottomSegments = Math.ceil(width / 8);
            for (let i = 1; i <= bottomSegments; i++) {
                const baseX = x + width - (width * i / bottomSegments);
                const baseY = y + height;
                const noise = addNoise(baseX, baseY, intensity);
                noise.y = Math.max(y + height - intensity, Math.min(y + height + intensity * 0.3, noise.y));
                points.push(noise);
            }

            // Left edge (bottom to top)
            const leftSegments = Math.ceil(height / 8);
            for (let i = 1; i < leftSegments; i++) {
                const baseX = x;
                const baseY = y + height - (height * i / leftSegments);
                const noise = addNoise(baseX, baseY, intensity);
                noise.x = Math.max(x - intensity * 0.3, Math.min(x + intensity, noise.x));
                points.push(noise);
            }

            // Draw the path
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 1; i < points.length; i++) {
                // Use quadratic curves for smoother torn edges
                const prev = points[i - 1];
                const curr = points[i];
                const midX = (prev.x + curr.x) / 2;
                const midY = (prev.y + curr.y) / 2;
                ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
            }

            // Close the path
            const last = points[points.length - 1];
            const first = points[0];
            const midX = (last.x + first.x) / 2;
            const midY = (last.y + first.y) / 2;
            ctx.quadraticCurveTo(last.x, last.y, midX, midY);
            ctx.quadraticCurveTo(first.x, first.y, first.x, first.y);
            ctx.closePath();
        }

        // Apply paper edge clipping to a canvas context
        function applyPaperEdgeClip(ctx, x, y, width, height, intensity) {
            if (!paperEdgeSeed) {
                paperEdgeSeed = Math.floor(Math.random() * 100000);
            }
            generatePaperEdgePath(ctx, x, y, width, height, intensity, paperEdgeSeed);
            ctx.clip();
        }

        // Draw paper edge shadow/border effect
        function drawPaperEdgeShadow(ctx, x, y, width, height, intensity) {
            ctx.save();
            generatePaperEdgePath(ctx, x, y, width, height, intensity, paperEdgeSeed);
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = intensity * 0.8;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillStyle = 'rgba(255, 255, 255, 0)';
            ctx.fill();
            ctx.restore();
        }

        function drawCurrentState() {
            if (!documentImage || highlightRegions.length === 0) return;

            setupCanvases();
            const ctx = animCanvas.getContext('2d');
            ctx.clearRect(0, 0, animCanvas.width, animCanvas.height);

            // Get the display size of the document canvas (CSS pixels)
            const docDisplayWidth = parseFloat(documentCanvas.style.width) || documentCanvas.width;
            const docDisplayHeight = parseFloat(documentCanvas.style.height) || documentCanvas.height;

            // Get the display size of the animation canvas (CSS pixels)
            const animDisplayWidth = parseFloat(animCanvas.style.width) || animCanvas.width;
            const animDisplayHeight = parseFloat(animCanvas.style.height) || animCanvas.height;

            // Calculate scale to fit document in animation canvas (in display pixels)
            const displayScale = Math.min(
                animDisplayWidth / docDisplayWidth,
                animDisplayHeight / docDisplayHeight
            ) * 0.9;

            // Calculate the actual canvas pixel scale (account for DPR)
            const dpr = window.devicePixelRatio || 1;

            const scaledWidth = docDisplayWidth * displayScale * dpr;
            const scaledHeight = docDisplayHeight * displayScale * dpr;
            const offsetX = (animCanvas.width - scaledWidth) / 2;
            const offsetY = (animCanvas.height - scaledHeight) / 2;

            // Scale factor for highlight regions (they're stored in internal canvas coords)
            const regionScale = scaledWidth / documentCanvas.width;

            const color = highlightColor.value;
            const style = getCurrentStyle();
            const uThickness = parseInt(underlineThickness.value) * dpr;
            const paperEdgeValue = parseInt(paperEdges.value);
            const usePaperEdges = paperEdgeValue > 0;
            const paperEdgeIntensity = paperEdgeValue * 4 * dpr; // Scale 0-6 to appropriate pixel values

            // Draw background first
            if (bgImageData && cachedBgImage) {
                ctx.drawImage(cachedBgImage, 0, 0, animCanvas.width, animCanvas.height);
            } else {
                ctx.fillStyle = bgColor.value;
                ctx.fillRect(0, 0, animCanvas.width, animCanvas.height);
            }

            // Draw paper edge shadow if enabled
            if (usePaperEdges) {
                drawPaperEdgeShadow(ctx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
            }

            if (style === 'highlight') {
                // For highlight: use an offscreen canvas to composite document + highlights
                // This prevents the background from being affected by multiply blend mode
                const offscreen = document.createElement('canvas');
                offscreen.width = animCanvas.width;
                offscreen.height = animCanvas.height;
                const offCtx = offscreen.getContext('2d');

                // Apply paper edge clipping if enabled
                if (usePaperEdges) {
                    offCtx.save();
                    applyPaperEdgeClip(offCtx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                }

                // Draw highlight regions first on offscreen canvas
                highlightRegions.forEach(region => {
                    if (!pdfDocument || region.page === currentPdfPage) {
                        offCtx.fillStyle = color;
                        offCtx.fillRect(
                            offsetX + region.x * regionScale,
                            offsetY + region.y * regionScale,
                            region.width * regionScale,
                            region.height * regionScale
                        );
                    }
                });

                // Draw document with multiply blend mode on offscreen canvas
                offCtx.globalCompositeOperation = 'multiply';
                offCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                offCtx.globalCompositeOperation = 'source-over';

                // Restore non-highlighted document areas on offscreen canvas
                offCtx.globalCompositeOperation = 'destination-over';
                offCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                offCtx.globalCompositeOperation = 'source-over';

                if (usePaperEdges) {
                    offCtx.restore();
                }

                // Now draw the composited result onto the main canvas (which already has background)
                ctx.drawImage(offscreen, 0, 0);
            } else {
                // For underline: draw document first, then underlines on top
                if (usePaperEdges) {
                    ctx.save();
                    applyPaperEdgeClip(ctx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                }

                ctx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);

                // Draw underlines
                highlightRegions.forEach(region => {
                    if (!pdfDocument || region.page === currentPdfPage) {
                        ctx.fillStyle = color;
                        const underlineY = offsetY + (region.y + region.height) * regionScale - uThickness;
                        ctx.fillRect(
                            offsetX + region.x * regionScale,
                            underlineY,
                            region.width * regionScale,
                            uThickness
                        );
                    }
                });

                if (usePaperEdges) {
                    ctx.restore();
                }
            }
        }

        // Animation
        function startAnimation() {
            if (!documentImage || highlightRegions.length === 0) return;

            isAnimating = true;

            const durationMs = parseFloat(duration.value) * 1000;
            const isSimultaneous = timingSimultaneous.checked;
            const delayMs = isSimultaneous ? 0 : parseFloat(delay.value) * 1000;
            const easingFn = easingFunctions['easeInOut'];
            const loop = true;

            setupCanvases();
            const ctx = animCanvas.getContext('2d');

            // Get the display size of the document canvas (CSS pixels)
            const docDisplayWidth = parseFloat(documentCanvas.style.width) || documentCanvas.width;
            const docDisplayHeight = parseFloat(documentCanvas.style.height) || documentCanvas.height;

            // Get the display size of the animation canvas (CSS pixels)
            const animDisplayWidth = parseFloat(animCanvas.style.width) || animCanvas.width;
            const animDisplayHeight = parseFloat(animCanvas.style.height) || animCanvas.height;

            // Calculate scale to fit document in animation canvas (in display pixels)
            const displayScale = Math.min(
                animDisplayWidth / docDisplayWidth,
                animDisplayHeight / docDisplayHeight
            ) * 0.9;

            // Calculate the actual canvas pixel scale (account for DPR)
            const dpr = window.devicePixelRatio || 1;

            const scaledWidth = docDisplayWidth * displayScale * dpr;
            const scaledHeight = docDisplayHeight * displayScale * dpr;
            const baseOffsetX = (animCanvas.width - scaledWidth) / 2;
            const baseOffsetY = (animCanvas.height - scaledHeight) / 2;

            // Scale factor for highlight regions (they're stored in internal canvas coords)
            const regionScale = scaledWidth / documentCanvas.width;

            const color = highlightColor.value;
            const style = getCurrentStyle();
            const uThickness = parseInt(underlineThickness.value) * dpr;
            const jiggle = parseInt(jiggleAmount.value) * dpr;
            const jiggleInterval = currentJiggleSpeed;
            const paperEdgeValue = parseInt(paperEdges.value);
            const usePaperEdges = paperEdgeValue > 0;
            const paperEdgeIntensity = paperEdgeValue * 4 * dpr;

            // Filter regions for current page
            const currentRegions = pdfDocument
                ? highlightRegions.filter(r => r.page === currentPdfPage)
                : highlightRegions;

            // For simultaneous mode, all regions start at time 0, so total duration is just the animation duration
            const totalDuration = isSimultaneous ? durationMs : (currentRegions.length - 1) * delayMs + durationMs;
            let startTime = null;

            // Create offscreen canvas for highlight compositing (reused each frame)
            const offscreen = document.createElement('canvas');
            offscreen.width = animCanvas.width;
            offscreen.height = animCanvas.height;
            const offCtx = offscreen.getContext('2d');

            function animate(timestamp) {
                if (!isAnimating) return;

                if (!startTime) startTime = timestamp;
                let elapsed = timestamp - startTime;

                // Handle looping
                if (loop && elapsed > totalDuration + 500) {
                    startTime = timestamp;
                    elapsed = 0;
                }

                // Calculate stop-motion style jiggle offset
                // Changes position at discrete intervals like hand-drawn animation
                let jiggleX = 0, jiggleY = 0, jiggleRotation = 0;
                if (jiggle > 0) {
                    // Change jiggle position at user-defined interval for stop-motion feel
                    const jiggleFrame = Math.floor(timestamp / jiggleInterval);
                    // Use frame number as seed for deterministic but random-looking positions
                    const seed1 = Math.sin(jiggleFrame * 12.9898) * 43758.5453;
                    const seed2 = Math.sin(jiggleFrame * 78.233) * 43758.5453;
                    const seed3 = Math.sin(jiggleFrame * 45.164) * 43758.5453;
                    jiggleX = ((seed1 - Math.floor(seed1)) - 0.5) * 2 * jiggle;
                    jiggleY = ((seed2 - Math.floor(seed2)) - 0.5) * 2 * jiggle;
                    jiggleRotation = ((seed3 - Math.floor(seed3)) - 0.5) * 0.02 * jiggle; // Slight rotation
                }

                const offsetX = baseOffsetX + jiggleX;
                const offsetY = baseOffsetY + jiggleY;

                ctx.clearRect(0, 0, animCanvas.width, animCanvas.height);

                // Draw background first
                if (bgImageData && cachedBgImage) {
                    ctx.drawImage(cachedBgImage, 0, 0, animCanvas.width, animCanvas.height);
                } else {
                    ctx.fillStyle = bgColor.value;
                    ctx.fillRect(0, 0, animCanvas.width, animCanvas.height);
                }

                // Calculate center point for rotation
                const centerX = offsetX + scaledWidth / 2;
                const centerY = offsetY + scaledHeight / 2;

                // Draw paper edge shadow if enabled (with rotation)
                if (usePaperEdges) {
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(jiggleRotation);
                    ctx.translate(-centerX, -centerY);
                    drawPaperEdgeShadow(ctx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                    ctx.restore();
                }

                if (style === 'highlight') {
                    // Use offscreen canvas to composite highlights with document
                    // This prevents background from being affected by multiply blend
                    offCtx.clearRect(0, 0, offscreen.width, offscreen.height);

                    // Apply rotation transform for jiggle
                    offCtx.save();
                    offCtx.translate(centerX, centerY);
                    offCtx.rotate(jiggleRotation);
                    offCtx.translate(-centerX, -centerY);

                    // Apply paper edge clipping if enabled
                    if (usePaperEdges) {
                        offCtx.save();
                        applyPaperEdgeClip(offCtx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                    }

                    // Draw animated highlights first on offscreen canvas
                    currentRegions.forEach((region, index) => {
                        // In simultaneous mode, all regions start at time 0
                        const regionStartTime = isSimultaneous ? 0 : index * delayMs;
                        const regionElapsed = elapsed - regionStartTime;

                        if (regionElapsed > 0) {
                            let progress = Math.min(regionElapsed / durationMs, 1);
                            progress = easingFn(progress);

                            const highlightWidth = region.width * regionScale * progress;

                            offCtx.fillStyle = color;
                            offCtx.fillRect(
                                offsetX + region.x * regionScale,
                                offsetY + region.y * regionScale,
                                highlightWidth,
                                region.height * regionScale
                            );
                        }
                    });

                    // Draw document with multiply blend mode on offscreen canvas
                    offCtx.globalCompositeOperation = 'multiply';
                    offCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                    offCtx.globalCompositeOperation = 'source-over';

                    // Restore non-highlighted areas on offscreen canvas
                    offCtx.globalCompositeOperation = 'destination-over';
                    offCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                    offCtx.globalCompositeOperation = 'source-over';

                    if (usePaperEdges) {
                        offCtx.restore();
                    }
                    offCtx.restore(); // Restore rotation transform

                    // Draw composited result onto main canvas (which already has background)
                    ctx.drawImage(offscreen, 0, 0);
                } else {
                    // Underline style: draw document first, then animated underlines
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(jiggleRotation);
                    ctx.translate(-centerX, -centerY);

                    if (usePaperEdges) {
                        ctx.save();
                        applyPaperEdgeClip(ctx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                    }

                    ctx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);

                    currentRegions.forEach((region, index) => {
                        const regionStartTime = isSimultaneous ? 0 : index * delayMs;
                        const regionElapsed = elapsed - regionStartTime;

                        if (regionElapsed > 0) {
                            let progress = Math.min(regionElapsed / durationMs, 1);
                            progress = easingFn(progress);

                            const underlineWidth = region.width * regionScale * progress;
                            const underlineY = offsetY + (region.y + region.height) * regionScale - uThickness;

                            ctx.fillStyle = color;
                            ctx.fillRect(
                                offsetX + region.x * regionScale,
                                underlineY,
                                underlineWidth,
                                uThickness
                            );
                        }
                    });

                    if (usePaperEdges) {
                        ctx.restore();
                    }
                    ctx.restore(); // Restore rotation transform
                }

                animationId = requestAnimationFrame(animate);
            }

            animationId = requestAnimationFrame(animate);
        }

        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Export GIF
        exportGifBtn.addEventListener('click', () => {
            exportGif();
        });

        function exportGif() {
            if (!documentImage || highlightRegions.length === 0) return;

            const originalText = exportGifBtn.textContent;
            exportGifBtn.textContent = 'Generating...';
            exportGifBtn.disabled = true;

            const durationMs = parseFloat(duration.value) * 1000;
            const isSimultaneous = timingSimultaneous.checked;
            const delayMs = isSimultaneous ? 0 : parseFloat(delay.value) * 1000;
            const easingFn = easingFunctions['easeInOut'];

            // Filter regions for current page
            const currentRegions = pdfDocument
                ? highlightRegions.filter(r => r.page === currentPdfPage)
                : highlightRegions;

            const totalDuration = isSimultaneous ? durationMs : (currentRegions.length - 1) * delayMs + durationMs;
            const fps = 20;
            const frameCount = Math.ceil(totalDuration / 1000 * fps) + 10;
            const frameInterval = totalDuration / frameCount;

            const frames = [];
            const tempCanvas = document.createElement('canvas');
            // Use CSS pixel size for GIF (not high-DPI internal size)
            const gifWidth = parseFloat(animCanvas.style.width) || 640;
            const gifHeight = parseFloat(animCanvas.style.height) || 360;
            tempCanvas.width = gifWidth;
            tempCanvas.height = gifHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Get the display size of the document canvas (CSS pixels)
            const docDisplayWidth = parseFloat(documentCanvas.style.width) || documentCanvas.width;
            const docDisplayHeight = parseFloat(documentCanvas.style.height) || documentCanvas.height;

            // Calculate scale to fit document in GIF canvas
            const displayScale = Math.min(
                gifWidth / docDisplayWidth,
                gifHeight / docDisplayHeight
            ) * 0.9;

            const scaledWidth = docDisplayWidth * displayScale;
            const scaledHeight = docDisplayHeight * displayScale;
            const baseOffsetX = (gifWidth - scaledWidth) / 2;
            const baseOffsetY = (gifHeight - scaledHeight) / 2;

            // Scale factor for highlight regions (they're stored in internal canvas coords)
            const regionScale = scaledWidth / documentCanvas.width;

            const color = highlightColor.value;
            const style = getCurrentStyle();
            const uThickness = parseInt(underlineThickness.value);
            const jiggle = parseInt(jiggleAmount.value);
            const jiggleInterval = currentJiggleSpeed;
            const paperEdgeValue = parseInt(paperEdges.value);
            const usePaperEdges = paperEdgeValue > 0;
            const paperEdgeIntensity = paperEdgeValue * 4;

            // Create offscreen canvas for highlight compositing
            const offscreenGif = document.createElement('canvas');
            offscreenGif.width = gifWidth;
            offscreenGif.height = gifHeight;
            const offGifCtx = offscreenGif.getContext('2d');

            // Calculate how many GIF frames per jiggle frame based on speed
            const msPerGifFrame = frameInterval;
            const gifFramesPerJiggle = Math.max(1, Math.round(jiggleInterval / msPerGifFrame));

            for (let i = 0; i <= frameCount; i++) {
                const elapsed = i * frameInterval;

                // Calculate stop-motion style jiggle offset (same as animation)
                let jiggleX = 0, jiggleY = 0, jiggleRotation = 0;
                if (jiggle > 0) {
                    // Group GIF frames into jiggle frames based on speed setting
                    const jiggleFrame = Math.floor(i / gifFramesPerJiggle);
                    const seed1 = Math.sin(jiggleFrame * 12.9898) * 43758.5453;
                    const seed2 = Math.sin(jiggleFrame * 78.233) * 43758.5453;
                    const seed3 = Math.sin(jiggleFrame * 45.164) * 43758.5453;
                    jiggleX = ((seed1 - Math.floor(seed1)) - 0.5) * 2 * jiggle;
                    jiggleY = ((seed2 - Math.floor(seed2)) - 0.5) * 2 * jiggle;
                    jiggleRotation = ((seed3 - Math.floor(seed3)) - 0.5) * 0.02 * jiggle;
                }

                const offsetX = baseOffsetX + jiggleX;
                const offsetY = baseOffsetY + jiggleY;
                const centerX = offsetX + scaledWidth / 2;
                const centerY = offsetY + scaledHeight / 2;

                // Draw background
                if (bgImageData && cachedBgImage) {
                    tempCtx.drawImage(cachedBgImage, 0, 0, gifWidth, gifHeight);
                } else {
                    tempCtx.fillStyle = bgColor.value;
                    tempCtx.fillRect(0, 0, gifWidth, gifHeight);
                }

                // Draw paper edge shadow if enabled (with rotation)
                if (usePaperEdges) {
                    tempCtx.save();
                    tempCtx.translate(centerX, centerY);
                    tempCtx.rotate(jiggleRotation);
                    tempCtx.translate(-centerX, -centerY);
                    drawPaperEdgeShadow(tempCtx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                    tempCtx.restore();
                }

                if (style === 'highlight') {
                    // Use offscreen canvas for highlight compositing
                    offGifCtx.clearRect(0, 0, gifWidth, gifHeight);

                    // Apply rotation transform
                    offGifCtx.save();
                    offGifCtx.translate(centerX, centerY);
                    offGifCtx.rotate(jiggleRotation);
                    offGifCtx.translate(-centerX, -centerY);

                    // Apply paper edge clipping if enabled
                    if (usePaperEdges) {
                        offGifCtx.save();
                        applyPaperEdgeClip(offGifCtx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                    }

                    // Draw highlights first on offscreen
                    currentRegions.forEach((region, index) => {
                        const regionStartTime = isSimultaneous ? 0 : index * delayMs;
                        const regionElapsed = elapsed - regionStartTime;

                        if (regionElapsed > 0) {
                            let progress = Math.min(regionElapsed / durationMs, 1);
                            progress = easingFn(progress);

                            const highlightWidth = region.width * regionScale * progress;

                            offGifCtx.fillStyle = color;
                            offGifCtx.fillRect(
                                offsetX + region.x * regionScale,
                                offsetY + region.y * regionScale,
                                highlightWidth,
                                region.height * regionScale
                            );
                        }
                    });

                    // Draw document with multiply blend mode on offscreen
                    offGifCtx.globalCompositeOperation = 'multiply';
                    offGifCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                    offGifCtx.globalCompositeOperation = 'source-over';

                    // Restore non-highlighted areas on offscreen
                    offGifCtx.globalCompositeOperation = 'destination-over';
                    offGifCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);
                    offGifCtx.globalCompositeOperation = 'source-over';

                    if (usePaperEdges) {
                        offGifCtx.restore();
                    }
                    offGifCtx.restore(); // Restore rotation

                    // Draw composited result onto main canvas (which already has background)
                    tempCtx.drawImage(offscreenGif, 0, 0);
                } else {
                    // Underline style: draw document first, then underlines
                    tempCtx.save();
                    tempCtx.translate(centerX, centerY);
                    tempCtx.rotate(jiggleRotation);
                    tempCtx.translate(-centerX, -centerY);

                    if (usePaperEdges) {
                        tempCtx.save();
                        applyPaperEdgeClip(tempCtx, offsetX, offsetY, scaledWidth, scaledHeight, paperEdgeIntensity);
                    }

                    tempCtx.drawImage(documentCanvas, offsetX, offsetY, scaledWidth, scaledHeight);

                    currentRegions.forEach((region, index) => {
                        const regionStartTime = isSimultaneous ? 0 : index * delayMs;
                        const regionElapsed = elapsed - regionStartTime;

                        if (regionElapsed > 0) {
                            let progress = Math.min(regionElapsed / durationMs, 1);
                            progress = easingFn(progress);

                            const underlineWidth = region.width * regionScale * progress;
                            const underlineY = offsetY + (region.y + region.height) * regionScale - uThickness;

                            tempCtx.fillStyle = color;
                            tempCtx.fillRect(
                                offsetX + region.x * regionScale,
                                underlineY,
                                underlineWidth,
                                uThickness
                            );
                        }
                    });

                    if (usePaperEdges) {
                        tempCtx.restore();
                    }
                    tempCtx.restore(); // Restore rotation
                }

                frames.push(tempCanvas.toDataURL('image/png'));
            }

            // Add a few frames at the end with full highlight
            for (let i = 0; i < 10; i++) {
                frames.push(frames[frames.length - 1]);
            }

            gifshot.createGIF({
                images: frames,
                gifWidth: tempCanvas.width,
                gifHeight: tempCanvas.height,
                interval: frameInterval / 1000,
                numWorkers: 4
            }, function(obj) {
                if (!obj.error) {
                    const link = document.createElement('a');
                    link.download = 'highlight-animation.gif';
                    link.href = obj.image;
                    link.click();
                }
                exportGifBtn.textContent = originalText;
                exportGifBtn.disabled = false;
            });
        }

        // Initialize
        drawBackground();

        // Resize handler
        window.addEventListener('resize', () => {
            drawBackground();
            if (documentImage && highlightRegions.length > 0) {
                restartAnimation();
            }
        });
    </script>
</body>
</html>
