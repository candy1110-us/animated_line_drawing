<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Animation - Flying Words</title>
    <link rel="stylesheet" href="css/index8.css">
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="main-layout">
            <!-- LEFT - Sidebar -->
            <div class="sidebar">
                <a href="index.html" class="logo-link">
                    <img src="images/baconegg.gif" alt="Logo" class="header-logo">
                    <span class="logo-title">Text Entrance Effect</span>
                </a>

                <!-- Text Input -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 10H3"/><path d="M21 6H3"/><path d="M21 14H3"/><path d="M17 18H3"/></svg></span>
                        Text
                    </div>
                    <div class="sidebar-control">
                        <textarea id="animationText" rows="3" placeholder="Enter your text here..." class="sidebar-textarea">Add text here to start animating</textarea>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Font</span>
                            <select id="fontFamily" class="full-width-select">
                                <option value="Inter">Inter</option>
                                <option value="HMT Regular" selected>HMT Regular</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                                <option value="Courier New">Courier New</option>
                                <option value="Comic Sans MS">Comic Sans MS</option>
                                <option value="Impact">Impact</option>
                            </select>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Size</span>
                            <input type="text" id="fontSize" value="35" class="sidebar-input" style="width: 60px; text-align: center;">
                        </div>
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="textColorIndicator" style="cursor: pointer;">
                            <span class="label-text">Color</span>
                            <div id="textColorPreview" class="color-preview-box" style="background: #000000;"></div>
                        </div>
                        <input type="color" id="textColor" value="#000000" class="color-input" style="display: none;">
                        <div id="textColorPopup" class="popup-menu">
                            <div class="color-square" id="textColorSquare">
                                <div class="color-overlay"></div>
                                <div id="textColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="textHueSlider">
                                <div id="textHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="textColorHexInput" value="#000000" class="hex-input">
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Canvas Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span>
                        Canvas
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="bgColorIndicator" style="cursor: pointer;">
                            <span class="label-text">Background</span>
                            <div id="bgColorPreview" class="color-preview-box" style="background: #00ff00;"></div>
                        </div>
                        <input type="color" id="backgroundColor" value="#00ff00" class="color-input" style="display: none;">
                        <div id="bgColorPopup" class="popup-menu">
                            <div class="color-square" id="bgColorSquare">
                                <div class="color-overlay"></div>
                                <div id="bgColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="bgHueSlider">
                                <div id="bgHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="bgColorHexInput" value="#00ff00" class="hex-input">
                            </div>
                            <div style="border-top: 1px solid #e5e7eb; padding-top: 10px;">
                                <div style="font-size: 11px; color: #9ca3af; margin-bottom: 6px;">Or use background image:</div>
                                <div class="bg-upload-area" id="bgImageUploadArea">
                                    <input type="file" id="bgImageUpload" accept="image/*" style="display: none;">
                                    <div id="bgUploadPlaceholder">
                                        <span style="font-size: 12px; color: #f59e0b; font-weight: 600;">Click to upload</span>
                                    </div>
                                    <div id="bgImagePreviewEl" style="display: none; text-align: center;">
                                        <img id="bgPreviewImg" class="bg-thumb" />
                                        <div class="bg-upload-actions">
                                            <span id="changeBgImage" style="color: #f59e0b;">Change</span>
                                            <span style="color: #d1d5db;">|</span>
                                            <span id="removeBgImage" style="color: #dd6143;">Remove</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Ratio</span>
                            <div class="aspect-ratio-group">
                                <button class="aspect-ratio-btn selected" id="ratio16x9" title="16:9 Landscape">
                                    <svg width="20" height="12" viewBox="0 0 20 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="0.5" y="0.5" width="19" height="11" rx="1" stroke="currentColor" fill="none"/>
                                    </svg>
                                    <span>16:9</span>
                                </button>
                                <button class="aspect-ratio-btn" id="ratio9x16" title="9:16 Portrait">
                                    <svg width="12" height="20" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="0.5" y="0.5" width="11" height="19" rx="1" stroke="currentColor" fill="none"/>
                                    </svg>
                                    <span>9:16</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Animation Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg></span>
                        Animation
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="highlightColorIndicator" style="cursor: pointer;">
                            <span class="label-text">Highlight color</span>
                            <div id="highlightColorPreview" class="color-preview-box" style="background: #ffeb3b;"></div>
                        </div>
                        <input type="color" id="highlightColor" value="#ffeb3b" class="color-input" style="display: none;">
                        <div id="highlightColorPopup" class="popup-menu">
                            <div class="color-square" id="highlightColorSquare">
                                <div class="color-overlay"></div>
                                <div id="highlightColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="highlightHueSlider">
                                <div id="highlightHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="highlightColorHexInput" value="#ffeb3b" class="hex-input">
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Jiggle</span>
                            <input type="range" id="jiggleIntensity" min="0" max="5" step="0.5" value="2" class="slider-compact">
                            <span class="value-display" id="jiggleValue">2</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Line spacing</span>
                            <input type="range" id="lineSpacing" min="0" max="100" step="5" value="15" class="slider-compact">
                            <span class="value-display" id="lineSpacingValue">15px</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Duration</span>
                            <input type="range" id="animationDuration" min="0.2" max="5" step="0.1" value="1" class="slider-compact">
                            <span class="value-display" id="durationValue">1.0s</span>
                        </div>
                    </div>
                </div>

                <div class="export-buttons">
                    <button class="btn-primary" id="playAnimation">Animate</button>
                    <button class="btn-primary" id="downloadGifBtn" style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">Export GIF</button>
                </div>
            </div>

            <!-- RIGHT - Preview -->
            <div class="preview-section">
                <div class="preview-content-wrapper">
                    <div class="animation-wrapper" id="animationWrapper">
                        <button id="resetPositionBtn" class="reset-position-btn">â†º Center</button>
                        <div class="animation-stage" id="animationStage">
                            <!-- Words will be inserted here -->
                        </div>
                    </div>
                </div>
                <p style="text-align: center; font-size: 11px; color: #9ca3af; margin-top: 12px;">Tip: Drag the text to reposition it on the canvas</p>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const animationTextInput = document.getElementById('animationText');
        const fontFamilySelect = document.getElementById('fontFamily');
        const fontSizeInput = document.getElementById('fontSize');
        const textColorInput = document.getElementById('textColor');
        const highlightColorInput = document.getElementById('highlightColor');
        const backgroundColorInput = document.getElementById('backgroundColor');
        // Background image upload elements
        const bgImageUpload = document.getElementById('bgImageUpload');
        const bgImageUploadArea = document.getElementById('bgImageUploadArea');
        const bgUploadPlaceholder = document.getElementById('bgUploadPlaceholder');
        const bgImagePreviewEl = document.getElementById('bgImagePreviewEl');
        const bgPreviewImg = document.getElementById('bgPreviewImg');
        const removeBgImageBtn = document.getElementById('removeBgImage');
        const jiggleIntensitySlider = document.getElementById('jiggleIntensity');
        const jiggleValue = document.getElementById('jiggleValue');
        const lineSpacingSlider = document.getElementById('lineSpacing');
        const lineSpacingValue = document.getElementById('lineSpacingValue');
        const animationDurationSlider = document.getElementById('animationDuration');
        const durationValue = document.getElementById('durationValue');
        const playButton = document.getElementById('playAnimation');
        const animationStage = document.getElementById('animationStage');
        const animationWrapper = document.getElementById('animationWrapper');

        let currentAspectRatio = '16:9';
        let backgroundImageUrl = null;

        // Text position offset (for dragging)
        let textOffsetX = 0;
        let textOffsetY = 0;

        // Drag functionality for animation stage
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let initialOffsetX = 0;
        let initialOffsetY = 0;

        animationStage.addEventListener('mousedown', (e) => {
            isDragging = true;
            animationStage.classList.add('dragging');
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            initialOffsetX = textOffsetX;
            initialOffsetY = textOffsetY;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            textOffsetX = initialOffsetX + deltaX;
            textOffsetY = initialOffsetY + deltaY;
            animationStage.style.transform = `translate(${textOffsetX}px, ${textOffsetY}px)`;
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                animationStage.classList.remove('dragging');
            }
        });

        // Touch support for mobile
        animationStage.addEventListener('touchstart', (e) => {
            isDragging = true;
            animationStage.classList.add('dragging');
            dragStartX = e.touches[0].clientX;
            dragStartY = e.touches[0].clientY;
            initialOffsetX = textOffsetX;
            initialOffsetY = textOffsetY;
        }, { passive: true });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const deltaX = e.touches[0].clientX - dragStartX;
            const deltaY = e.touches[0].clientY - dragStartY;
            textOffsetX = initialOffsetX + deltaX;
            textOffsetY = initialOffsetY + deltaY;
            animationStage.style.transform = `translate(${textOffsetX}px, ${textOffsetY}px)`;
        }, { passive: true });

        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                animationStage.classList.remove('dragging');
            }
        });

        // Reset position button
        const resetPositionBtn = document.getElementById('resetPositionBtn');
        resetPositionBtn.addEventListener('click', () => {
            textOffsetX = 0;
            textOffsetY = 0;
            animationStage.style.transform = '';
        });

        // Update font size display and validation
        fontSizeInput.addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/[^0-9]/g, '');
        });

        fontSizeInput.addEventListener('blur', (e) => {
            let value = parseInt(e.target.value);
            if (isNaN(value) || value < 20) value = 20;
            if (value > 120) value = 120;
            e.target.value = value;
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        fontSizeInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') e.target.blur();
        });

        // Update jiggle intensity display
        jiggleIntensitySlider.addEventListener('input', (e) => {
            jiggleValue.textContent = e.target.value;
        });

        // Update line spacing display
        lineSpacingSlider.addEventListener('input', (e) => {
            lineSpacingValue.textContent = e.target.value + 'px';
            animationStage.style.setProperty('--line-spacing', e.target.value);
        });

        // Update animation duration display
        animationDurationSlider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            durationValue.textContent = value.toFixed(1) + 's';
        });

        // Update text color
        textColorInput.addEventListener('input', (e) => {
            document.getElementById('textColorPreview').style.background = e.target.value;
            if (animationStage.children.length > 0) {
                const words = animationStage.querySelectorAll('.word');
                words.forEach(word => { word.style.color = e.target.value; });
            }
        });

        // Update highlight color
        highlightColorInput.addEventListener('input', (e) => {
            document.getElementById('highlightColorPreview').style.background = e.target.value;
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        // Update background color (only if no background image)
        backgroundColorInput.addEventListener('input', (e) => {
            document.getElementById('bgColorPreview').style.background = e.target.value;
            if (!backgroundImageUrl) {
                animationWrapper.style.background = e.target.value;
            }
        });

        // Background image upload
        bgImageUploadArea.addEventListener('click', (e) => {
            e.stopPropagation();
            if (e.target.id === 'removeBgImage') {
                backgroundImageUrl = null;
                bgImageUpload.value = '';
                bgImagePreviewEl.style.display = 'none';
                bgUploadPlaceholder.style.display = '';
                animationWrapper.style.background = backgroundColorInput.value;
                animationWrapper.style.backgroundSize = '';
                animationWrapper.style.backgroundPosition = '';
                document.getElementById('bgColorPreview').style.background = backgroundColorInput.value;
                return;
            }
            if (e.target.id === 'changeBgImage' || !backgroundImageUrl) {
                bgImageUpload.click();
            }
        });

        bgImageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    backgroundImageUrl = event.target.result;
                    bgPreviewImg.src = backgroundImageUrl;
                    bgUploadPlaceholder.style.display = 'none';
                    bgImagePreviewEl.style.display = '';
                    animationWrapper.style.background = `url(${backgroundImageUrl}) center/cover`;
                    animationWrapper.style.backgroundSize = 'cover';
                    animationWrapper.style.backgroundPosition = 'center';
                    document.getElementById('bgColorPreview').style.background = `url(${backgroundImageUrl}) center/cover`;
                };
                reader.readAsDataURL(file);
            }
        });

        // Aspect ratio selection
        const ratio16x9 = document.getElementById('ratio16x9');
        const ratio9x16 = document.getElementById('ratio9x16');

        ratio16x9.addEventListener('click', () => {
            currentAspectRatio = '16:9';
            ratio16x9.classList.add('selected');
            ratio9x16.classList.remove('selected');
            animationWrapper.classList.remove('ratio-9-16');
        });

        ratio9x16.addEventListener('click', () => {
            currentAspectRatio = '9:16';
            ratio9x16.classList.add('selected');
            ratio16x9.classList.remove('selected');
            animationWrapper.classList.add('ratio-9-16');
        });

        // Function to create word elements
        function createWordElements(text) {
            animationStage.innerHTML = '';
            const lines = text.trim().split('\n');

            lines.forEach((line, lineIndex) => {
                const words = line.trim().split(/\s+/).filter(w => w.length > 0);

                words.forEach((word, wordIndex) => {
                    const wordSpan = document.createElement('span');
                    wordSpan.className = 'word';
                    wordSpan.textContent = word;
                    wordSpan.style.fontFamily = fontFamilySelect.value;
                    wordSpan.style.fontSize = fontSizeInput.value + 'px';
                    wordSpan.style.color = textColorInput.value;

                    const highlightColor = highlightColorInput.value;
                    const r = parseInt(highlightColor.slice(1, 3), 16);
                    const g = parseInt(highlightColor.slice(3, 5), 16);
                    const b = parseInt(highlightColor.slice(5, 7), 16);
                    wordSpan.style.backgroundColor = `rgba(${r}, ${g}, ${b}, 1)`;

                    const jiggle = parseInt(jiggleIntensitySlider.value);
                    wordSpan.style.setProperty('--jiggle-1', `${jiggle}deg`);
                    wordSpan.style.setProperty('--jiggle-2', `-${jiggle}deg`);
                    wordSpan.style.setProperty('--jiggle-3', `${jiggle / 2}deg`);

                    animationStage.appendChild(wordSpan);
                });

                if (lineIndex < lines.length - 1) {
                    const lineBreak = document.createElement('div');
                    lineBreak.style.width = '100%';
                    lineBreak.style.height = '0';
                    animationStage.appendChild(lineBreak);
                }
            });
        }

        // Function to play animation
        function playAnimation() {
            const words = animationStage.querySelectorAll('.word');
            const totalDuration = parseFloat(animationDurationSlider.value) * 1000;
            const delayBetweenWords = words.length > 1 ? totalDuration / words.length : 0;

            words.forEach((word) => {
                word.classList.remove('animate');
                word.classList.add('animating');
            });

            void animationStage.offsetWidth;

            words.forEach((word, index) => {
                setTimeout(() => {
                    word.classList.add('animate');
                }, index * delayBetweenWords);
            });
        }

        // Event listeners
        playButton.addEventListener('click', playAnimation);

        animationTextInput.addEventListener('input', () => {
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        fontFamilySelect.addEventListener('change', () => {
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        textColorInput.addEventListener('change', () => {
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        highlightColorInput.addEventListener('change', () => {
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        jiggleIntensitySlider.addEventListener('input', () => {
            if (animationStage.children.length > 0) {
                createWordElements(animationTextInput.value);
            }
        });

        // Initialize with default text
        createWordElements(animationTextInput.value);

        // Custom Color Picker Functionality
        function setupColorPicker(config) {
            const { triggerEl, popupEl, squareEl, cursorEl, hueSliderEl, hueCursorEl, hexInputEl, colorInputEl, swatchEl } = config;

            let currentHue = 0;
            let currentSaturation = 100;
            let currentValue = 100;

            function hexToHsv(hex) {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, v = max;
                const d = max - min;
                s = max === 0 ? 0 : d / max;
                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                        case g: h = ((b - r) / d + 2) / 6; break;
                        case b: h = ((r - g) / d + 4) / 6; break;
                    }
                }
                return { h: Math.round(h * 360), s: Math.round(s * 100), v: Math.round(v * 100) };
            }

            function hsvToHex(h, s, v) {
                s /= 100; v /= 100;
                const i = Math.floor(h / 60) % 6;
                const f = h / 60 - Math.floor(h / 60);
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);
                let r, g, b;
                switch (i) {
                    case 0: r = v; g = t; b = p; break;
                    case 1: r = q; g = v; b = p; break;
                    case 2: r = p; g = v; b = t; break;
                    case 3: r = p; g = q; b = v; break;
                    case 4: r = t; g = p; b = v; break;
                    case 5: r = v; g = p; b = q; break;
                }
                return '#' + [r, g, b].map(x => {
                    const hex = Math.round(x * 255).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                }).join('');
            }

            function initFromHex(hex) {
                const hsv = hexToHsv(hex);
                currentHue = hsv.h;
                currentSaturation = hsv.s;
                currentValue = hsv.v;
                updateUI();
            }

            function updateUI() {
                const hex = hsvToHex(currentHue, currentSaturation, currentValue);
                const hueRgb = hsvToHex(currentHue, 100, 100);
                squareEl.style.background = `linear-gradient(to right, white, ${hueRgb})`;
                swatchEl.style.background = hex;
                hexInputEl.value = hex;
                colorInputEl.value = hex;

                cursorEl.style.left = (currentSaturation) + '%';
                cursorEl.style.top = (100 - currentValue) + '%';
                hueCursorEl.style.left = (currentHue / 360) * 100 + '%';
            }

            triggerEl.addEventListener('click', (e) => {
                e.stopPropagation();
                const isVisible = popupEl.classList.contains('visible');
                document.querySelectorAll('.popup-menu').forEach(p => p.classList.remove('visible'));
                if (!isVisible) {
                    popupEl.classList.add('visible');
                    initFromHex(colorInputEl.value);
                }
            });

            let isDraggingSquare = false;
            let isDraggingHue = false;

            squareEl.addEventListener('mousedown', (e) => {
                isDraggingSquare = true;
                updateFromSquare(e);
            });

            hueSliderEl.addEventListener('mousedown', (e) => {
                isDraggingHue = true;
                updateFromHue(e);
            });

            document.addEventListener('mousemove', (e) => {
                if (isDraggingSquare) updateFromSquare(e);
                if (isDraggingHue) updateFromHue(e);
            });

            document.addEventListener('mouseup', () => {
                isDraggingSquare = false;
                isDraggingHue = false;
            });

            function updateFromSquare(e) {
                const rect = squareEl.getBoundingClientRect();
                currentSaturation = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
                currentValue = Math.max(0, Math.min(100, 100 - ((e.clientY - rect.top) / rect.height) * 100));
                updateUI();
                colorInputEl.dispatchEvent(new Event('input'));
            }

            function updateFromHue(e) {
                const rect = hueSliderEl.getBoundingClientRect();
                currentHue = Math.max(0, Math.min(360, ((e.clientX - rect.left) / rect.width) * 360));
                updateUI();
                colorInputEl.dispatchEvent(new Event('input'));
            }

            hexInputEl.addEventListener('change', (e) => {
                let hex = e.target.value;
                if (!hex.startsWith('#')) hex = '#' + hex;
                if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
                    initFromHex(hex);
                    colorInputEl.value = hex;
                    colorInputEl.dispatchEvent(new Event('input'));
                }
            });

            initFromHex(colorInputEl.value);
        }

        // Setup text color picker
        setupColorPicker({
            triggerEl: document.getElementById('textColorIndicator'),
            popupEl: document.getElementById('textColorPopup'),
            squareEl: document.getElementById('textColorSquare'),
            cursorEl: document.getElementById('textColorCursor'),
            hueSliderEl: document.getElementById('textHueSlider'),
            hueCursorEl: document.getElementById('textHueCursor'),
            hexInputEl: document.getElementById('textColorHexInput'),
            colorInputEl: document.getElementById('textColor'),
            swatchEl: document.getElementById('textColorPreview')
        });

        // Setup highlight color picker
        setupColorPicker({
            triggerEl: document.getElementById('highlightColorIndicator'),
            popupEl: document.getElementById('highlightColorPopup'),
            squareEl: document.getElementById('highlightColorSquare'),
            cursorEl: document.getElementById('highlightColorCursor'),
            hueSliderEl: document.getElementById('highlightHueSlider'),
            hueCursorEl: document.getElementById('highlightHueCursor'),
            hexInputEl: document.getElementById('highlightColorHexInput'),
            colorInputEl: document.getElementById('highlightColor'),
            swatchEl: document.getElementById('highlightColorPreview')
        });

        // Setup background color picker
        setupColorPicker({
            triggerEl: document.getElementById('bgColorIndicator'),
            popupEl: document.getElementById('bgColorPopup'),
            squareEl: document.getElementById('bgColorSquare'),
            cursorEl: document.getElementById('bgColorCursor'),
            hueSliderEl: document.getElementById('bgHueSlider'),
            hueCursorEl: document.getElementById('bgHueCursor'),
            hexInputEl: document.getElementById('bgColorHexInput'),
            colorInputEl: document.getElementById('backgroundColor'),
            swatchEl: document.getElementById('bgColorPreview')
        });

        // Close popups when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.popup-menu') && !e.target.closest('.sidebar-control-row')) {
                document.querySelectorAll('.popup-menu').forEach(p => p.classList.remove('visible'));
            }
        });

        // Download GIF functionality
        let isCreatingGif = false;
        const downloadGifBtn = document.getElementById('downloadGifBtn');

        if (downloadGifBtn) {
            downloadGifBtn.addEventListener('click', async () => {
                if (isCreatingGif) return;

                downloadGifBtn.disabled = true;
                downloadGifBtn.textContent = 'Creating GIF...';
                isCreatingGif = true;

                try {
                    await captureAnimationAsGif();
                    downloadGifBtn.textContent = 'GIF Downloaded!';
                    setTimeout(() => {
                        downloadGifBtn.textContent = 'Export GIF';
                        downloadGifBtn.disabled = false;
                        isCreatingGif = false;
                    }, 2000);
                } catch (error) {
                    console.error('Error creating GIF:', error);
                    downloadGifBtn.textContent = 'Error: ' + (error.message || 'Failed');
                    setTimeout(() => {
                        downloadGifBtn.textContent = 'Export GIF';
                        downloadGifBtn.disabled = false;
                        isCreatingGif = false;
                    }, 3000);
                }
            });
        }

        async function captureAnimationAsGif() {
            if (typeof gifshot === 'undefined') {
                throw new Error('gifshot library not loaded');
            }

            const text = animationTextInput.value.trim();
            if (!text) {
                throw new Error('No text to animate');
            }

            if (document.fonts) {
                await document.fonts.ready;
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            const animDuration = parseFloat(animationDurationSlider.value) * 1000;
            const fps = 20;
            const frameTime = 1000 / fps;

            createWordElements(text);
            await new Promise(resolve => setTimeout(resolve, 200));

            const words = Array.from(animationStage.querySelectorAll('.word'));
            const delayBetweenWords = words.length > 1 ? animDuration / words.length : 0;
            const flyInDuration = 800;
            const extraJiggleTime = 1000;

            const totalAnimDuration = animDuration + flyInDuration + extraJiggleTime;
            const totalFrames = Math.ceil(totalAnimDuration / frameTime);

            let canvasWidth, canvasHeight;
            if (currentAspectRatio === '16:9') {
                canvasWidth = 1280;
                canvasHeight = 720;
            } else {
                canvasWidth = 720;
                canvasHeight = 1280;
            }

            const wrapperRect = animationWrapper.getBoundingClientRect();
            const scaleX = canvasWidth / wrapperRect.width;
            const scaleY = canvasHeight / wrapperRect.height;

            const scaledOffsetX = textOffsetX * scaleX;
            const scaledOffsetY = textOffsetY * scaleY;

            animationStage.style.transform = '';
            const wordData = words
                .filter(word => word.classList.contains('word') && word.textContent.trim().length > 0)
                .map((word, index) => {
                    const rect = word.getBoundingClientRect();
                    const currentWrapperRect = animationWrapper.getBoundingClientRect();
                    const jiggleOffset = (index * 137.5) % 300;

                    return {
                        text: word.textContent,
                        x: rect.left - currentWrapperRect.left,
                        y: rect.top - currentWrapperRect.top,
                        fontSize: parseFloat(fontSizeInput.value),
                        fontFamily: fontFamilySelect.value,
                        color: textColorInput.value,
                        highlightColor: highlightColorInput.value,
                        highlightOpacity: 1,
                        jiggleOffset: jiggleOffset
                    };
                });
            if (textOffsetX !== 0 || textOffsetY !== 0) {
                animationStage.style.transform = `translate(${textOffsetX}px, ${textOffsetY}px)`;
            }

            const bgColor = backgroundColorInput.value;

            function easeIn(t) {
                return t * t * t;
            }

            function easeInOut(t) {
                return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
            }

            const images = [];

            let bgImage = null;
            if (backgroundImageUrl) {
                bgImage = await new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => resolve(null);
                    img.src = backgroundImageUrl;
                });
            }

            for (let frameIndex = 0; frameIndex < totalFrames; frameIndex++) {
                const currentTime = frameIndex * frameTime;

                const progress = Math.round((frameIndex / totalFrames) * 100);
                downloadGifBtn.textContent = `Creating GIF... ${progress}%`;

                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');

                if (bgImage) {
                    ctx.drawImage(bgImage, 0, 0, canvasWidth, canvasHeight);
                } else {
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                }

                wordData.forEach((data, wordIndex) => {
                    const startTime = wordIndex * delayBetweenWords;
                    const endTime = startTime + flyInDuration;

                    let opacity = 0;
                    let translateY = canvasHeight * 1.5;
                    let rotation = 0;

                    const jiggle = parseFloat(jiggleIntensitySlider.value);
                    const jiggleDuration = 300;
                    const jiggleProgress = ((currentTime + data.jiggleOffset) % jiggleDuration) / jiggleDuration;

                    let jiggleVal;
                    if (jiggleProgress <= 0.25) {
                        const t = jiggleProgress / 0.25;
                        jiggleVal = easeInOut(t) * jiggle;
                    } else if (jiggleProgress <= 0.5) {
                        const t = (jiggleProgress - 0.25) / 0.25;
                        jiggleVal = (1 - easeInOut(t)) * jiggle;
                    } else if (jiggleProgress <= 0.75) {
                        const t = (jiggleProgress - 0.5) / 0.25;
                        jiggleVal = -easeInOut(t) * jiggle;
                    } else {
                        const t = (jiggleProgress - 0.75) / 0.25;
                        jiggleVal = -(1 - easeInOut(t)) * jiggle;
                    }

                    if (currentTime < startTime) {
                        return;
                    } else if (currentTime >= endTime) {
                        opacity = 1;
                        translateY = 0;
                        rotation = jiggleVal;
                    } else {
                        const elapsed = currentTime - startTime;
                        const progress = elapsed / flyInDuration;
                        const easedProgress = easeIn(progress);
                        opacity = easedProgress;

                        if (progress <= 0.6) {
                            const flyProgress = progress / 0.6;
                            const easedFlyProgress = easeIn(flyProgress);
                            const startOffset = canvasHeight * 1.5;
                            const overshootOffset = -(data.fontSize * scaleX * 0.3);
                            translateY = startOffset - (startOffset - overshootOffset) * easedFlyProgress;
                        } else {
                            const settleProgress = (progress - 0.6) / 0.4;
                            const easedSettleProgress = easeInOut(settleProgress);
                            const overshootOffset = -(data.fontSize * scaleX * 0.3);
                            translateY = overshootOffset + (0 - overshootOffset) * easedSettleProgress;
                        }

                        rotation = jiggleVal;
                    }

                    if (opacity <= 0) return;

                    const x = (data.x * scaleX) + scaledOffsetX;
                    const y = (data.y * scaleY) + translateY + scaledOffsetY;

                    ctx.save();
                    ctx.globalAlpha = opacity;

                    ctx.font = `${data.fontSize * scaleX}px ${data.fontFamily}`;
                    const textMetrics = ctx.measureText(data.text);
                    const textWidth = textMetrics.width;
                    const textHeight = data.fontSize * scaleX;
                    const padding = 8 * scaleX;

                    const centerX = x + textWidth / 2;
                    const centerY = y + textHeight / 2;

                    ctx.translate(centerX, centerY);
                    ctx.rotate((rotation * Math.PI) / 180);
                    ctx.translate(-centerX, -centerY);

                    const r = parseInt(data.highlightColor.slice(1, 3), 16);
                    const g = parseInt(data.highlightColor.slice(3, 5), 16);
                    const b = parseInt(data.highlightColor.slice(5, 7), 16);

                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${data.highlightOpacity})`;
                    ctx.beginPath();
                    ctx.roundRect(x - padding, y - padding, textWidth + padding * 2, textHeight + padding, 6 * scaleX);
                    ctx.fill();

                    ctx.fillStyle = data.color;
                    ctx.textBaseline = 'top';
                    ctx.fillText(data.text, x, y);

                    ctx.restore();
                });

                images.push(canvas.toDataURL('image/png'));
            }

            if (images.length === 0) {
                throw new Error('No frames captured');
            }

            downloadGifBtn.textContent = 'Encoding GIF...';

            return new Promise((resolve, reject) => {
                gifshot.createGIF({
                    images: images,
                    gifWidth: canvasWidth,
                    gifHeight: canvasHeight,
                    interval: 1 / fps,
                    frameDuration: 1,
                    numFrames: images.length,
                    repeat: 0
                }, (obj) => {
                    if (!obj.error) {
                        const a = document.createElement('a');
                        a.href = obj.image;
                        a.download = 'text-animation.gif';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        resolve();
                    } else {
                        console.error('GIF creation error:', obj.error);
                        reject(new Error(obj.error));
                    }
                });
            });
        }
    </script>
</body>
</html>
