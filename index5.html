<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jiggle Line Drawing Animator</title>
    <link rel="stylesheet" href="css/index8.css">
</head>
<body>
    <div class="container">
        <div class="main-layout">
            <!-- LEFT - Sidebar -->
            <div class="sidebar">
                <a href="index.html" class="logo-link">
                    <img src="images/baconegg.gif" alt="Logo" class="header-logo">
                    <span class="logo-title">Make it jiggle</span>
                </a>

                <!-- Upload Section -->
                <div class="upload-section" id="uploadSection">
                    <input type="file" id="imageUpload" accept="image/png,image/gif,image/webp,image/jpeg,image/jpg">
                    <div id="uploadPlaceholder">
                        <label for="imageUpload" class="upload-label">
                            Upload Drawing
                        </label>
                        <div class="helper-text">
                            PNG or JPG
                        </div>
                    </div>
                    <div id="uploadPreview" class="hidden">
                        <div class="image-preview-container">
                            <img id="previewImg" class="image-preview" />
                        </div>
                        <div class="upload-actions">
                            <label for="imageUpload" class="helper-text" style="color: #f59e0b; cursor: pointer;">Change</label>
                            <span class="helper-text" style="color: #9ca3af;">|</span>
                            <span id="removeImage" class="helper-text" style="color: #dd6143; cursor: pointer;">Remove</span>
                        </div>
                    </div>
                </div>

                <!-- Canvas Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="3" x2="9" y2="21"/></svg></span>
                        Canvas
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="bgIndicator" style="cursor: pointer;">
                            <span class="label-text">Background</span>
                            <div id="bgPreview" class="color-preview-box" style="background: #ffffff;"></div>
                        </div>
                        <div id="bgPopup" class="popup-menu">
                            <div class="color-square" id="bgColorSquare">
                                <div class="color-overlay"></div>
                                <div id="bgColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="bgHueSlider">
                                <div id="bgHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="bgColorHexInput" value="#ffffff" class="hex-input">
                                <input type="color" id="bgColor" value="#ffffff" class="color-input">
                            </div>
                            <div style="border-top: 1px solid #e5e7eb; padding-top: 10px;">
                                <div style="font-size: 11px; color: #9ca3af; margin-bottom: 6px;">Or use background image:</div>
                                <div class="bg-upload-area" id="bgImageUploadArea">
                                    <input type="file" id="bgImageUpload" accept="image/*" style="display: none;">
                                    <div id="bgUploadPlaceholder">
                                        <span style="font-size: 12px; color: #f59e0b; font-weight: 600;">Click to upload</span>
                                    </div>
                                    <div id="bgImagePreview" style="display: none; text-align: center;">
                                        <img id="bgPreviewImg" class="bg-thumb" />
                                        <div class="bg-upload-actions">
                                            <span id="changeBgImage" style="color: #f59e0b;">Change</span>
                                            <span style="color: #d1d5db;">|</span>
                                            <span id="removeBgImage" style="color: #dd6143;">Remove</span>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Ratio</span>
                            <div class="aspect-ratio-group">
                                <button class="aspect-ratio-btn selected" id="ratio16x9" title="16:9 Landscape">
                                    <svg width="20" height="12" viewBox="0 0 20 12" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="0.5" y="0.5" width="19" height="11" rx="1" stroke="currentColor" fill="none"/>
                                    </svg>
                                    <span>16:9</span>
                                </button>
                                <button class="aspect-ratio-btn" id="ratio9x16" title="9:16 Portrait">
                                    <svg width="12" height="20" viewBox="0 0 12 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <rect x="0.5" y="0.5" width="11" height="19" rx="1" stroke="currentColor" fill="none"/>
                                    </svg>
                                    <span>9:16</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Drawing Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg></span>
                        Drawing
                    </div>
                    <div class="sidebar-control pos-relative">
                        <div class="sidebar-control-row" id="strokeIndicator" style="cursor: pointer;">
                            <span class="label-text">Stroke color</span>
                            <div id="strokePreview" class="color-preview-box" style="background: #000000;"></div>
                        </div>
                        <div id="strokePopup" class="popup-menu">
                            <div class="color-square" id="strokeColorSquare">
                                <div class="color-overlay"></div>
                                <div id="strokeColorCursor" class="color-cursor"></div>
                            </div>
                            <div class="hue-slider" id="strokeHueSlider">
                                <div id="strokeHueCursor" class="hue-cursor"></div>
                            </div>
                            <div class="flex-center-gap-8 mb-12">
                                <span class="label-text">Hex:</span>
                                <input type="text" id="strokeColorHexInput" value="#000000" class="hex-input">
                                <input type="color" id="strokeColor" value="#000000" class="color-input">
                            </div>
                            <div id="strokeThicknessSection" style="display: none; border-top: 1px solid #e5e7eb; padding-top: 12px;">
                                <div class="label-text" style="margin-bottom: 8px;">Line Thickness <span class="value-display" id="lineWidthDisplay2">0</span></div>
                                <input type="range" id="lineWidth2" min="-3" max="5" value="0" class="slider-compact">
                                <div class="helper-text">Adjust line thickness (-3 thinner, +5 thicker)</div>
                            </div>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Stroke width</span>
                            <input type="range" id="strokeWidth" min="2" max="12" value="4" class="stroke-width-slider">
                            <span class="value-display" id="strokeWidthDisplay">4px</span>
                        </div>
                    </div>
                    <div class="sidebar-control" id="thresholdGroup" style="display: none;">
                        <div class="sidebar-control-row">
                            <span class="label-text">Threshold</span>
                            <input type="range" id="threshold" min="50" max="220" value="128" class="slider-compact">
                            <span class="value-display" id="thresholdDisplay">128</span>
                        </div>
                    </div>
                    <label class="sidebar-control" id="applyToColorsGroup" style="display: none; cursor: pointer;">
                        <div class="sidebar-control-row">
                            <input type="checkbox" id="applyToColors" class="checkbox-input">
                            <span class="label-text">Keep colors</span>
                        </div>
                    </label>
                </div>

                <!-- Animation Settings -->
                <div class="sidebar-section">
                    <div class="sidebar-section-label">
                        <span class="sidebar-section-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg></span>
                        Animation
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Jiggle</span>
                            <div class="speed-group">
                                <button class="speed-btn jiggle-btn" data-value="1">Low</button>
                                <button class="speed-btn jiggle-btn selected" data-value="2">Med</button>
                                <button class="speed-btn jiggle-btn" data-value="3">High</button>
                            </div>
                            <input type="hidden" id="jiggleAmount" value="2">
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Frames</span>
                            <input type="range" id="frameCount" min="2" max="5" value="3" class="slider-compact">
                            <span class="value-display" id="frameCountDisplay">3</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Angle</span>
                            <input type="range" id="angleAmount" min="0" max="2" step="0.1" value="0.5" class="slider-compact">
                            <span class="value-display" id="angleDisplay">0.5°</span>
                        </div>
                    </div>
                    <div class="sidebar-control">
                        <div class="sidebar-control-row">
                            <span class="label-text">Speed</span>
                            <input type="range" id="animSpeed" min="50" max="300" step="10" value="120" class="slider-compact">
                            <span class="value-display" id="speedDisplay">120ms</span>
                        </div>
                    </div>
                </div>

                <div class="export-buttons">
                    <button class="btn-primary" id="exportGifBtn" disabled style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);"><span class="btn-text">Export GIF</span><span class="btn-loading"><span class="spinner"></span>Exporting...</span></button>
                </div>
            </div>

            <!-- RIGHT - Canvas Area -->
            <div class="preview-section">
                <div class="preview-content-wrapper">
                    <div id="canvasArea" style="display: flex; flex-direction: column; align-items: center; width: 100%;">
                        <div class="drawing-canvas-container ratio-16-9" id="drawingCanvasContainer">
                            <canvas id="drawingCanvas" width="640" height="360"></canvas>
                            <!-- Animation canvas overlaid on top, hidden by default -->
                            <canvas id="mainCanvas" class="preview-canvas" style="display: none;"></canvas>
                        </div>

                        <!-- Unified button row below canvas -->
                        <div class="canvas-actions">
                            <button class="canvas-action-btn" id="undoBtn">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
                                Undo
                            </button>
                            <button class="canvas-action-btn canvas-action-btn--danger" id="clearBtn">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                                Clear
                            </button>
                            <button class="canvas-action-btn canvas-action-btn--play" id="playBtn">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                                Play
                            </button>
                            <button class="canvas-action-btn canvas-action-btn--stop" id="stopBtn" style="display: none;">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
                                Stop
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <script>
        // State
        let uploadedImage = null;
        let processedImage = null;
        let isJpgUpload = false;
        let isUploadedFile = false;
        let jiggleFrames = [];
        let isAnimating = false;
        let animationId = null;
        let currentFrame = 0;
        let bgImageData = null;
        let cachedBgImage = null;
        let currentAspectRatio = '16:9';

        // Drag offset for repositioning the drawing
        let imageOffsetX = 0;
        let imageOffsetY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let initialOffsetX = 0;
        let initialOffsetY = 0;

        // Drawing state
        let isDrawing = false;
        let allStrokes = [];
        let currentStroke = [];
        let frameAngles = [];

        // DOM Elements
        const imageUpload = document.getElementById('imageUpload');
        const uploadSection = document.getElementById('uploadSection');
        const uploadPlaceholder = document.getElementById('uploadPlaceholder');
        const uploadPreview = document.getElementById('uploadPreview');
        const previewImg = document.getElementById('previewImg');
        const removeImage = document.getElementById('removeImage');
        const mainCanvas = document.getElementById('mainCanvas');
        const exportGifBtn = document.getElementById('exportGifBtn');

        // Views / buttons
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');

        // Sliders
        const jiggleAmount = document.getElementById('jiggleAmount');
        const frameCount = document.getElementById('frameCount');
        const angleAmount = document.getElementById('angleAmount');
        const animSpeed = document.getElementById('animSpeed');
        const bgColor = document.getElementById('bgColor');
        const strokeColorInput = document.getElementById('strokeColor');
        const strokeIndicator = document.getElementById('strokeIndicator');
        const strokePopup = document.getElementById('strokePopup');
        const strokePreview = document.getElementById('strokePreview');
        const strokeThicknessSection = document.getElementById('strokeThicknessSection');
        const lineWidth2 = document.getElementById('lineWidth2');
        const lineWidthDisplay2 = document.getElementById('lineWidthDisplay2');
        const threshold = document.getElementById('threshold');
        const thresholdGroup = document.getElementById('thresholdGroup');

        // Apply to Colors checkbox
        const applyToColors = document.getElementById('applyToColors');
        const applyToColorsGroup = document.getElementById('applyToColorsGroup');

        // Displays
        const frameCountDisplay = document.getElementById('frameCountDisplay');
        const angleDisplay = document.getElementById('angleDisplay');
        const speedDisplay = document.getElementById('speedDisplay');
        const bgPreview = document.getElementById('bgPreview');
        const bgPopup = document.getElementById('bgPopup');
        const bgIndicator = document.getElementById('bgIndicator');
        const thresholdDisplay = document.getElementById('thresholdDisplay');

        // Drawing elements
        const drawingCanvasContainer = document.getElementById('drawingCanvasContainer');
        // Animation uses the same container as drawing — no more view switching
        const previewContent = drawingCanvasContainer;
        const drawingCanvas = document.getElementById('drawingCanvas');
        const drawCtx = drawingCanvas.getContext('2d');
        const strokeWidthSlider = document.getElementById('strokeWidth');
        const strokeWidthDisplay = document.getElementById('strokeWidthDisplay');
        const undoBtn = document.getElementById('undoBtn');
        const clearBtn = document.getElementById('clearBtn');

        // Background image elements
        const bgImageUploadArea = document.getElementById('bgImageUploadArea');
        const bgImageUpload = document.getElementById('bgImageUpload');
        const bgUploadPlaceholder = document.getElementById('bgUploadPlaceholder');
        const bgImagePreview = document.getElementById('bgImagePreview');
        const bgPreviewImg = document.getElementById('bgPreviewImg');
        const changeBgImage = document.getElementById('changeBgImage');
        const removeBgImage = document.getElementById('removeBgImage');

        // Aspect ratio elements
        const ratio16x9Btn = document.getElementById('ratio16x9');
        const ratio9x16Btn = document.getElementById('ratio9x16');

        // Initialize drawing canvas
        drawCtx.strokeStyle = '#000000';
        drawCtx.lineWidth = 4;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        // Fill initial drawing canvas background
        drawCtx.fillStyle = '#ffffff';
        drawCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

        // ============================================
        // Play / Stop logic
        // ============================================
        function showDrawingView() {
            drawingCanvas.style.display = '';
            mainCanvas.style.display = 'none';
            drawingCanvasContainer.style.cursor = isUploadedFile ? 'default' : 'crosshair';
            undoBtn.disabled = false;
            clearBtn.disabled = false;
            playBtn.style.display = '';
            stopBtn.style.display = 'none';
            if (isUploadedFile && uploadedImage) {
                drawUploadedImageOnDrawingCanvas();
            } else {
                redrawDrawingCanvas();
            }
        }

        function showAnimationView() {
            drawingCanvas.style.display = 'none';
            mainCanvas.style.display = '';
            drawingCanvasContainer.style.cursor = 'grab';
            undoBtn.disabled = true;
            clearBtn.disabled = true;
            playBtn.style.display = 'none';
            stopBtn.style.display = '';
        }

        playBtn.addEventListener('click', () => {
            // Build the image from strokes if we have strokes but no uploadedImage
            if (!uploadedImage && allStrokes.length > 0) {
                updateDrawingImage();
                // Wait for image to load then start
                const waitAndPlay = () => {
                    if (uploadedImage && uploadedImage.complete) {
                        generateJiggleFrames();
                        showAnimationView();
                        startAnimation();
                    } else {
                        setTimeout(waitAndPlay, 10);
                    }
                };
                waitAndPlay();
                return;
            }

            if (!uploadedImage) return;

            // If frames need regeneration
            if (jiggleFrames.length === 0) {
                if (isUploadedFile) {
                    processUploadedImage().then(() => {
                        generateJiggleFrames();
                        showAnimationView();
                        startAnimation();
                    });
                } else {
                    generateJiggleFrames();
                    showAnimationView();
                    startAnimation();
                }
            } else {
                showAnimationView();
                startAnimation();
            }
        });

        stopBtn.addEventListener('click', () => {
            stopAnimation();
            showDrawingView();
        });

        // ============================================
        // Stroke color control
        // ============================================
        strokeColorInput.addEventListener('input', () => {
            drawCtx.strokeStyle = strokeColorInput.value;
            strokePreview.style.background = strokeColorInput.value;
            if (uploadedImage) {
                if (isUploadedFile) {
                    processUploadedImage().then(() => {
                        jiggleFrames = [];
                    });
                } else {
                    jiggleFrames = [];
                }
            }
        });

        // Stroke popup toggle
        strokeIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            strokePopup.classList.toggle('visible');
            bgPopup.classList.remove('visible');
        });

        strokePopup.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Line thickness in stroke popup (for uploaded images)
        lineWidth2.addEventListener('input', () => {
            const val = parseInt(lineWidth2.value);
            lineWidthDisplay2.textContent = val > 0 ? `+${val}` : val;
            if (isUploadedFile && uploadedImage) {
                processUploadedImage(val).then(() => {
                    jiggleFrames = [];
                });
            }
        });

        // Jiggle button handlers
        const jiggleBtns = document.querySelectorAll('.jiggle-btn');
        jiggleBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                jiggleBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                jiggleAmount.value = btn.dataset.value;
                jiggleFrames = [];
            });
        });

        // Update displays
        frameCount.addEventListener('input', () => {
            frameCountDisplay.textContent = frameCount.value;
            jiggleFrames = [];
        });

        angleAmount.addEventListener('input', () => {
            angleDisplay.textContent = angleAmount.value + '°';
            jiggleFrames = [];
        });

        animSpeed.addEventListener('input', () => {
            speedDisplay.textContent = animSpeed.value + 'ms';
        });

        // Apply to Colors checkbox handler
        applyToColors.addEventListener('change', () => {
            if (isUploadedFile && uploadedImage) {
                processUploadedImage().then(() => {
                    jiggleFrames = [];
                });
            }
        });

        bgColor.addEventListener('input', () => {
            bgPreview.style.background = bgColor.value;
            bgImageData = null;
            cachedBgImage = null;
            if (bgImagePreview) bgImagePreview.style.display = 'none';
            if (bgUploadPlaceholder) bgUploadPlaceholder.style.display = 'flex';
            // Update drawing canvas background
            if (!isAnimating) redrawDrawingCanvas();
        });

        // Aspect ratio handlers
        function selectAspectRatio(ratio) {
            currentAspectRatio = ratio;
            const isVertical = ratio === '9:16';

            ratio16x9Btn.classList.toggle('selected', !isVertical);
            ratio9x16Btn.classList.toggle('selected', isVertical);

            // Update canvas container (shared for drawing and animation)
            drawingCanvasContainer.classList.toggle('ratio-9-16', isVertical);
            drawingCanvasContainer.classList.toggle('ratio-16-9', !isVertical);

            // Update drawing canvas dimensions
            if (isVertical) {
                drawingCanvas.width = 360;
                drawingCanvas.height = 640;
            } else {
                drawingCanvas.width = 640;
                drawingCanvas.height = 360;
            }

            redrawStrokes();

            // If we have an uploaded image, redraw it on the drawing canvas
            if (isUploadedFile && uploadedImage) {
                drawUploadedImageOnDrawingCanvas();
            }

            jiggleFrames = [];
        }

        ratio16x9Btn.addEventListener('click', () => selectAspectRatio('16:9'));
        ratio9x16Btn.addEventListener('click', () => selectAspectRatio('9:16'));

        // Background image upload handlers
        if (bgImageUploadArea && bgImageUpload) {
            bgImageUploadArea.addEventListener('click', (e) => {
                if (e.target.id === 'changeBgImage') {
                    bgImageUpload.click();
                } else if (e.target.id === 'removeBgImage') {
                    bgImageData = null;
                    cachedBgImage = null;
                    bgImagePreview.style.display = 'none';
                    bgUploadPlaceholder.style.display = 'flex';
                    previewContent.style.background = '';
                } else if (!e.target.closest('#bgImagePreview') || e.target.id === 'changeBgImage') {
                    bgImageUpload.click();
                }
            });

            bgImageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        bgImageData = event.target.result;
                        bgPreviewImg.src = bgImageData;
                        bgUploadPlaceholder.style.display = 'none';
                        bgImagePreview.style.display = 'flex';
                        previewContent.style.background = `url(${bgImageData}) center/cover`;

                        cachedBgImage = new Image();
                        cachedBgImage.src = bgImageData;
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        threshold.addEventListener('input', () => {
            thresholdDisplay.textContent = threshold.value;
            if (isUploadedFile && uploadedImage) {
                processUploadedImage().then(() => {
                    jiggleFrames = [];
                });
            }
        });

        // Stroke width control
        strokeWidthSlider.addEventListener('input', () => {
            const width = parseInt(strokeWidthSlider.value);
            strokeWidthDisplay.textContent = width + 'px';
            drawCtx.lineWidth = width;
        });

        // ============================================
        // Drawing functions
        // ============================================
        function getDrawCoordinates(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;

            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            }
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            // Don't draw if an uploaded image is displayed on the drawing canvas
            if (isUploadedFile) return;
            e.preventDefault();
            isDrawing = true;
            const pos = getDrawCoordinates(e);
            currentStroke = [{ x: pos.x, y: pos.y }];
            drawCtx.beginPath();
            drawCtx.moveTo(pos.x, pos.y);
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            const pos = getDrawCoordinates(e);
            currentStroke.push({ x: pos.x, y: pos.y });
            drawCtx.lineTo(pos.x, pos.y);
            drawCtx.stroke();
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            if (e) e.preventDefault();
            isDrawing = false;
            if (currentStroke.length > 1) {
                allStrokes.push({
                    points: [...currentStroke],
                    lineWidth: drawCtx.lineWidth,
                    strokeColor: drawCtx.strokeStyle
                });
                // Convert drawing to image for animation
                updateDrawingImage();
            }
            currentStroke = [];
        }

        // Convert drawing strokes to an image for animation use (transparent bg)
        function updateDrawingImage() {
            if (allStrokes.length === 0) {
                uploadedImage = null;
                exportGifBtn.disabled = true;
                return;
            }
            // Render strokes onto a temporary transparent canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = drawingCanvas.width;
            tempCanvas.height = drawingCanvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.lineCap = 'round';
            tempCtx.lineJoin = 'round';
            allStrokes.forEach(stroke => {
                tempCtx.lineWidth = stroke.lineWidth;
                tempCtx.strokeStyle = stroke.strokeColor || '#000000';
                tempCtx.beginPath();
                tempCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                stroke.points.forEach(point => tempCtx.lineTo(point.x, point.y));
                tempCtx.stroke();
            });
            const dataUrl = tempCanvas.toDataURL('image/png');
            const img = new Image();
            img.onload = () => {
                uploadedImage = img;
                processedImage = null;
                isJpgUpload = false;
                isUploadedFile = false;
                exportGifBtn.disabled = false;
                jiggleFrames = [];
            };
            img.src = dataUrl;
        }

        // Draw uploaded image onto the drawing canvas (so user sees it)
        function drawUploadedImageOnDrawingCanvas() {
            if (!uploadedImage) return;
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            const sourceImg = (processedImage && processedImage.complete) ? processedImage : uploadedImage;

            // Fill with chosen background color
            fillDrawingBackground();

            // Fit image in canvas
            const scale = Math.min(
                (drawingCanvas.width * 0.9) / sourceImg.width,
                (drawingCanvas.height * 0.9) / sourceImg.height
            );
            const drawWidth = sourceImg.width * scale;
            const drawHeight = sourceImg.height * scale;
            const x = (drawingCanvas.width - drawWidth) / 2;
            const y = (drawingCanvas.height - drawHeight) / 2;

            drawCtx.drawImage(sourceImg, x, y, drawWidth, drawHeight);
        }

        // Mouse events for drawing
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseleave', stopDrawing);

        // Touch events for drawing
        drawingCanvas.addEventListener('touchstart', startDrawing);
        drawingCanvas.addEventListener('touchmove', draw);
        drawingCanvas.addEventListener('touchend', stopDrawing);

        // Fill drawing canvas with current background
        function fillDrawingBackground() {
            drawCtx.fillStyle = bgColor.value;
            drawCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        }

        // Redraw canvas from strokes
        function redrawDrawingCanvas() {
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            fillDrawingBackground();
            allStrokes.forEach(stroke => {
                drawCtx.lineWidth = stroke.lineWidth;
                drawCtx.strokeStyle = stroke.strokeColor || '#000000';
                drawCtx.beginPath();
                drawCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                stroke.points.forEach(point => {
                    drawCtx.lineTo(point.x, point.y);
                });
                drawCtx.stroke();
            });
            drawCtx.lineWidth = parseInt(strokeWidthSlider.value);
            drawCtx.strokeStyle = strokeColorInput.value;
        }

        // Redraw strokes scaled to new canvas dimensions
        function redrawStrokes() {
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            fillDrawingBackground();
            allStrokes.forEach(stroke => {
                drawCtx.lineWidth = stroke.lineWidth;
                drawCtx.strokeStyle = stroke.strokeColor || '#000000';
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                drawCtx.beginPath();
                if (stroke.points.length > 0) {
                    drawCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
                    stroke.points.forEach(point => {
                        drawCtx.lineTo(point.x, point.y);
                    });
                }
                drawCtx.stroke();
            });
            drawCtx.lineWidth = parseInt(strokeWidthSlider.value);
            drawCtx.strokeStyle = strokeColorInput.value;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';
        }

        // Undo button
        undoBtn.addEventListener('click', () => {
            if (allStrokes.length > 0) {
                allStrokes.pop();
                redrawDrawingCanvas();
                updateDrawingImage();
            }
        });

        // Clear button
        clearBtn.addEventListener('click', () => {
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            fillDrawingBackground();
            allStrokes = [];
            uploadedImage = null;
            processedImage = null;
            isUploadedFile = false;
            jiggleFrames = [];
            frameAngles = [];
            exportGifBtn.disabled = true;

            // Reset upload UI
            uploadPlaceholder.classList.remove('hidden');
            uploadPreview.classList.add('hidden');
            uploadSection.classList.remove('has-file');
            thresholdGroup.style.display = 'none';
            strokeThicknessSection.style.display = 'none';
            applyToColorsGroup.style.display = 'none';

            // If we were in animation view, switch back
            if (isAnimating) stopAnimation();
            showDrawingView();
        });

        // Background popup toggle
        bgIndicator.addEventListener('click', (e) => {
            e.stopPropagation();
            bgPopup.classList.toggle('visible');
            strokePopup.classList.remove('visible');
        });

        document.addEventListener('click', () => {
            bgPopup.classList.remove('visible');
            strokePopup.classList.remove('visible');
        });

        bgPopup.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // ============================================
        // Upload handling
        // ============================================
        uploadSection.addEventListener('click', (e) => {
            if (e.target.id === 'removeImage') return;
            if (!uploadSection.classList.contains('has-file')) {
                imageUpload.value = ''; // Reset to allow re-selecting same file
                imageUpload.click();
            }
        });

        imageUpload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        // Stop animation if running
                        if (isAnimating) stopAnimation();

                        uploadedImage = img;
                        processedImage = null;
                        previewImg.src = event.target.result;
                        uploadPlaceholder.classList.add('hidden');
                        uploadPreview.classList.remove('hidden');
                        uploadSection.classList.add('has-file');
                        exportGifBtn.disabled = false;

                        const fileType = file.type.toLowerCase();
                        isJpgUpload = fileType === 'image/jpeg' || fileType === 'image/jpg';
                        isUploadedFile = true;

                        imageOffsetX = 0;
                        imageOffsetY = 0;

                        // Show controls for uploaded images
                        thresholdGroup.style.display = '';
                        strokeThicknessSection.style.display = 'block';
                        applyToColorsGroup.style.display = '';

                        // Clear strokes since we're using uploaded image
                        allStrokes = [];
                        jiggleFrames = [];

                        // Process then show on drawing canvas
                        processUploadedImage().then(() => {
                            drawUploadedImageOnDrawingCanvas();
                        });

                        showDrawingView();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Remove image
        removeImage.addEventListener('click', (e) => {
            e.stopPropagation();
            clearAll();
        });

        function clearAll() {
            if (isAnimating) stopAnimation();

            uploadedImage = null;
            processedImage = null;
            isJpgUpload = false;
            isUploadedFile = false;
            jiggleFrames = [];
            allStrokes = [];

            imageOffsetX = 0;
            imageOffsetY = 0;
            uploadPlaceholder.classList.remove('hidden');
            uploadPreview.classList.add('hidden');
            uploadSection.classList.remove('has-file');
            exportGifBtn.disabled = true;
            imageUpload.value = '';
            thresholdGroup.style.display = 'none';
            strokeThicknessSection.style.display = 'none';
            applyToColorsGroup.style.display = 'none';

            // Clear the drawing canvas and refill background
            drawCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            fillDrawingBackground();
            showDrawingView();
        }

        // Get the image to use
        function getSourceImage() {
            if (isUploadedFile && processedImage && processedImage.complete) {
                return processedImage;
            }
            return uploadedImage;
        }

        // ============================================
        // Animation drawing
        // ============================================
        function drawOriginalImage() {
            if (!uploadedImage) return;

            const container = previewContent;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            mainCanvas.width = containerWidth;
            mainCanvas.height = containerHeight;

            const ctx = mainCanvas.getContext('2d');
            ctx.clearRect(0, 0, containerWidth, containerHeight);

            if (bgImageData && cachedBgImage) {
                ctx.drawImage(cachedBgImage, 0, 0, containerWidth, containerHeight);
            } else {
                ctx.fillStyle = bgColor.value;
                ctx.fillRect(0, 0, containerWidth, containerHeight);
            }

            const sourceImg = getSourceImage();
            const scaleFactor = isUploadedFile ? 0.9 : 1.0;
            const scale = Math.min(
                (containerWidth * scaleFactor) / uploadedImage.width,
                (containerHeight * scaleFactor) / uploadedImage.height
            );

            const drawWidth = uploadedImage.width * scale;
            const drawHeight = uploadedImage.height * scale;
            const x = (containerWidth - drawWidth) / 2 + imageOffsetX;
            const y = (containerHeight - drawHeight) / 2 + imageOffsetY;

            if (!isUploadedFile) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = sourceImg.width;
                tempCanvas.height = sourceImg.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(sourceImg, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;

                const strokeHex = strokeColorInput.value;
                const strokeR = parseInt(strokeHex.substr(1, 2), 16);
                const strokeG = parseInt(strokeHex.substr(3, 2), 16);
                const strokeB = parseInt(strokeHex.substr(5, 2), 16);

                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] > 0) {
                        data[i] = strokeR;
                        data[i + 1] = strokeG;
                        data[i + 2] = strokeB;
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(tempCanvas, x, y, drawWidth, drawHeight);
            } else {
                ctx.drawImage(sourceImg, x, y, drawWidth, drawHeight);
            }
        }

        // ============================================
        // Jiggle frame generation
        // ============================================
        function noise2D(x, y, seed) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + seed * 43.1234) * 43758.5453;
            return (n - Math.floor(n)) * 2 - 1;
        }

        function smoothNoise(x, y, seed, frequency) {
            const fx = x * frequency;
            const fy = y * frequency;

            const x0 = Math.floor(fx);
            const y0 = Math.floor(fy);
            const x1 = x0 + 1;
            const y1 = y0 + 1;

            const sx = fx - x0;
            const sy = fy - y0;

            const smoothX = sx * sx * (3 - 2 * sx);
            const smoothY = sy * sy * (3 - 2 * sy);

            const n00 = noise2D(x0, y0, seed);
            const n10 = noise2D(x1, y0, seed);
            const n01 = noise2D(x0, y1, seed);
            const n11 = noise2D(x1, y1, seed);

            const nx0 = n00 + smoothX * (n10 - n00);
            const nx1 = n01 + smoothX * (n11 - n01);

            return nx0 + smoothY * (nx1 - nx0);
        }

        function generateJiggleFrames() {
            const numFrames = parseInt(frameCount.value);
            const jiggle = parseInt(jiggleAmount.value);
            const maxAngle = parseFloat(angleAmount.value);

            const sourceImg = getSourceImage();
            if (!sourceImg || !sourceImg.complete) {
                console.error('Source image not ready');
                return;
            }

            const imgWidth = uploadedImage.width;
            const imgHeight = uploadedImage.height;

            if (imgWidth === 0 || imgHeight === 0) {
                console.error('Image has zero dimensions');
                return;
            }

            jiggleFrames = [];
            frameAngles = [];

            const srcCanvas = document.createElement('canvas');
            srcCanvas.width = imgWidth;
            srcCanvas.height = imgHeight;
            const srcCtx = srcCanvas.getContext('2d');
            srcCtx.drawImage(sourceImg, 0, 0, imgWidth, imgHeight);
            const srcData = srcCtx.getImageData(0, 0, imgWidth, imgHeight);

            if (!isUploadedFile) {
                const strokeHex = strokeColorInput.value;
                const strokeR = parseInt(strokeHex.substr(1, 2), 16);
                const strokeG = parseInt(strokeHex.substr(3, 2), 16);
                const strokeB = parseInt(strokeHex.substr(5, 2), 16);

                for (let i = 0; i < srcData.data.length; i += 4) {
                    if (srcData.data[i + 3] > 0) {
                        srcData.data[i] = strokeR;
                        srcData.data[i + 1] = strokeG;
                        srcData.data[i + 2] = strokeB;
                    }
                }
            }

            function bilinearSample(data, width, height, x, y) {
                const x0 = Math.floor(x);
                const y0 = Math.floor(y);
                const x1 = Math.min(x0 + 1, width - 1);
                const y1 = Math.min(y0 + 1, height - 1);

                const fx = x - x0;
                const fy = y - y0;

                const idx00 = (y0 * width + x0) * 4;
                const idx10 = (y0 * width + x1) * 4;
                const idx01 = (y1 * width + x0) * 4;
                const idx11 = (y1 * width + x1) * 4;

                const result = [0, 0, 0, 0];
                for (let c = 0; c < 4; c++) {
                    const v00 = data[idx00 + c];
                    const v10 = data[idx10 + c];
                    const v01 = data[idx01 + c];
                    const v11 = data[idx11 + c];

                    const v0 = v00 + fx * (v10 - v00);
                    const v1 = v01 + fx * (v11 - v01);
                    result[c] = Math.round(v0 + fy * (v1 - v0));
                }
                return result;
            }

            for (let f = 0; f < numFrames; f++) {
                const seedX = f * 100 + Math.random() * 1000;
                const seedY = f * 100 + 500 + Math.random() * 1000;

                const frameAngle = (Math.random() * 2 - 1) * maxAngle * (Math.PI / 180);
                frameAngles.push(frameAngle);

                const workCanvas = document.createElement('canvas');
                workCanvas.width = imgWidth;
                workCanvas.height = imgHeight;
                const workCtx = workCanvas.getContext('2d');
                const destData = workCtx.createImageData(imgWidth, imgHeight);

                const refSize = 500;
                const imgSize = Math.max(imgWidth, imgHeight);
                const displacementScale = imgSize / refSize;

                const frequency = (0.02 + (jiggle / 8) * 0.03) * (refSize / imgSize);

                for (let y = 0; y < imgHeight; y++) {
                    for (let x = 0; x < imgWidth; x++) {
                        const dispX = smoothNoise(x, y, seedX, frequency) * jiggle * displacementScale;
                        const dispY = smoothNoise(x, y, seedY, frequency) * jiggle * displacementScale;

                        const srcX = x - dispX;
                        const srcY = y - dispY;

                        const destIdx = (y * imgWidth + x) * 4;

                        if (srcX >= 0 && srcX < imgWidth - 1 && srcY >= 0 && srcY < imgHeight - 1) {
                            const pixel = bilinearSample(srcData.data, imgWidth, imgHeight, srcX, srcY);
                            destData.data[destIdx] = pixel[0];
                            destData.data[destIdx + 1] = pixel[1];
                            destData.data[destIdx + 2] = pixel[2];
                            destData.data[destIdx + 3] = pixel[3];
                        } else if (srcX >= 0 && srcX < imgWidth && srcY >= 0 && srcY < imgHeight) {
                            const srcIdx = (Math.floor(srcY) * imgWidth + Math.floor(srcX)) * 4;
                            destData.data[destIdx] = srcData.data[srcIdx];
                            destData.data[destIdx + 1] = srcData.data[srcIdx + 1];
                            destData.data[destIdx + 2] = srcData.data[srcIdx + 2];
                            destData.data[destIdx + 3] = srcData.data[srcIdx + 3];
                        } else {
                            destData.data[destIdx + 3] = 0;
                        }
                    }
                }

                workCtx.putImageData(destData, 0, 0);

                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = imgWidth;
                frameCanvas.height = imgHeight;
                const frameCtx = frameCanvas.getContext('2d');
                frameCtx.drawImage(workCanvas, 0, 0);

                jiggleFrames.push(frameCanvas);
            }

            currentFrame = 0;
            drawFrame(0);
        }

        function drawFrame(frameIndex) {
            if (jiggleFrames.length === 0) return;

            const container = previewContent;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            if (containerWidth === 0 || containerHeight === 0) return;

            mainCanvas.width = containerWidth;
            mainCanvas.height = containerHeight;

            const ctx = mainCanvas.getContext('2d');
            ctx.clearRect(0, 0, containerWidth, containerHeight);

            if (bgImageData && cachedBgImage) {
                ctx.drawImage(cachedBgImage, 0, 0, containerWidth, containerHeight);
            } else {
                ctx.fillStyle = bgColor.value;
                ctx.fillRect(0, 0, containerWidth, containerHeight);
            }

            const angle = frameAngles[frameIndex] || 0;
            const frame = jiggleFrames[frameIndex];
            const imgWidth = frame.width;
            const imgHeight = frame.height;

            const scaleFactor = isUploadedFile ? 0.9 : 1.0;
            const scale = Math.min(
                (containerWidth * scaleFactor) / imgWidth,
                (containerHeight * scaleFactor) / imgHeight
            );

            const drawWidth = imgWidth * scale;
            const drawHeight = imgHeight * scale;
            const x = (containerWidth - drawWidth) / 2 + imageOffsetX;
            const y = (containerHeight - drawHeight) / 2 + imageOffsetY;

            if (angle !== 0) {
                const centerX = x + drawWidth / 2;
                const centerY = y + drawHeight / 2;
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angle);
                ctx.drawImage(frame, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                ctx.restore();
            } else {
                ctx.drawImage(frame, x, y, drawWidth, drawHeight);
            }
        }

        // Drag functionality for repositioning on animation canvas
        mainCanvas.addEventListener('mousedown', (e) => {
            if (!uploadedImage) return;
            isDragging = true;
            mainCanvas.classList.add('dragging');
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            initialOffsetX = imageOffsetX;
            initialOffsetY = imageOffsetY;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - dragStartX;
            const deltaY = e.clientY - dragStartY;
            imageOffsetX = initialOffsetX + deltaX;
            imageOffsetY = initialOffsetY + deltaY;

            if (isAnimating) {
                drawFrame(currentFrame);
            } else {
                drawOriginalImage();
            }
        });

        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                mainCanvas.classList.remove('dragging');
            }
        });

        // Touch support for dragging
        mainCanvas.addEventListener('touchstart', (e) => {
            if (!uploadedImage) return;
            isDragging = true;
            mainCanvas.classList.add('dragging');
            dragStartX = e.touches[0].clientX;
            dragStartY = e.touches[0].clientY;
            initialOffsetX = imageOffsetX;
            initialOffsetY = imageOffsetY;
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const deltaX = e.touches[0].clientX - dragStartX;
            const deltaY = e.touches[0].clientY - dragStartY;
            imageOffsetX = initialOffsetX + deltaX;
            imageOffsetY = initialOffsetY + deltaY;

            if (isAnimating) {
                drawFrame(currentFrame);
            } else {
                drawOriginalImage();
            }
        }, { passive: true });

        document.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                mainCanvas.classList.remove('dragging');
            }
        });

        // ============================================
        // Animation start/stop
        // ============================================
        function startAnimation() {
            isAnimating = true;

            function animate() {
                if (!isAnimating) return;
                currentFrame = (currentFrame + 1) % jiggleFrames.length;
                drawFrame(currentFrame);
                animationId = setTimeout(animate, parseInt(animSpeed.value));
            }

            animate();
        }

        function stopAnimation() {
            isAnimating = false;
            if (animationId) {
                clearTimeout(animationId);
                animationId = null;
            }
        }

        // ============================================
        // Process uploaded image (line extraction)
        // ============================================
        function adjustLineWidth(mask, width, height, amount) {
            if (amount === 0) return mask;

            const result = new Uint8Array(width * height);
            const radius = Math.abs(amount);

            if (amount > 0) {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (mask[y * width + x]) {
                            for (let dy = -radius; dy <= radius; dy++) {
                                for (let dx = -radius; dx <= radius; dx++) {
                                    if (dx * dx + dy * dy <= radius * radius) {
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                            result[ny * width + nx] = 1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (mask[y * width + x]) {
                            let allSet = true;
                            outer: for (let dy = -radius; dy <= radius && allSet; dy++) {
                                for (let dx = -radius; dx <= radius && allSet; dx++) {
                                    if (dx * dx + dy * dy <= radius * radius) {
                                        const nx = x + dx;
                                        const ny = y + dy;
                                        if (nx < 0 || nx >= width || ny < 0 || ny >= height || !mask[ny * width + nx]) {
                                            allSet = false;
                                            break outer;
                                        }
                                    }
                                }
                            }
                            if (allSet) {
                                result[y * width + x] = 1;
                            }
                        }
                    }
                }
            }

            return result;
        }

        function processUploadedImage(lineWidthOverride) {
            return new Promise((resolve) => {
                if (!uploadedImage) {
                    resolve();
                    return;
                }

                const thresholdValue = parseInt(threshold.value);
                const lineWidthValue = lineWidthOverride !== undefined ? lineWidthOverride : parseInt(lineWidth2.value);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = uploadedImage.width;
                tempCanvas.height = uploadedImage.height;
                const tempCtx = tempCanvas.getContext('2d');

                tempCtx.drawImage(uploadedImage, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                const width = tempCanvas.width;
                const height = tempCanvas.height;

                const mask = new Uint8Array(width * height);
                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];
                    if (a >= 128) {
                        const brightness = (r + g + b) / 3;
                        if (brightness < thresholdValue) {
                            mask[i / 4] = 1;
                        }
                    }
                }

                const adjustedMask = adjustLineWidth(mask, width, height, lineWidthValue);

                const strokeHex = strokeColorInput.value;
                const strokeR = parseInt(strokeHex.substr(1, 2), 16);
                const strokeG = parseInt(strokeHex.substr(3, 2), 16);
                const strokeB = parseInt(strokeHex.substr(5, 2), 16);

                const keepColors = applyToColors.checked;

                let exterior = null;
                let outlinePaint = adjustedMask;
                if (keepColors) {
                    const contentMask = new Uint8Array(width * height);
                    for (let i = 0; i < data.length; i += 4) {
                        const a = data[i + 3];
                        if (a < 128) continue;
                        const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                        if (brightness < 240) {
                            contentMask[i / 4] = 1;
                        }
                    }

                    const barrier = new Uint8Array(width * height);
                    for (let i = 0; i < barrier.length; i++) {
                        if (adjustedMask[i] || contentMask[i]) barrier[i] = 1;
                    }

                    const dist = new Int32Array(width * height);
                    const queue = [];
                    let qHead = 0;
                    for (let i = 0; i < adjustedMask.length; i++) {
                        if (adjustedMask[i]) {
                            dist[i] = 0;
                            queue.push(i);
                        } else {
                            dist[i] = 3;
                        }
                    }
                    while (qHead < queue.length) {
                        const idx = queue[qHead++];
                        const d = dist[idx] + 1;
                        if (d > 1) continue;
                        const px = idx % width;
                        const py = (idx - px) / width;
                        if (px > 0 && d < dist[idx - 1]) { dist[idx - 1] = d; queue.push(idx - 1); }
                        if (px < width - 1 && d < dist[idx + 1]) { dist[idx + 1] = d; queue.push(idx + 1); }
                        if (py > 0 && d < dist[idx - width]) { dist[idx - width] = d; queue.push(idx - width); }
                        if (py < height - 1 && d < dist[idx + width]) { dist[idx + width] = d; queue.push(idx + width); }
                    }

                    outlinePaint = new Uint8Array(width * height);
                    for (let i = 0; i < dist.length; i++) {
                        if (dist[i] <= 1) outlinePaint[i] = 1;
                    }

                    exterior = new Uint8Array(width * height);
                    const stack = [];
                    for (let x = 0; x < width; x++) {
                        if (!barrier[x] && !exterior[x]) { stack.push(x); exterior[x] = 1; }
                        const bottom = (height - 1) * width + x;
                        if (!barrier[bottom] && !exterior[bottom]) { stack.push(bottom); exterior[bottom] = 1; }
                    }
                    for (let y = 1; y < height - 1; y++) {
                        const left = y * width;
                        if (!barrier[left] && !exterior[left]) { stack.push(left); exterior[left] = 1; }
                        const right = y * width + width - 1;
                        if (!barrier[right] && !exterior[right]) { stack.push(right); exterior[right] = 1; }
                    }
                    while (stack.length > 0) {
                        const idx = stack.pop();
                        const px = idx % width;
                        const py = (idx - px) / width;
                        if (px > 0 && !exterior[idx - 1] && !barrier[idx - 1]) { exterior[idx - 1] = 1; stack.push(idx - 1); }
                        if (px < width - 1 && !exterior[idx + 1] && !barrier[idx + 1]) { exterior[idx + 1] = 1; stack.push(idx + 1); }
                        if (py > 0 && !exterior[idx - width] && !barrier[idx - width]) { exterior[idx - width] = 1; stack.push(idx - width); }
                        if (py < height - 1 && !exterior[idx + width] && !barrier[idx + width]) { exterior[idx + width] = 1; stack.push(idx + width); }
                    }
                }

                for (let i = 0; i < adjustedMask.length; i++) {
                    const dataIdx = i * 4;
                    if (outlinePaint[i]) {
                        data[dataIdx] = strokeR;
                        data[dataIdx + 1] = strokeG;
                        data[dataIdx + 2] = strokeB;
                        data[dataIdx + 3] = 255;
                    } else if (keepColors && !exterior[i]) {
                        data[dataIdx + 3] = 255;
                    } else {
                        data[dataIdx + 3] = 0;
                    }
                }

                tempCtx.putImageData(imageData, 0, 0);

                processedImage = new Image();
                processedImage.onload = () => {
                    resolve();
                };
                processedImage.src = tempCanvas.toDataURL('image/png');
            });
        }

        // ============================================
        // Export GIF
        // ============================================
        exportGifBtn.addEventListener('click', () => {
            if (!uploadedImage) return;

            if (jiggleFrames.length === 0) {
                generateJiggleFrames();
            }
            if (jiggleFrames.length === 0) return;

            exportGifBtn.classList.add('exporting');
            exportGifBtn.disabled = true;
            exportAsGif();
        });

        function exportAsGif() {
            let width, height;
            if (currentAspectRatio === '16:9') {
                width = 1280;
                height = 720;
            } else {
                width = 720;
                height = 1280;
            }
            const speed = parseInt(animSpeed.value);

            if (bgImageData) {
                const bgImg = new Image();
                bgImg.onload = () => {
                    createGifWithBackground(bgImg, width, height, speed);
                };
                bgImg.src = bgImageData;
            } else {
                createGifWithBackground(null, width, height, speed);
            }
        }

        function createGifWithBackground(bgImg, width, height, speed) {
            const frames = [];

            const previewWidth = previewContent.clientWidth;
            const previewHeight = previewContent.clientHeight;
            const exportScaleX = width / previewWidth;
            const exportScaleY = height / previewHeight;

            const scaledOffsetX = imageOffsetX * exportScaleX;
            const scaledOffsetY = imageOffsetY * exportScaleY;

            for (let i = 0; i < jiggleFrames.length; i++) {
                const frame = jiggleFrames[i];
                const angle = frameAngles[i] || 0;

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');

                if (bgImg) {
                    tempCtx.drawImage(bgImg, 0, 0, width, height);
                } else {
                    tempCtx.fillStyle = bgColor.value;
                    tempCtx.fillRect(0, 0, width, height);
                }

                const exportScaleFactor = isUploadedFile ? 0.9 : 1.0;
                const scale = Math.min(
                    (width * exportScaleFactor) / frame.width,
                    (height * exportScaleFactor) / frame.height
                );
                const drawWidth = frame.width * scale;
                const drawHeight = frame.height * scale;
                const x = (width - drawWidth) / 2 + scaledOffsetX;
                const y = (height - drawHeight) / 2 + scaledOffsetY;

                if (angle !== 0) {
                    const centerX = x + drawWidth / 2;
                    const centerY = y + drawHeight / 2;
                    tempCtx.save();
                    tempCtx.translate(centerX, centerY);
                    tempCtx.rotate(angle);
                    tempCtx.drawImage(frame, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                    tempCtx.restore();
                } else {
                    tempCtx.drawImage(frame, x, y, drawWidth, drawHeight);
                }

                frames.push(tempCanvas.toDataURL('image/png'));
            }

            gifshot.createGIF({
                images: frames,
                gifWidth: width,
                gifHeight: height,
                interval: speed / 1000,
                numFrames: frames.length,
                frameDuration: 1,
                sampleInterval: 10
            }, function(obj) {
                exportGifBtn.classList.remove('exporting');
                exportGifBtn.disabled = false;

                if (!obj.error) {
                    const link = document.createElement('a');
                    link.href = obj.image;
                    link.download = 'jiggle-drawing.gif';
                    link.click();
                }
            });
        }

        // ============================================
        // Color pickers
        // ============================================
        function hsvToHex(h, s, v) {
            s /= 100;
            v /= 100;
            const c = v * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = v - c;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            const toHex = n => Math.round((n + m) * 255).toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }

        function hexToHsv(hex) {
            const r = parseInt(hex.substr(1, 2), 16) / 255;
            const g = parseInt(hex.substr(3, 2), 16) / 255;
            const b = parseInt(hex.substr(5, 2), 16) / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const d = max - min;
            let h = 0;
            const s = max === 0 ? 0 : (d / max) * 100;
            const v = max * 100;
            if (d !== 0) {
                if (max === r) h = ((g - b) / d + (g < b ? 6 : 0)) * 60;
                else if (max === g) h = ((b - r) / d + 2) * 60;
                else h = ((r - g) / d + 4) * 60;
            }
            return { h, s, v };
        }

        // Stroke color picker
        const strokeColorSquare = document.getElementById('strokeColorSquare');
        const strokeColorCursor = document.getElementById('strokeColorCursor');
        const strokeHueSlider = document.getElementById('strokeHueSlider');
        const strokeHueCursor = document.getElementById('strokeHueCursor');
        const strokeColorHexInput = document.getElementById('strokeColorHexInput');

        let strokeHue = 0;
        let strokeSaturation = 100;
        let strokeValue = 0;

        function updateStrokeColorFromHsv() {
            const hex = hsvToHex(strokeHue, strokeSaturation, strokeValue);
            strokeColorInput.value = hex;
            strokeColorHexInput.value = hex;
            strokePreview.style.background = hex;
            strokeColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${strokeHue}, 100%, 50%))`;

            drawCtx.strokeStyle = hex;
            if (uploadedImage) {
                if (isUploadedFile) {
                    processUploadedImage().then(() => {
                        jiggleFrames = [];
                    });
                } else {
                    jiggleFrames = [];
                }
            }
        }

        function setStrokeColorCursorPosition() {
            const rect = strokeColorSquare.getBoundingClientRect();
            strokeColorCursor.style.left = (strokeSaturation / 100 * rect.width) + 'px';
            strokeColorCursor.style.top = ((100 - strokeValue) / 100 * rect.height) + 'px';
        }

        function setStrokeHueCursorPosition() {
            const rect = strokeHueSlider.getBoundingClientRect();
            strokeHueCursor.style.left = (strokeHue / 360 * rect.width) + 'px';
        }

        strokeColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${strokeHue}, 100%, 50%))`;
        setStrokeColorCursorPosition();
        setStrokeHueCursorPosition();

        strokeColorSquare.addEventListener('mousedown', (e) => {
            function pickColor(event) {
                const rect = strokeColorSquare.getBoundingClientRect();
                const x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
                const y = Math.max(0, Math.min(event.clientY - rect.top, rect.height));
                strokeSaturation = (x / rect.width) * 100;
                strokeValue = 100 - (y / rect.height) * 100;
                strokeColorCursor.style.left = x + 'px';
                strokeColorCursor.style.top = y + 'px';
                updateStrokeColorFromHsv();
            }
            pickColor(e);
            function onMouseMove(event) { pickColor(event); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        strokeHueSlider.addEventListener('mousedown', (e) => {
            function pickHue(event) {
                const rect = strokeHueSlider.getBoundingClientRect();
                const x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
                strokeHue = (x / rect.width) * 360;
                strokeHueCursor.style.left = x + 'px';
                updateStrokeColorFromHsv();
            }
            pickHue(e);
            function onMouseMove(event) { pickHue(event); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        strokeColorHexInput.addEventListener('input', (e) => {
            let hex = e.target.value;
            if (hex.match(/^#[0-9A-Fa-f]{6}$/)) {
                const hsv = hexToHsv(hex);
                strokeHue = hsv.h;
                strokeSaturation = hsv.s;
                strokeValue = hsv.v;
                strokeColorInput.value = hex;
                strokePreview.style.background = hex;
                strokeColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${strokeHue}, 100%, 50%))`;
                setStrokeColorCursorPosition();
                setStrokeHueCursorPosition();

                drawCtx.strokeStyle = hex;
                if (uploadedImage) {
                    if (isUploadedFile) {
                        processUploadedImage().then(() => {
                            jiggleFrames = [];
                        });
                    } else {
                        jiggleFrames = [];
                    }
                }
            }
        });

        strokeColorInput.addEventListener('input', (e) => {
            const hex = e.target.value;
            strokeColorHexInput.value = hex;
            const hsv = hexToHsv(hex);
            strokeHue = hsv.h;
            strokeSaturation = hsv.s;
            strokeValue = hsv.v;
            strokeColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${strokeHue}, 100%, 50%))`;
            setStrokeColorCursorPosition();
            setStrokeHueCursorPosition();
        });

        // Background color picker
        const bgColorSquare = document.getElementById('bgColorSquare');
        const bgColorCursor = document.getElementById('bgColorCursor');
        const bgHueSlider = document.getElementById('bgHueSlider');
        const bgHueCursor = document.getElementById('bgHueCursor');
        const bgColorHexInput = document.getElementById('bgColorHexInput');

        let bgHue = 0;
        let bgSaturation = 0;
        let bgValue = 100;

        function updateBgColorFromHsv() {
            const hex = hsvToHex(bgHue, bgSaturation, bgValue);
            bgColor.value = hex;
            bgColorHexInput.value = hex;
            bgPreview.style.background = hex;
            bgColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${bgHue}, 100%, 50%))`;

            bgImageData = null;
            cachedBgImage = null;
            if (bgImagePreview) bgImagePreview.style.display = 'none';
            if (bgUploadPlaceholder) bgUploadPlaceholder.style.display = '';
            // Update drawing canvas background
            if (!isAnimating) redrawDrawingCanvas();
        }

        function setBgColorCursorPosition() {
            const rect = bgColorSquare.getBoundingClientRect();
            bgColorCursor.style.left = (bgSaturation / 100 * rect.width) + 'px';
            bgColorCursor.style.top = ((100 - bgValue) / 100 * rect.height) + 'px';
        }

        function setBgHueCursorPosition() {
            const rect = bgHueSlider.getBoundingClientRect();
            bgHueCursor.style.left = (bgHue / 360 * rect.width) + 'px';
        }

        bgColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${bgHue}, 100%, 50%))`;
        setBgColorCursorPosition();
        setBgHueCursorPosition();

        bgColorSquare.addEventListener('mousedown', (e) => {
            function pickColor(event) {
                const rect = bgColorSquare.getBoundingClientRect();
                const x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
                const y = Math.max(0, Math.min(event.clientY - rect.top, rect.height));
                bgSaturation = (x / rect.width) * 100;
                bgValue = 100 - (y / rect.height) * 100;
                bgColorCursor.style.left = x + 'px';
                bgColorCursor.style.top = y + 'px';
                updateBgColorFromHsv();
            }
            pickColor(e);
            function onMouseMove(event) { pickColor(event); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        bgHueSlider.addEventListener('mousedown', (e) => {
            function pickHue(event) {
                const rect = bgHueSlider.getBoundingClientRect();
                const x = Math.max(0, Math.min(event.clientX - rect.left, rect.width));
                bgHue = (x / rect.width) * 360;
                bgHueCursor.style.left = x + 'px';
                updateBgColorFromHsv();
            }
            pickHue(e);
            function onMouseMove(event) { pickHue(event); }
            function onMouseUp() {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        bgColorHexInput.addEventListener('input', (e) => {
            let hex = e.target.value;
            if (hex.match(/^#[0-9A-Fa-f]{6}$/)) {
                const hsv = hexToHsv(hex);
                bgHue = hsv.h;
                bgSaturation = hsv.s;
                bgValue = hsv.v;
                bgColor.value = hex;
                bgPreview.style.background = hex;
                bgColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${bgHue}, 100%, 50%))`;
                setBgColorCursorPosition();
                setBgHueCursorPosition();

                bgImageData = null;
                cachedBgImage = null;
                if (bgImagePreview) bgImagePreview.style.display = 'none';
                if (bgUploadPlaceholder) bgUploadPlaceholder.style.display = '';
                if (!isAnimating) redrawDrawingCanvas();
            }
        });

        bgColor.addEventListener('input', (e) => {
            const hex = e.target.value;
            bgColorHexInput.value = hex;
            const hsv = hexToHsv(hex);
            bgHue = hsv.h;
            bgSaturation = hsv.s;
            bgValue = hsv.v;
            bgColorSquare.style.background = `linear-gradient(to top, #000, transparent), linear-gradient(to right, #fff, hsl(${bgHue}, 100%, 50%))`;
            setBgColorCursorPosition();
            setBgHueCursorPosition();
        });

        // ============================================
        // Handle window resize
        // ============================================
        window.addEventListener('resize', () => {
            if (isAnimating && jiggleFrames.length > 0) {
                drawFrame(currentFrame);
            }
        });
    </script>
</body>
</html>
