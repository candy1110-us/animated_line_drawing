<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animated Bar Chart - Sketch Style</title>
    <script src="https://cdn.jsdelivr.net/npm/roughjs@4.6.6/bundled/rough.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <style>
        @font-face {
            font-family: 'HMT Regular';
            src: url('fonts/HmtRegular-WRrv.ttf') format('truetype');
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: #ecebe4;
            background-image: url('data:image/svg+xml;utf8,<svg width="28" height="28" xmlns="http://www.w3.org/2000/svg"><circle cx="14" cy="14" r="1" fill="%23d2d1c7"/></svg>');
            background-size: 28px 28px;
            min-height: 100vh;
            padding: 40px 20px;
            position: relative;
            overflow-x: hidden;
        }

        /* Doodle decorations */
        body::before,
        body::after {
            content: '';
            position: fixed;
            border-radius: 50%;
            opacity: 0.15;
            pointer-events: none;
            z-index: 0;
        }

        body::before {
            background: #6ba3ff;
            width: 50vh;
            height: 50vh;
            top: 20%;
            left: -10vh;
            animation: float 6s ease-in-out infinite;
        }

        body::after {
            background: #f59e0b;
            width: 150px;
            height: 150px;
            bottom: 15%;
            right: 8%;
            animation: float 8s ease-in-out infinite reverse;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(0deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .header {
            background: transparent;
            padding: 20px 30px;
            margin-bottom: 30px;
            text-align: center;
            position: relative;
        }

        .logo-link {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            background: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 100;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .logo-link:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.25);
        }

        .header-logo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .header-content {
            text-align: center;
        }

        .header h1 {
            font-family: 'HMT Regular', 'Inter', sans-serif;
            font-size: 3.5rem;
            color: #2d3436;
            margin-bottom: 12px;
            text-shadow: 3px 3px 0px rgba(107, 163, 255, 0.3);
        }

        .header p {
            color: #636e72;
            font-size: 1.1rem;
        }

        .main-layout {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            height: calc(100vh - 180px); /* Full height minus header/title space */
            align-items: start;
        }

        .left-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 8px;
            min-width: 0; /* Prevents flex items from overflowing */
        }

        .left-column::-webkit-scrollbar {
            width: 8px;
        }

        .left-column::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }

        .left-column::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }

        .left-column::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }

        .right-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
            position: sticky;
            top: 20px;
        }

        .sidebar-panel {
            background: white;
            border-radius: 20px;
            padding: 24px;
            box-shadow:
                3px 3px 0px rgba(0, 0, 0, 0.05),
                6px 6px 0px rgba(107, 163, 255, 0.08);
            border: 1px solid rgba(45, 52, 54, 0.15);
            overflow-x: hidden;
            min-width: 0;
            flex-shrink: 0;
        }

        .sidebar-panel h3 {
            font-size: 16px;
            color: #2d3436;
            margin-bottom: 16px;
            font-weight: 600;
        }

        .chart-area {
            width: 100%;
        }

        .chart-container-wrapper {
            background: transparent;
            border-radius: 0;
            padding: 0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 0;
        }

        .chart-container {
            position: relative;
            width: 100%;
            height: auto;
            max-width: 900px;
            aspect-ratio: 16 / 9; /* Will be updated dynamically */
            background: #ffffff; /* Default white background */
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border-radius: 20px;
            overflow: hidden;
        }

        #chartSvg {
            width: 100%;
            height: 100%;
            display: block;
            margin: 0 auto;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 50px;
            font-size: 18px;
        }

        /* Mode/Chart Type Buttons */
        .mode-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            background: white;
            color: #2d3436;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 2px 2px 0px rgba(107, 163, 255, 0.1);
            font-size: 14px;
        }

        .mode-btn:hover {
            border-color: #6ba3ff;
            background: #f8f9ff;
            transform: translateY(-2px);
            box-shadow: 3px 3px 0px rgba(107, 163, 255, 0.2);
        }

        .mode-btn.active,
        .mode-btn.selected {
            border-color: #6ba3ff;
            background: #6ba3ff;
            color: white;
            transform: translateY(-2px);
            box-shadow: 3px 3px 0px rgba(0, 0, 0, 0.1);
        }

        .chart-type-btns {
            display: flex;
            gap: 10px;
        }

        /* Aspect Ratio Buttons */
        .aspect-ratio-btn {
            color: #6366f1;
            transition: opacity 0.2s;
        }

        .aspect-ratio-btn:hover {
            opacity: 0.7 !important;
        }

        .aspect-ratio-btn.selected {
            opacity: 1 !important;
        }


        /* Data Input Section */
        .input-row {
            display: grid;
            grid-template-columns: 1fr minmax(70px, 90px) minmax(50px, 60px) minmax(50px, 60px);
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
            min-width: 0;
        }

        .input-row input[type="text"] {
            padding: 10px 12px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.2s;
            position: relative;
            z-index: 50;
            min-width: 0;
        }

        .input-row input[type="number"] {
            padding: 10px 12px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.2s;
            position: relative;
            z-index: 50;
            min-width: 0;
        }

        .input-row input:focus {
            outline: none;
            border-color: #6ba3ff;
            box-shadow: 0 0 0 3px rgba(107, 163, 255, 0.1);
        }

        .color-pattern-preview {
            width: 100%;
            max-width: 60px;
            min-width: 50px;
            height: 44px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            flex-shrink: 0;
            position: relative;
            z-index: 10;
            overflow: hidden;
            box-shadow: 2px 2px 0px rgba(107, 163, 255, 0.1);
        }

        .color-pattern-preview:hover {
            border-color: #6ba3ff;
            transform: translateY(-2px);
            box-shadow: 3px 3px 0px rgba(107, 163, 255, 0.2);
        }

        .color-pattern-preview svg {
            pointer-events: none;
        }

        /* Ensure chart settings panel has proper isolation */
        .settings-column {
            position: relative;
            z-index: auto;
            isolation: isolate;
        }

        .plus-icon {
            width: 24px;
            height: 24px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .plus-icon:hover {
            opacity: 1;
        }

        /* Data Table */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
            font-size: 13px;
        }

        .data-table thead {
            background: #f3f4f6;
        }

        .data-table th {
            padding: 8px 6px;
            text-align: left;
            font-weight: 600;
            color: #374151;
            border-bottom: 2px solid #e0e7ff;
        }

        .data-table td {
            padding: 6px;
            border-bottom: 1px solid #e5e7eb;
        }

        .data-table input[type="text"],
        .data-table input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid rgba(45, 52, 54, 0.15);
            border-radius: 8px;
            font-size: 13px;
            transition: all 0.2s;
        }

        .data-table input:focus {
            outline: none;
            border-color: #6ba3ff;
            box-shadow: 0 0 0 2px rgba(107, 163, 255, 0.1);
        }

        .data-table svg {
            cursor: pointer;
        }

        .trash-icon {
            width: 24px;
            height: 24px;
            cursor: pointer;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .trash-icon:hover {
            opacity: 1;
        }

        /* Move icon for data reordering */
        .move-icon {
            width: 20px;
            height: 20px;
            cursor: grab;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .move-icon:hover {
            opacity: 1;
        }

        .move-icon:active {
            cursor: grabbing;
        }

        /* Custom Palette Dropdown */
        .custom-palette-dropdown {
            position: relative;
            z-index: 100;
        }

        .palette-dropdown-selected {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            background: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #374151;
            transition: all 0.2s;
            box-shadow: 2px 2px 0px rgba(107, 163, 255, 0.1);
        }

        .palette-dropdown-selected:hover {
            border-color: #6ba3ff;
            transform: translateY(-2px);
            box-shadow: 3px 3px 0px rgba(107, 163, 255, 0.2);
        }

        .palette-dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background: white;
            border: 2px solid #6ba3ff;
            border-radius: 12px;
            box-shadow: 0 6px 16px rgba(107, 163, 255, 0.25);
            max-height: 300px;
            overflow-y: auto;
            z-index: 1000;
        }

        .palette-option {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: background 0.2s;
        }

        .palette-option:hover {
            background: #f3f4f6;
        }

        /* Chart Labels Section */
        .label-input-group {
            margin-bottom: 12px;
        }

        .label-input-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 6px;
        }

        .label-input-group input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.2s;
        }

        .label-input-group input:focus {
            outline: none;
            border-color: #6ba3ff;
            box-shadow: 0 0 0 3px rgba(107, 163, 255, 0.1);
        }

        /* Background Section */
        .bg-type-toggle {
            display: flex;
            gap: 16px;
            margin-bottom: 12px;
        }

        .bg-type-toggle label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
        }

        .bg-color-display {
            width: 60px;
            height: 40px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            box-shadow: 2px 2px 0px rgba(107, 163, 255, 0.1);
        }

        .bg-color-display:hover {
            border-color: #6ba3ff;
            transform: translateY(-2px);
            box-shadow: 3px 3px 0px rgba(107, 163, 255, 0.2);
        }

        .bg-image-input {
            width: 100%;
            padding: 8px;
            border: 2px solid rgba(45, 52, 54, 0.15);
            border-radius: 12px;
            font-size: 13px;
        }

        /* Animation Settings */
        .slider-group {
            margin-bottom: 14px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 6px;
        }

        .slider-value {
            color: #6366f1;
            font-weight: 700;
        }

        .slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e7ff;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #818cf8;
            cursor: pointer;
        }

        .slider-group input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #818cf8;
            cursor: pointer;
            border: none;
        }

        /* Animate Button */
        .animate-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #818cf8 0%, #6366f1 100%);
            color: white;
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 8px rgba(129, 140, 248, 0.3);
            display: inline-block;
        }

        .animate-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(129, 140, 248, 0.4);
        }

        .animate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .animate-btn-container {
            text-align: right;
            margin-bottom: 16px;
        }

        /* Edit Popup */
        .edit-popup {
            display: none;
            position: fixed;
            background: white;
            border: 3px solid #818cf8;
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            z-index: 10000;
            min-width: 280px;
            max-width: 400px;
            pointer-events: none;
        }

        .edit-popup.active {
            display: block;
            pointer-events: auto;
        }

        .input-row {
            position: relative;
            z-index: 1;
        }

        .data-table {
            position: relative;
            z-index: 1;
        }

        .color-picker-container {
            display: flex;
            gap: 10px;
            margin-bottom: 12px;
        }

        .color-canvas {
            width: 180px;
            height: 180px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            cursor: crosshair;
        }

        .color-hue-slider {
            width: 20px;
            height: 180px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            cursor: pointer;
            background: linear-gradient(to bottom,
                #ff0000 0%,
                #ffff00 17%,
                #00ff00 33%,
                #00ffff 50%,
                #0000ff 67%,
                #ff00ff 83%,
                #ff0000 100%);
        }

        .color-hex-input {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 12px;
        }

        .color-hex-input label {
            font-size: 12px;
            font-weight: 700;
            color: #374151;
        }

        .color-hex-input input {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #e0e7ff;
            border-radius: 6px;
            font-size: 13px;
            font-family: monospace;
            text-transform: uppercase;
        }

        .color-display-small {
            width: 40px;
            height: 28px;
            border: 2px solid #e0e7ff;
            border-radius: 6px;
        }

        .edit-popup-patterns {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .edit-popup-pattern {
            width: 50px;
            height: 50px;
            cursor: pointer;
            position: relative;
        }

        .edit-popup-pattern svg {
            width: 50px;
            height: 50px;
            display: block;
            transition: all 0.2s;
        }

        .edit-popup-pattern:hover svg {
            transform: scale(1.08);
        }

        .edit-popup-pattern.selected::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 2px solid #818cf8;
            border-radius: 6px;
            pointer-events: none;
        }

        /* Reusable Utility Classes */

        /* Grid layouts */
        .grid-2col-gap12 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .grid-2col-100-gap8 {
            display: grid;
            grid-template-columns: 1fr 1fr 100px;
            gap: 8px;
            align-items: end;
        }

        .grid-4col-gap8 {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        /* Flex layouts */
        .flex-gap12 {
            display: flex;
            gap: 12px;
        }

        .flex-gap8-center {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .flex-gap16-center {
            display: flex;
            gap: 16px;
            align-items: center;
        }

        .flex-col-center-gap3 {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 3px;
        }

        .flex-center {
            display: flex;
            justify-content: center;
        }

        /* Spacing utilities */
        .mb-0 {
            margin-bottom: 0;
        }

        .mb-8 {
            margin-bottom: 8px;
        }

        .mb-12 {
            margin-bottom: 12px;
        }

        .mt-16 {
            margin-top: 16px;
        }

        /* Common label styles */
        .section-label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 8px;
        }

        .label-fontsize-10 {
            font-size: 10px;
            color: currentColor;
            font-weight: 600;
        }

        .popup-heading {
            margin: 0 0 12px 0;
            font-size: 14px;
            font-weight: 700;
            color: #374151;
        }

        /* Common input/button styles */
        .compact-mode-btn {
            padding: 8px;
            font-size: 13px;
        }

        .full-width-input {
            width: 100%;
            padding: 10px 8px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 14px;
        }

        .full-width-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }

        .full-width-select-sm {
            width: 100%;
            padding: 10px 8px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 13px;
            background: white;
            cursor: pointer;
        }

        .full-width-slider {
            width: 100%;
        }

        /* Aspect ratio button base */
        .aspect-btn-base {
            padding: 0;
            border: none;
            background: transparent;
            cursor: pointer;
        }

        /* Background pattern option */
        .bg-pattern-base {
            cursor: pointer;
            border: 2px solid #e0e7ff;
            border-radius: 6px;
            background: white;
            transition: all 0.2s;
        }

        .bg-pattern-text {
            padding: 8px;
            text-align: center;
            font-size: 12px;
        }

        .bg-pattern-image {
            overflow: hidden;
            aspect-ratio: 2;
            position: relative;
        }

        .bg-pattern-img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.8;
        }

        /* Palette strip */
        .palette-strip {
            width: 70px;
            height: 20px;
            border-radius: 4px;
        }

        /* Upload section */
        .upload-flex {
            flex: 1;
            padding: 6px;
            border: 2px solid #e0e7ff;
            border-radius: 6px;
            font-size: 12px;
        }

        .clear-btn {
            padding: 8px 12px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }

        /* Dividers */
        .hr-divider {
            border: none;
            border-top: 2px solid #e0e7ff;
            margin: 16px 0;
        }

        /* Specific layout utilities */
        .span-2 {
            grid-column: span 2;
        }

        .overflow-scroll {
            max-height: 340px;
            overflow-y: auto;
        }

        .bg-white-full {
            background: #ffffff;
            width: 100%;
            height: 40px;
            cursor: pointer;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
        }

        .empty-icon {
            font-size: 20px;
            margin-bottom: 10px;
        }

        /* Table utilities */
        .th-width-32 {
            width: 32%;
        }

        .th-width-18 {
            width: 18%;
        }

        .th-width-28 {
            width: 28%;
        }

        .th-width-10 {
            width: 10%;
        }

        .th-width-12 {
            width: 12%;
        }

        .text-center {
            text-align: center;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .cursor-move {
            cursor: move;
        }

        .cursor-text {
            cursor: text;
        }

        .no-data-message {
            text-align: center;
            color: #9ca3af;
            padding: 20px;
            font-size: 13px;
        }

        .ml-auto {
            margin-left: auto;
        }

        /* Bar Chart Specific Styles */
        .bar-label {
            font-family: var(--chart-font-family, 'Noteworthy', sans-serif);
            font-weight: 600;
            color: #333;
            text-align: center;
            /* font-size set inline via JavaScript */
        }

        .bar-value {
            font-family: var(--chart-font-family, 'Noteworthy', sans-serif);
            font-weight: 700;
            color: #333;
            /* font-size set inline via JavaScript */
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
                height: auto;
            }

            .left-column {
                max-height: none;
                overflow-y: visible;
            }

            .right-column {
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="index.html" class="logo-link">
                <img src="images/mefn.gif" alt="Logo" class="header-logo">
            </a>
            <div class="header-content">
                <h1>Animated Chart Generator</h1>
                <p>Create beautiful sketch-style animated charts with customizable patterns and colors</p>
            </div>
        </div>

        <div class="main-layout">
            <!-- Left Column: Data and Settings Panels -->
            <div class="left-column">
                <!-- Data Panel -->
                <div class="sidebar-panel">
                    <h3>Data</h3>

                        <!-- Chart Type Selection (Moved to top) -->
                        <div class="label-input-group mb-12">
                            <label>Chart Type</label>
                            <div class="chart-type-btns" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                                <button class="mode-btn selected compact-mode-btn" data-chart="bar" onclick="selectChartType('bar', this)">Bar</button>
                                <button class="mode-btn compact-mode-btn" data-chart="pie" onclick="selectChartType('pie', this)">Pie</button>
                                <button class="mode-btn compact-mode-btn" data-chart="line" onclick="selectChartType('line', this)">Line</button>
                                <button class="mode-btn compact-mode-btn" data-chart="area" onclick="selectChartType('area', this)">Area</button>
                                <button class="mode-btn compact-mode-btn" data-chart="scatter" onclick="selectChartType('scatter', this)">Scatter</button>
                                <button class="mode-btn compact-mode-btn" data-chart="hbar" onclick="selectChartType('hbar', this)">H-Bar</button>
                            </div>
                        </div>

                        <!-- Area Chart Color Selector (only visible for area charts) -->
                        <div id="areaColorSection" class="label-input-group mb-12" style="display: none;">
                            <label>Area Fill Color & Pattern</label>
                            <div class="color-pattern-preview" id="areaColorPatternPreview" onclick="openAreaColorPopup(event)" style="width: 60px; height: 44px; cursor: pointer;">
                                <svg id="areaPatternPreview" style="width: 100%; height: 100%;"></svg>
                            </div>
                        </div>

                        <div class="label-input-group mb-12" id="paletteSection">
                            <label>Choose color palette for your chart</label>
                        <div class="custom-palette-dropdown" onclick="togglePaletteDropdown()">
                            <div class="palette-dropdown-selected">
                                <div id="selectedPaletteStrip" class="palette-strip" style="background: linear-gradient(90deg, #e63946 0%, #e63946 12.5%, #f77f00 12.5%, #f77f00 25%, #fcbf49 25%, #fcbf49 37.5%, #06a77d 37.5%, #06a77d 50%, #118ab2 50%, #118ab2 62.5%, #073b4c 62.5%, #073b4c 75%, #dd6e42 75%, #dd6e42 87.5%, #e8dab2 87.5%, #e8dab2 100%);"></div>
                                <span id="selectedPaletteName">Retro Warm</span>
                                <span class="ml-auto">â–¼</span>
                            </div>
                            <div class="palette-dropdown-options" id="paletteDropdownOptions" style="display: none;">
                                <div class="palette-option" onclick="selectPaletteOption('retro', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #e63946 0%, #e63946 12.5%, #f77f00 12.5%, #f77f00 25%, #fcbf49 25%, #fcbf49 37.5%, #06a77d 37.5%, #06a77d 50%, #118ab2 50%, #118ab2 62.5%, #073b4c 62.5%, #073b4c 75%, #dd6e42 75%, #dd6e42 87.5%, #e8dab2 87.5%, #e8dab2 100%);"></div>
                                    <span>Retro Warm</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('pastel', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #ffb5c2 0%, #ffb5c2 12.5%, #ffd4a3 12.5%, #ffd4a3 25%, #fff5ba 25%, #fff5ba 37.5%, #b4e4d4 37.5%, #b4e4d4 50%, #c5a9e8 50%, #c5a9e8 62.5%, #ffccf9 62.5%, #ffccf9 75%, #a8e6cf 75%, #a8e6cf 87.5%, #ffd3b6 87.5%, #ffd3b6 100%);"></div>
                                    <span>Pastel Soft</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('vintage', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #8b7e66 0%, #8b7e66 12.5%, #a4907c 12.5%, #a4907c 25%, #c9b8a3 25%, #c9b8a3 37.5%, #7d8570 37.5%, #7d8570 50%, #8e7c68 50%, #8e7c68 62.5%, #b4a088 62.5%, #b4a088 75%, #9b8b7e 75%, #9b8b7e 87.5%, #a89f91 87.5%, #a89f91 100%);"></div>
                                    <span>Vintage Earth</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('poster', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #264653 0%, #264653 12.5%, #2a9d8f 12.5%, #2a9d8f 25%, #e9c46a 25%, #e9c46a 37.5%, #f4a261 37.5%, #f4a261 50%, #e76f51 50%, #e76f51 62.5%, #6a994e 62.5%, #6a994e 75%, #bc4749 75%, #bc4749 87.5%, #9d4edd 87.5%, #9d4edd 100%);"></div>
                                    <span>Poster Bold</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('sketch', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #457b9d 0%, #457b9d 12.5%, #a8dadc 12.5%, #a8dadc 25%, #f1faee 25%, #f1faee 37.5%, #e63946 37.5%, #e63946 50%, #1d3557 50%, #1d3557 62.5%, #f77f00 62.5%, #f77f00 75%, #06a77d 75%, #06a77d 87.5%, #e9c46a 87.5%, #e9c46a 100%);"></div>
                                    <span>Sketch Blue</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('autumn', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #8b4513 0%, #8b4513 12.5%, #d2691e 12.5%, #d2691e 25%, #daa520 25%, #daa520 37.5%, #b8860b 37.5%, #b8860b 50%, #cd853f 50%, #cd853f 62.5%, #a0522d 62.5%, #a0522d 75%, #c19a6b 75%, #c19a6b 87.5%, #e3a857 87.5%, #e3a857 100%);"></div>
                                    <span>Autumn Leaves</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('ocean', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #006994 0%, #006994 12.5%, #247ba0 12.5%, #247ba0 25%, #1e96c8 25%, #1e96c8 37.5%, #2cb5e8 37.5%, #2cb5e8 50%, #7fcdff 50%, #7fcdff 62.5%, #4dd0e1 62.5%, #4dd0e1 75%, #00acc1 75%, #00acc1 87.5%, #0097a7 87.5%, #0097a7 100%);"></div>
                                    <span>Ocean Breeze</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('forest', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #2d5016 0%, #2d5016 12.5%, #3d6b28 12.5%, #3d6b28 25%, #4a7c3a 25%, #4a7c3a 37.5%, #5a8e4c 37.5%, #5a8e4c 50%, #6ca35f 50%, #6ca35f 62.5%, #7eb773 62.5%, #7eb773 75%, #90ca87 75%, #90ca87 87.5%, #a4d99b 87.5%, #a4d99b 100%);"></div>
                                    <span>Forest Green</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('sunset', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #ff6b35 0%, #ff6b35 12.5%, #f7931e 12.5%, #f7931e 25%, #fdc82f 25%, #fdc82f 37.5%, #fbb040 37.5%, #fbb040 50%, #f89c50 50%, #f89c50 62.5%, #f57e5f 62.5%, #f57e5f 75%, #f25f70 75%, #f25f70 87.5%, #ef4180 87.5%, #ef4180 100%);"></div>
                                    <span>Sunset Glow</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('candy', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #ff6b9d 0%, #ff6b9d 12.5%, #c44569 12.5%, #c44569 25%, #ffa07a 25%, #ffa07a 37.5%, #fa8072 37.5%, #fa8072 50%, #e0b0ff 50%, #e0b0ff 62.5%, #dda0dd 62.5%, #dda0dd 75%, #ffc0cb 75%, #ffc0cb 87.5%, #ffb6c1 87.5%, #ffb6c1 100%);"></div>
                                    <span>Candy Pop</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('earthy', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #936639 0%, #936639 12.5%, #a67c52 12.5%, #a67c52 25%, #b8926b 25%, #b8926b 37.5%, #caa884 37.5%, #caa884 50%, #7c6a5c 50%, #7c6a5c 62.5%, #8d7966 62.5%, #8d7966 75%, #9e8870 75%, #9e8870 87.5%, #af977a 87.5%, #af977a 100%);"></div>
                                    <span>Earthy Tones</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('neon', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #ff006e 0%, #ff006e 12.5%, #fb5607 12.5%, #fb5607 25%, #ffbe0b 25%, #ffbe0b 37.5%, #8338ec 37.5%, #8338ec 50%, #3a86ff 50%, #3a86ff 62.5%, #06ffa5 62.5%, #06ffa5 75%, #ff006e 75%, #ff006e 87.5%, #fb5607 87.5%, #fb5607 100%);"></div>
                                    <span>Neon Bright</span>
                                </div>
                                <div class="palette-option" onclick="selectPaletteOption('muted', event)">
                                    <div class="palette-strip" style="background: linear-gradient(90deg, #6c757d 0%, #6c757d 12.5%, #8d99ae 12.5%, #8d99ae 25%, #9ba4b5 25%, #9ba4b5 37.5%, #adb5bd 37.5%, #adb5bd 50%, #b1a7a6 50%, #b1a7a6 62.5%, #c6b9cd 62.5%, #c6b9cd 75%, #d6cbd3 75%, #d6cbd3 87.5%, #e5d4ce 87.5%, #e5d4ce 100%);"></div>
                                    <span>Muted Grey</span>
                                </div>
                            </div>
                        </div>
                        </div>

                        <div class="label-input-group mb-12">
                            <label>Add your data</label>
                        </div>

                        <!-- Standard input row (Bar, Pie, Line, H-Bar) -->
                        <div class="input-row" id="standardInputRow">
                            <input type="text" id="labelInput" placeholder="Label" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <input type="number" id="valueInput" placeholder="Value" min="0" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <div class="color-pattern-preview" id="colorPatternPreview" onclick="openEditPopup(event)">
                                <svg id="currentPatternPreview"></svg>
                            </div>
                            <svg class="plus-icon" onclick="addData(event)" viewBox="0 0 24 24" fill="none" stroke="#6ba3ff" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="12" y1="8" x2="12" y2="16"/>
                                <line x1="8" y1="12" x2="16" y2="12"/>
                            </svg>
                        </div>

                        <!-- Scatter plot input row -->
                        <div class="input-row" id="scatterInputRow" style="display: none; grid-template-columns: 1fr 70px 70px 60px auto; gap: 8px;">
                            <input type="text" id="scatterLabelInput" placeholder="Label" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <input type="number" id="scatterXInput" placeholder="X" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <input type="number" id="scatterYInput" placeholder="Y" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <div class="color-pattern-preview" id="scatterColorPatternPreview" onclick="openEditPopup(event)">
                                <svg id="scatterPatternPreview"></svg>
                            </div>
                            <svg class="plus-icon" onclick="addData(event)" viewBox="0 0 24 24" fill="none" stroke="#6ba3ff" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="12" y1="8" x2="12" y2="16"/>
                                <line x1="8" y1="12" x2="16" y2="12"/>
                            </svg>
                        </div>

                        <!-- Area chart input row (no color picker per item) -->
                        <div class="input-row" id="areaInputRow" style="display: none; grid-template-columns: 1fr 90px auto; gap: 8px;">
                            <input type="text" id="areaLabelInput" placeholder="Label" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <input type="number" id="areaValueInput" placeholder="Value" min="0" onclick="if(document.getElementById('editPopup').classList.contains('active')) closeEditPopup();" />
                            <svg class="plus-icon" onclick="addData(event)" viewBox="0 0 24 24" fill="none" stroke="#6ba3ff" stroke-width="2">
                                <circle cx="12" cy="12" r="10"/>
                                <line x1="12" y1="8" x2="12" y2="16"/>
                                <line x1="8" y1="12" x2="16" y2="12"/>
                            </svg>
                        </div>

                        <input type="hidden" id="colorInput" value="#e63946" />
                        <input type="hidden" id="patternInput" value="solid" />

                        <div id="dataList" class="mt-16 overflow-scroll"></div>
                </div>

                <!-- Settings Panel -->
                <div class="sidebar-panel" id="chartSettingsPanel">
                    <h3>Settings</h3>

                        <!-- Row 1: Aspect Ratio + Background (half width), Text Font (half width) -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;" class="mb-12">
                            <div style="display: flex; gap: 12px;">
                                <div style="flex: 1;">
                                    <label class="section-label">Aspect Ratio</label>
                                    <div class="flex-gap16-center">
                                        <button data-ratio="16:9" onclick="selectAspectRatio('16:9', this)" class="aspect-ratio-btn selected aspect-btn-base flex-col-center-gap3" style="opacity: 1;">
                                            <svg width="32" height="20" viewBox="0 0 32 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <rect x="1" y="1" width="30" height="18" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
                                            </svg>
                                            <span class="label-fontsize-10">16:9</span>
                                        </button>
                                        <button data-ratio="9:16" onclick="selectAspectRatio('9:16', this)" class="aspect-ratio-btn aspect-btn-base flex-col-center-gap3" style="opacity: 0.4;">
                                            <svg width="20" height="32" viewBox="0 0 20 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                                                <rect x="1" y="1" width="18" height="30" rx="1" stroke="currentColor" stroke-width="2" fill="none"/>
                                            </svg>
                                            <span class="label-fontsize-10">9:16</span>
                                        </button>
                                    </div>
                                </div>
                                <div class="label-input-group mb-0" style="flex-shrink: 0;">
                                    <label>Background</label>
                                    <div class="color-pattern-preview" id="bgColorDisplay" onclick="openBgColorPicker()" style="width: 60px; height: 44px; cursor: pointer; background: #ffffff; border: 2px solid rgba(45, 52, 54, 0.15); border-radius: 12px;"></div>
                                    <input type="hidden" id="bgColor" value="#ffffff">
                                    <input type="hidden" id="bgPattern" value="">
                                </div>
                            </div>
                            <div class="label-input-group mb-0">
                                <label for="fontFamily">Text Font</label>
                                <select id="fontFamily" onchange="updatePreview()" class="full-width-select-sm">
                                    <option value="Comic Sans MS, cursive">Comic Sans MS</option>
                                    <option value="Bradley Hand, Comic Sans MS, cursive">Bradley Hand</option>
                                    <option value="Marker Felt, Comic Sans MS, cursive">Marker Felt</option>
                                    <option value="Noteworthy, sans-serif" selected>Noteworthy</option>
                                    <option value="Snell Roundhand, cursive">Snell Roundhand</option>
                                    <option value="Apple Chancery, cursive">Apple Chancery</option>
                                    <option value="Papyrus, fantasy">Papyrus</option>
                                    <option value="Segoe Script, Comic Sans MS, cursive">Segoe Script</option>
                                    <option value="Lucida Handwriting, cursive">Lucida Handwriting</option>
                                    <option value="Segoe Print, Comic Sans MS, sans-serif">Segoe Print</option>
                                </select>
                            </div>
                        </div>

                        <!-- Row 2: Chart Width and Height (for Bar/Line) or Chart Size (for Pie) -->
                        <div class="grid-2col-gap12 mb-12">
                            <!-- Chart Size (for Pie chart only) -->
                            <div class="slider-group mb-0 span-2" id="chartSizeSliderGroup" style="display: none;">
                                <label>
                                    <span>Chart Size</span>
                                    <span class="slider-value" id="chartSizeDisplay">90%</span>
                                </label>
                                <input type="range" id="chartSizeSlider" min="50" max="100" value="90" step="5" oninput="updateChartSizeDisplay(this.value)" class="full-width-slider">
                            </div>
                            <!-- Chart Width (for Bar and Line charts) -->
                            <div class="slider-group mb-0" id="chartWidthSliderGroup">
                                <label>
                                    <span>Chart Width</span>
                                    <span class="slider-value" id="chartWidthDisplay">90%</span>
                                </label>
                                <input type="range" id="chartWidthSlider" min="50" max="100" value="90" step="5" oninput="updateChartWidthDisplay(this.value)" class="full-width-slider">
                            </div>
                            <!-- Chart Height (for Bar and Line charts) -->
                            <div class="slider-group mb-0" id="chartHeightSliderGroup">
                                <label>
                                    <span>Chart Height</span>
                                    <span class="slider-value" id="chartHeightDisplay">90%</span>
                                </label>
                                <input type="range" id="chartHeightSlider" min="50" max="100" value="90" step="5" oninput="updateChartHeightDisplay(this.value)" class="full-width-slider">
                            </div>
                        </div>

                        <!-- Row 3: Line Roughness and Duration -->
                        <div class="grid-2col-gap12 mb-12">
                            <div class="slider-group mb-0">
                                <label>
                                    <span>Line Roughness</span>
                                    <span class="slider-value" id="roughnessDisplay">2.0</span>
                                </label>
                                <input type="range" id="roughnessSlider" min="0" max="5" value="2" step="0.5" oninput="updateRoughnessDisplay(this.value); updatePreview()" class="full-width-slider">
                            </div>
                            <div class="slider-group mb-0">
                                <label>
                                    <span>Duration</span>
                                    <span class="slider-value" id="durationDisplay">0.8s</span>
                                </label>
                                <input type="range" id="durationSlider" min="300" max="5000" value="800" step="100" oninput="updateDurationDisplay(this.value); updatePreview()" class="full-width-slider">
                            </div>
                        </div>

                        <!-- Title Row -->
                        <div class="grid-2col-100-gap8 mb-12">
                            <div class="label-input-group mb-0 span-2">
                                <label for="chartTitle">Title</label>
                                <input type="text" id="chartTitle" placeholder="Chart title" oninput="updatePreview()" onclick="event.stopPropagation()">
                            </div>
                            <div class="label-input-group mb-0">
                                <label>Font Size</label>
                                <input type="number" id="titleFontSize" min="10" max="80" value="50" step="2" oninput="updatePreview()" onclick="event.stopPropagation()" class="full-width-input">
                            </div>
                        </div>

                        <!-- Pie Chart Data Label Font Size (shown only for pie chart) -->
                        <div id="pieDataLabelFontSizeSetting" class="mb-12" style="display: none;">
                            <div class="label-input-group mb-0">
                                <label>Data Label Font Size</label>
                                <input type="number" id="pieDataLabelFontSize" min="10" max="50" value="35" step="2" oninput="updatePreview()" onclick="event.stopPropagation()" class="full-width-input">
                            </div>
                        </div>

                        <!-- Axis Settings (shown only for bar and line charts) -->
                        <div id="axisSettings" class="grid-2col-100-gap8 mb-12">
                            <div class="label-input-group mb-0">
                                <label for="xAxisLabel">X-Axis</label>
                                <input type="text" id="xAxisLabel" placeholder="X-axis" oninput="updatePreview()" onclick="event.stopPropagation()">
                            </div>
                            <div class="label-input-group mb-0">
                                <label for="yAxisLabel">Y-Axis</label>
                                <input type="text" id="yAxisLabel" placeholder="Y-axis" oninput="updatePreview()" onclick="event.stopPropagation()">
                            </div>
                            <div class="label-input-group mb-0">
                                <label>Font Size</label>
                                <input type="number" id="axisFontSize" min="10" max="50" value="35" step="2" oninput="updatePreview()" onclick="event.stopPropagation()" class="full-width-input">
                            </div>
                        </div>

                        <div id="lineshapeSettings" class="mb-12" style="display: none;">
                            <label class="section-label" style="margin-bottom: 6px;">Datapoint Shape</label>
                            <select id="datapointShape" onchange="updatePreview()" class="full-width-select">
                                <option value="circle">Circle</option>
                                <option value="square">Square</option>
                                <option value="diamond">Diamond</option>
                                <option value="triangle">Triangle</option>
                            </select>
                        </div>
                </div>
            </div>

            <!-- Right Column: Chart Area and Buttons -->
            <div class="right-column">
                <!-- Chart Area -->
                <div class="chart-area">
                    <div class="chart-container-wrapper">
                        <div class="chart-container" id="chartContainer">
                            <svg id="chartSvg" style="display: none;"></svg>
                            <div class="empty-state" id="emptyState">
                                <div class="empty-icon"><img src="images/data.png" alt="Chart icon" style="width: 27px; height: auto; opacity: 0.6;"></div>
                                <div>Add data to see preview</div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Animate Buttons -->
                <div class="animate-btn-container flex-gap12 flex-center">
                    <button class="animate-btn" onclick="animateChart()" id="animateBtn" disabled>
                        â–¶ Animate Chart
                    </button>
                    <button class="animate-btn" id="downloadGifBtn" disabled>
                        Download as GIF
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Edit Color/Pattern Popup -->
    <div class="edit-popup" id="editPopup">
        <div class="color-picker-container">
            <canvas id="colorCanvas" class="color-canvas" width="180" height="180"></canvas>
            <canvas id="hueSlider" class="color-hue-slider" width="20" height="180"></canvas>
        </div>
        <div class="color-hex-input">
            <label>Hex:</label>
            <input type="text" id="hexInput" maxlength="7" value="#FF0000" oninput="updateColorFromHex()">
            <div class="color-display-small" id="colorDisplaySmall"></div>
        </div>
        <div class="edit-popup-patterns">
            <div class="edit-popup-pattern selected" data-pattern="solid" onclick="selectPopupPattern('solid', this)">
                <svg id="popup-preview-solid"></svg>
            </div>
            <div class="edit-popup-pattern" data-pattern="hachure" onclick="selectPopupPattern('hachure', this)">
                <svg id="popup-preview-hachure"></svg>
            </div>
            <div class="edit-popup-pattern" data-pattern="cross-hatch" onclick="selectPopupPattern('cross-hatch', this)">
                <svg id="popup-preview-cross-hatch"></svg>
            </div>
            <div class="edit-popup-pattern" data-pattern="dots" onclick="selectPopupPattern('dots', this)">
                <svg id="popup-preview-dots"></svg>
            </div>
            <div class="edit-popup-pattern" data-pattern="dashed" onclick="selectPopupPattern('dashed', this)">
                <svg id="popup-preview-dashed"></svg>
            </div>
            <div class="edit-popup-pattern" data-pattern="zigzag-line" onclick="selectPopupPattern('zigzag-line', this)">
                <svg id="popup-preview-zigzag-line"></svg>
            </div>
        </div>
    </div>

    <!-- Background Color Picker Popup -->
    <div class="edit-popup" id="bgColorPickerPopup" style="min-width: 350px; max-width: 400px; max-height: 80vh; overflow-y: auto;">
        <h4 class="popup-heading">Background Color</h4>
        <div class="color-picker-container">
            <canvas id="bgColorCanvas" class="color-canvas" width="180" height="180"></canvas>
            <canvas id="bgHueSlider" class="color-hue-slider" width="20" height="180"></canvas>
        </div>
        <div class="color-hex-input">
            <label>Hex:</label>
            <input type="text" id="bgHexInput" maxlength="7" value="#FFFFFF" oninput="updateBgColorFromHex()">
            <div class="color-display-small" id="bgColorDisplaySmall"></div>
        </div>

        <hr class="hr-divider">

        <h4 class="popup-heading">Pattern Overlay (Optional)</h4>
        <div class="grid-4col-gap8 mb-12">
            <div class="bg-pattern-option bg-pattern-base bg-pattern-text" data-pattern="" onclick="selectBgPattern('', this)">
                None
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-01.png" onclick="selectBgPattern('Paper/Grid-01.png', this)">
                <img src="Paper/Grid-01.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-03.png" onclick="selectBgPattern('Paper/Grid-03.png', this)">
                <img src="Paper/Grid-03.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-04.png" onclick="selectBgPattern('Paper/Grid-04.png', this)">
                <img src="Paper/Grid-04.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-05.png" onclick="selectBgPattern('Paper/Grid-05.png', this)">
                <img src="Paper/Grid-05.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-06.png" onclick="selectBgPattern('Paper/Grid-06.png', this)">
                <img src="Paper/Grid-06.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-07.png" onclick="selectBgPattern('Paper/Grid-07.png', this)">
                <img src="Paper/Grid-07.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-08.png" onclick="selectBgPattern('Paper/Grid-08.png', this)">
                <img src="Paper/Grid-08.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Grid-09.png" onclick="selectBgPattern('Paper/Grid-09.png', this)">
                <img src="Paper/Grid-09.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Lines-01.png" onclick="selectBgPattern('Paper/Lines-01.png', this)">
                <img src="Paper/Lines-01.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Lines-02.png" onclick="selectBgPattern('Paper/Lines-02.png', this)">
                <img src="Paper/Lines-02.png" class="bg-pattern-img">
            </div>
            <div class="bg-pattern-option bg-pattern-base bg-pattern-image" data-pattern="Paper/Lines-03.png" onclick="selectBgPattern('Paper/Lines-03.png', this)">
                <img src="Paper/Lines-03.png" class="bg-pattern-img">
            </div>
        </div>

        <hr class="hr-divider">

        <h4 class="popup-heading" style="margin-bottom: 8px;">Or Upload Custom Image</h4>
        <div class="flex-gap8-center">
            <input type="file" id="bgImage" accept="image/*" onchange="handleBackgroundImage()" class="upload-flex">
            <button onclick="clearBackgroundImage()" id="clearBgImageBtn" class="clear-btn" style="display: none;">Clear</button>
        </div>
    </div>

    <script>
        let dataItems = [];
        let rc;
        let currentPaletteIndex = 0;
        let editingItemIndex = -1;
        let modalSelectedPattern = 'solid';
        let currentChartType = 'bar';
        let currentAspectRatio = '16:9';
        let chartSizePercent = 90; // Used for pie chart
        let chartWidthPercent = 90; // Used for bar and line charts
        let chartHeightPercent = 90; // Used for bar and line charts
        let backgroundImage = null;

        const PALETTES = {
            'retro': {
                name: 'Retro Warm',
                colors: ['#e63946', '#f77f00', '#fcbf49', '#06a77d', '#118ab2', '#073b4c', '#dd6e42', '#e8dab2'],
                gradient: 'linear-gradient(90deg, #e63946 0%, #e63946 12.5%, #f77f00 12.5%, #f77f00 25%, #fcbf49 25%, #fcbf49 37.5%, #06a77d 37.5%, #06a77d 50%, #118ab2 50%, #118ab2 62.5%, #073b4c 62.5%, #073b4c 75%, #dd6e42 75%, #dd6e42 87.5%, #e8dab2 87.5%, #e8dab2 100%)'
            },
            'pastel': {
                name: 'Pastel Soft',
                colors: ['#ffb5c2', '#ffd4a3', '#fff5ba', '#b4e4d4', '#c5a9e8', '#ffccf9', '#a8e6cf', '#ffd3b6'],
                gradient: 'linear-gradient(90deg, #ffb5c2 0%, #ffb5c2 12.5%, #ffd4a3 12.5%, #ffd4a3 25%, #fff5ba 25%, #fff5ba 37.5%, #b4e4d4 37.5%, #b4e4d4 50%, #c5a9e8 50%, #c5a9e8 62.5%, #ffccf9 62.5%, #ffccf9 75%, #a8e6cf 75%, #a8e6cf 87.5%, #ffd3b6 87.5%, #ffd3b6 100%)'
            },
            'vintage': {
                name: 'Vintage Earth',
                colors: ['#8b7e66', '#a4907c', '#c9b8a3', '#7d8570', '#8e7c68', '#b4a088', '#9b8b7e', '#a89f91'],
                gradient: 'linear-gradient(90deg, #8b7e66 0%, #8b7e66 12.5%, #a4907c 12.5%, #a4907c 25%, #c9b8a3 25%, #c9b8a3 37.5%, #7d8570 37.5%, #7d8570 50%, #8e7c68 50%, #8e7c68 62.5%, #b4a088 62.5%, #b4a088 75%, #9b8b7e 75%, #9b8b7e 87.5%, #a89f91 87.5%, #a89f91 100%)'
            },
            'poster': {
                name: 'Poster Bold',
                colors: ['#264653', '#2a9d8f', '#e9c46a', '#f4a261', '#e76f51', '#6a994e', '#bc4749', '#9d4edd'],
                gradient: 'linear-gradient(90deg, #264653 0%, #264653 12.5%, #2a9d8f 12.5%, #2a9d8f 25%, #e9c46a 25%, #e9c46a 37.5%, #f4a261 37.5%, #f4a261 50%, #e76f51 50%, #e76f51 62.5%, #6a994e 62.5%, #6a994e 75%, #bc4749 75%, #bc4749 87.5%, #9d4edd 87.5%, #9d4edd 100%)'
            },
            'sketch': {
                name: 'Sketch Blue',
                colors: ['#457b9d', '#a8dadc', '#f1faee', '#e63946', '#1d3557', '#f77f00', '#06a77d', '#e9c46a'],
                gradient: 'linear-gradient(90deg, #457b9d 0%, #457b9d 12.5%, #a8dadc 12.5%, #a8dadc 25%, #f1faee 25%, #f1faee 37.5%, #e63946 37.5%, #e63946 50%, #1d3557 50%, #1d3557 62.5%, #f77f00 62.5%, #f77f00 75%, #06a77d 75%, #06a77d 87.5%, #e9c46a 87.5%, #e9c46a 100%)'
            },
            'autumn': {
                name: 'Autumn Leaves',
                colors: ['#8b4513', '#d2691e', '#daa520', '#b8860b', '#cd853f', '#a0522d', '#c19a6b', '#e3a857'],
                gradient: 'linear-gradient(90deg, #8b4513 0%, #8b4513 12.5%, #d2691e 12.5%, #d2691e 25%, #daa520 25%, #daa520 37.5%, #b8860b 37.5%, #b8860b 50%, #cd853f 50%, #cd853f 62.5%, #a0522d 62.5%, #a0522d 75%, #c19a6b 75%, #c19a6b 87.5%, #e3a857 87.5%, #e3a857 100%)'
            },
            'ocean': {
                name: 'Ocean Breeze',
                colors: ['#006994', '#247ba0', '#1e96c8', '#2cb5e8', '#7fcdff', '#4dd0e1', '#00acc1', '#0097a7'],
                gradient: 'linear-gradient(90deg, #006994 0%, #006994 12.5%, #247ba0 12.5%, #247ba0 25%, #1e96c8 25%, #1e96c8 37.5%, #2cb5e8 37.5%, #2cb5e8 50%, #7fcdff 50%, #7fcdff 62.5%, #4dd0e1 62.5%, #4dd0e1 75%, #00acc1 75%, #00acc1 87.5%, #0097a7 87.5%, #0097a7 100%)'
            },
            'forest': {
                name: 'Forest Green',
                colors: ['#2d5016', '#3d6b28', '#4a7c3a', '#5a8e4c', '#6ca35f', '#7eb773', '#90ca87', '#a4d99b'],
                gradient: 'linear-gradient(90deg, #2d5016 0%, #2d5016 12.5%, #3d6b28 12.5%, #3d6b28 25%, #4a7c3a 25%, #4a7c3a 37.5%, #5a8e4c 37.5%, #5a8e4c 50%, #6ca35f 50%, #6ca35f 62.5%, #7eb773 62.5%, #7eb773 75%, #90ca87 75%, #90ca87 87.5%, #a4d99b 87.5%, #a4d99b 100%)'
            },
            'sunset': {
                name: 'Sunset Glow',
                colors: ['#ff6b35', '#f7931e', '#fdc82f', '#fbb040', '#f89c50', '#f57e5f', '#f25f70', '#ef4180'],
                gradient: 'linear-gradient(90deg, #ff6b35 0%, #ff6b35 12.5%, #f7931e 12.5%, #f7931e 25%, #fdc82f 25%, #fdc82f 37.5%, #fbb040 37.5%, #fbb040 50%, #f89c50 50%, #f89c50 62.5%, #f57e5f 62.5%, #f57e5f 75%, #f25f70 75%, #f25f70 87.5%, #ef4180 87.5%, #ef4180 100%)'
            },
            'candy': {
                name: 'Candy Pop',
                colors: ['#ff6b9d', '#c44569', '#ffa07a', '#fa8072', '#e0b0ff', '#dda0dd', '#ffc0cb', '#ffb6c1'],
                gradient: 'linear-gradient(90deg, #ff6b9d 0%, #ff6b9d 12.5%, #c44569 12.5%, #c44569 25%, #ffa07a 25%, #ffa07a 37.5%, #fa8072 37.5%, #fa8072 50%, #e0b0ff 50%, #e0b0ff 62.5%, #dda0dd 62.5%, #dda0dd 75%, #ffc0cb 75%, #ffc0cb 87.5%, #ffb6c1 87.5%, #ffb6c1 100%)'
            },
            'earthy': {
                name: 'Earthy Tones',
                colors: ['#936639', '#a67c52', '#b8926b', '#caa884', '#7c6a5c', '#8d7966', '#9e8870', '#af977a'],
                gradient: 'linear-gradient(90deg, #936639 0%, #936639 12.5%, #a67c52 12.5%, #a67c52 25%, #b8926b 25%, #b8926b 37.5%, #caa884 37.5%, #caa884 50%, #7c6a5c 50%, #7c6a5c 62.5%, #8d7966 62.5%, #8d7966 75%, #9e8870 75%, #9e8870 87.5%, #af977a 87.5%, #af977a 100%)'
            },
            'neon': {
                name: 'Neon Bright',
                colors: ['#ff006e', '#fb5607', '#ffbe0b', '#8338ec', '#3a86ff', '#06ffa5', '#ff006e', '#fb5607'],
                gradient: 'linear-gradient(90deg, #ff006e 0%, #ff006e 12.5%, #fb5607 12.5%, #fb5607 25%, #ffbe0b 25%, #ffbe0b 37.5%, #8338ec 37.5%, #8338ec 50%, #3a86ff 50%, #3a86ff 62.5%, #06ffa5 62.5%, #06ffa5 75%, #ff006e 75%, #ff006e 87.5%, #fb5607 87.5%, #fb5607 100%)'
            },
            'muted': {
                name: 'Muted Grey',
                colors: ['#6c757d', '#8d99ae', '#9ba4b5', '#adb5bd', '#b1a7a6', '#c6b9cd', '#d6cbd3', '#e5d4ce'],
                gradient: 'linear-gradient(90deg, #6c757d 0%, #6c757d 12.5%, #8d99ae 12.5%, #8d99ae 25%, #9ba4b5 25%, #9ba4b5 37.5%, #adb5bd 37.5%, #adb5bd 50%, #b1a7a6 50%, #b1a7a6 62.5%, #c6b9cd 62.5%, #c6b9cd 75%, #d6cbd3 75%, #d6cbd3 87.5%, #e5d4ce 87.5%, #e5d4ce 100%)'
            }
        };

        let selectedPalette = 'retro';

        window.addEventListener('DOMContentLoaded', () => {
            const svg = document.getElementById('chartSvg');
            rc = rough.svg(svg);
            initializePopupPatternPreviews();
            updateCurrentPatternPreview();
        });

        function togglePaletteDropdown() {
            const options = document.getElementById('paletteDropdownOptions');
            options.style.display = options.style.display === 'none' ? 'block' : 'none';
        }

        function selectPaletteOption(paletteName, event) {
            event.stopPropagation();
            document.getElementById('selectedPaletteName').textContent = PALETTES[paletteName].name;
            document.getElementById('selectedPaletteStrip').style.background = PALETTES[paletteName].gradient;
            document.getElementById('paletteDropdownOptions').style.display = 'none';
            selectPalette(paletteName);
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.querySelector('.custom-palette-dropdown');
            const options = document.getElementById('paletteDropdownOptions');
            if (dropdown && !dropdown.contains(event.target)) {
                options.style.display = 'none';
            }
        });

        function selectChartType(chartType, element) {
            currentChartType = chartType;
            document.querySelectorAll('.mode-btn[data-chart]').forEach(btn => {
                btn.classList.remove('selected');
            });
            element.classList.add('selected');

            // Show/hide different input rows based on chart type
            const standardInputRow = document.getElementById('standardInputRow');
            const scatterInputRow = document.getElementById('scatterInputRow');
            const areaInputRow = document.getElementById('areaInputRow');
            const areaColorSection = document.getElementById('areaColorSection');
            const paletteSection = document.getElementById('paletteSection');

            // Hide all input rows first
            standardInputRow.style.display = 'none';
            scatterInputRow.style.display = 'none';
            areaInputRow.style.display = 'none';
            areaColorSection.style.display = 'none';

            // Show appropriate input row based on chart type
            if (chartType === 'scatter') {
                scatterInputRow.style.display = 'grid';
                paletteSection.style.display = 'block';
                updateCurrentPatternPreview(); // Update scatter preview
            } else if (chartType === 'area') {
                areaInputRow.style.display = 'grid';
                areaColorSection.style.display = 'block';
                paletteSection.style.display = 'none';
                updateAreaPatternPreview();
            } else {
                // Bar, Pie, Line, H-Bar use standard input
                standardInputRow.style.display = 'grid';
                paletteSection.style.display = 'block';
                updateCurrentPatternPreview(); // Update standard preview
            }

            // Show/hide axis settings and line shape settings based on chart type
            const axisSettings = document.getElementById('axisSettings');
            const lineshapeSettings = document.getElementById('lineshapeSettings');
            const pieDataLabelFontSizeSetting = document.getElementById('pieDataLabelFontSizeSetting');

            // Show/hide size sliders based on chart type
            const chartSizeSliderGroup = document.getElementById('chartSizeSliderGroup');
            const chartWidthSliderGroup = document.getElementById('chartWidthSliderGroup');
            const chartHeightSliderGroup = document.getElementById('chartHeightSliderGroup');

            if (chartType === 'pie') {
                axisSettings.style.display = 'none';
                pieDataLabelFontSizeSetting.style.display = 'block';
                // Show single size slider for pie chart
                chartSizeSliderGroup.style.display = 'block';
                chartWidthSliderGroup.style.display = 'none';
                chartHeightSliderGroup.style.display = 'none';
            } else {
                axisSettings.style.display = 'grid';
                pieDataLabelFontSizeSetting.style.display = 'none';
                // Show width and height sliders for bar and line charts
                chartSizeSliderGroup.style.display = 'none';
                chartWidthSliderGroup.style.display = 'block';
                chartHeightSliderGroup.style.display = 'block';
            }

            if (chartType === 'line' || chartType === 'area') {
                lineshapeSettings.style.display = 'block';
            } else {
                lineshapeSettings.style.display = 'none';
            }

            updateDataList(); // Refresh table to match chart type
            updatePreview(); // Chart type change requires re-animation
        }

        function selectAspectRatio(ratio, element) {
            currentAspectRatio = ratio;
            document.querySelectorAll('.aspect-ratio-btn').forEach(btn => {
                btn.classList.remove('selected');
                btn.style.opacity = '0.4';
            });
            element.classList.add('selected');
            element.style.opacity = '1';

            // Update the preview container aspect ratio
            const chartContainer = document.querySelector('.chart-container');
            if (chartContainer) {
                chartContainer.style.aspectRatio = ratio === '16:9' ? '16 / 9' : '9 / 16';
                // Adjust max-width for vertical to prevent it from being too wide
                chartContainer.style.maxWidth = ratio === '16:9' ? '900px' : '337px';
            }

            // Aspect ratio change requires re-animation
            updatePreview();
        }

        function updateChartSizeDisplay(value) {
            chartSizePercent = parseInt(value);
            document.getElementById('chartSizeDisplay').textContent = value + '%';
            updatePreview(); // Size change requires re-animation
        }

        function updateChartWidthDisplay(value) {
            chartWidthPercent = parseInt(value);
            document.getElementById('chartWidthDisplay').textContent = value + '%';
            updatePreview(); // Width change requires re-animation
        }

        function updateChartHeightDisplay(value) {
            chartHeightPercent = parseInt(value);
            document.getElementById('chartHeightDisplay').textContent = value + '%';
            updatePreview(); // Height change requires re-animation
        }

        let draggedDataIndex = null;

        function handleDragStart(e, index) {
            draggedDataIndex = index;
            e.currentTarget.style.opacity = '0.4';
        }

        function handleDragEnd(e) {
            e.currentTarget.style.opacity = '1';
        }

        function handleDragOver(e) {
            e.preventDefault();
            return false;
        }

        function handleDrop(e, dropIndex) {
            e.stopPropagation();

            if (draggedDataIndex !== null && draggedDataIndex !== dropIndex) {
                const draggedItem = dataItems[draggedDataIndex];
                dataItems.splice(draggedDataIndex, 1);
                dataItems.splice(dropIndex, 0, draggedItem);

                updateDataList();
                updatePreview();
            }

            draggedDataIndex = null;
            return false;
        }


        function selectBgPattern(patternPath, element) {
            document.getElementById('bgPattern').value = patternPath;

            // Remove selected class from all pattern options
            document.querySelectorAll('.bg-pattern-option').forEach(opt => {
                opt.style.borderColor = '#e0e7ff';
                opt.style.transform = 'scale(1)';
            });

            // Add selected class to clicked element
            if (element) {
                element.style.borderColor = '#6366f1';
                element.style.transform = 'scale(1.05)';
            }

            updateChartBackground();
        }

        function selectPalette(paletteName) {
            selectedPalette = paletteName;
            currentPaletteIndex = 0;

            document.getElementById('selectedPaletteStrip').style.background = PALETTES[paletteName].gradient;
            document.getElementById('selectedPaletteName').textContent = PALETTES[paletteName].name;

            const palette = PALETTES[paletteName].colors;
            dataItems.forEach((item, index) => {
                item.color = palette[index % palette.length];
            });

            currentPaletteIndex = dataItems.length;
            updateDataList();
            updatePreview(); // Color changes don't need re-animation
            updateColorInputFromPalette();
        }

        function updateColorInputFromPalette() {
            const palette = PALETTES[selectedPalette].colors;
            const nextColor = palette[currentPaletteIndex % palette.length];
            document.getElementById('colorInput').value = nextColor;
            updateCurrentPatternPreview();
        }

        function updateCurrentPatternPreview() {
            const color = document.getElementById('colorInput').value;
            const pattern = document.getElementById('patternInput').value;

            // Update standard preview
            const svgElement = document.getElementById('currentPatternPreview');
            if (svgElement) {
                svgElement.innerHTML = '';
                const roughSvg = rough.svg(svgElement);
                const hachureGap = pattern === 'dots' ? 12 : (pattern === 'solid' ? 1 : 6);
                const rect = roughSvg.rectangle(3, 3, 54, 38, {
                    fill: color,
                    fillStyle: pattern,
                    roughness: 2,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                svgElement.appendChild(rect);
            }

            // Update scatter preview
            const scatterSvgElement = document.getElementById('scatterPatternPreview');
            if (scatterSvgElement) {
                scatterSvgElement.innerHTML = '';
                const roughSvg = rough.svg(scatterSvgElement);
                const hachureGap = pattern === 'dots' ? 12 : (pattern === 'solid' ? 1 : 6);
                const rect = roughSvg.rectangle(3, 3, 54, 38, {
                    fill: color,
                    fillStyle: pattern,
                    roughness: 2,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                scatterSvgElement.appendChild(rect);
            }
        }

        function updatePopupPatternPreviews(color) {
            const patterns = [
                { name: 'solid', hachureGap: 1 },
                { name: 'hachure', hachureGap: 6 },
                { name: 'cross-hatch', hachureGap: 6 },
                { name: 'dots', hachureGap: 12 },
                { name: 'dashed', hachureGap: 6 },
                { name: 'zigzag-line', hachureGap: 6 }
            ];

            patterns.forEach(patternObj => {
                const svgElement = document.getElementById(`popup-preview-${patternObj.name}`);
                if (!svgElement) return;
                svgElement.innerHTML = ''; // Clear previous content
                const roughSvg = rough.svg(svgElement);
                const rect = roughSvg.rectangle(7, 7, 35, 35, {
                    fill: color,
                    fillStyle: patternObj.name,
                    roughness: 2,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: patternObj.hachureGap
                });
                svgElement.appendChild(rect);
            });
        }

        function initializePopupPatternPreviews() {
            // Initialize with default color
            updatePopupPatternPreviews('#667eea');
        }

        function updateDurationDisplay(value) {
            document.getElementById('durationDisplay').textContent = (value / 1000).toFixed(1) + 's';
        }

        function updateSketchDisplay(value) {
            document.getElementById('sketchDisplay').textContent = value + 'ms';
        }

        function updateRoughnessDisplay(value) {
            document.getElementById('roughnessDisplay').textContent = parseFloat(value).toFixed(1);
        }

        function handleBackgroundImage() {
            const file = document.getElementById('bgImage').files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    backgroundImage = e.target.result;
                    updateChartBackground();
                    closeBgColorPicker();
                    // Show clear button
                    document.getElementById('clearBgImageBtn').style.display = 'block';
                };
                reader.readAsDataURL(file);
            }
        }

        function clearBackgroundImage() {
            backgroundImage = null;
            document.getElementById('bgImage').value = ''; // Clear file input
            document.getElementById('clearBgImageBtn').style.display = 'none';
            updateChartBackground();
        }

        function updateChartBackground() {
            const chartContainer = document.querySelector('.chart-container');
            const bgColor = document.getElementById('bgColor').value || '#ffffff';
            const bgPattern = document.getElementById('bgPattern').value;

            // Apply background only to container (for display and GIF export)
            if (!chartContainer) return;

            // Always set the background color (default to white if not set)
            chartContainer.style.backgroundColor = bgColor;

            // Apply pattern or custom image as overlay
            if (backgroundImage && !bgPattern) {
                // Custom uploaded image
                chartContainer.style.backgroundImage = `url(${backgroundImage})`;
                chartContainer.style.backgroundSize = 'cover';
                chartContainer.style.backgroundPosition = 'center';
                chartContainer.style.backgroundBlendMode = 'multiply';
            } else if (bgPattern) {
                // Pattern overlay - fixed size so it doesn't scale with window
                chartContainer.style.backgroundImage = `url(${bgPattern})`;
                chartContainer.style.backgroundSize = '1200px 1200px'; // Fixed size (12x zoom for maximum visibility)
                chartContainer.style.backgroundRepeat = 'repeat';
                chartContainer.style.backgroundPosition = 'top left';
                chartContainer.style.backgroundBlendMode = 'multiply';
            } else {
                // No pattern or image, just solid color
                chartContainer.style.backgroundImage = 'none';
            }

            // Update the preview display
            const bgDisplay = document.getElementById('bgColorDisplay');
            bgDisplay.style.backgroundColor = bgColor || '#ffffff';
            if (bgPattern) {
                bgDisplay.style.backgroundImage = `url(${bgPattern})`;
                bgDisplay.style.backgroundSize = '40px 40px';
                bgDisplay.style.backgroundRepeat = 'repeat';
            } else if (backgroundImage) {
                bgDisplay.style.backgroundImage = `url(${backgroundImage})`;
                bgDisplay.style.backgroundSize = 'cover';
            } else {
                bgDisplay.style.backgroundImage = 'none';
            }
        }

        function addData(event) {
            // Close edit popup if it's open
            const editPopup = document.getElementById('editPopup');
            if (editPopup && editPopup.classList.contains('active')) {
                closeEditPopup();
            }

            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }

            let label, value, xValue, yValue, color, pattern;

            if (currentChartType === 'scatter') {
                // Scatter chart: Label, X, Y, Color/Pattern
                label = document.getElementById('scatterLabelInput').value.trim();
                xValue = parseFloat(document.getElementById('scatterXInput').value);
                yValue = parseFloat(document.getElementById('scatterYInput').value);
                color = document.getElementById('colorInput').value;
                pattern = document.getElementById('patternInput').value;

                if (!label || isNaN(xValue) || isNaN(yValue)) {
                    alert('Please enter a valid label, X value, and Y value');
                    return;
                }

                dataItems.push({ label, x: xValue, y: yValue, color, pattern });
                document.getElementById('scatterLabelInput').value = '';
                document.getElementById('scatterXInput').value = '';
                document.getElementById('scatterYInput').value = '';
                document.getElementById('scatterLabelInput').focus();

                currentPaletteIndex++;
                updateColorInputFromPalette();

            } else if (currentChartType === 'area') {
                // Area chart: Label, Value (color is shared for all items)
                label = document.getElementById('areaLabelInput').value.trim();
                value = parseFloat(document.getElementById('areaValueInput').value);
                color = document.getElementById('colorInput').value;
                pattern = document.getElementById('patternInput').value;

                if (!label || !value || value <= 0) {
                    alert('Please enter a valid label and positive value');
                    return;
                }

                dataItems.push({ label, value, color, pattern });
                document.getElementById('areaLabelInput').value = '';
                document.getElementById('areaValueInput').value = '';
                document.getElementById('areaLabelInput').focus();

            } else {
                // Standard charts (Bar, Pie, Line, H-Bar): Label, Value, Color/Pattern
                label = document.getElementById('labelInput').value.trim();
                value = parseFloat(document.getElementById('valueInput').value);
                color = document.getElementById('colorInput').value;
                pattern = document.getElementById('patternInput').value;

                if (!label || !value || value <= 0) {
                    alert('Please enter a valid label and positive value');
                    return;
                }

                dataItems.push({ label, value, color, pattern });
                document.getElementById('labelInput').value = '';
                document.getElementById('valueInput').value = '';
                document.getElementById('labelInput').focus();

                currentPaletteIndex++;
                updateColorInputFromPalette();
            }

            updateDataList();
            updatePreview();
            document.getElementById('animateBtn').disabled = false;
        }

        function removeData(index) {
            dataItems.splice(index, 1);
            updateDataList();
            updatePreview();

            if (dataItems.length === 0) {
                document.getElementById('animateBtn').disabled = true;
            }
        }

        function updateDataLabel(index, newLabel) {
            if (newLabel && newLabel.trim()) {
                dataItems[index].label = newLabel.trim();
                updateDataList();
                updatePreview();
            }
        }

        function updateDataValue(index, newValue) {
            const value = parseFloat(newValue);
            if (!isNaN(value) && value > 0) {
                dataItems[index].value = value;
                updateDataList();
                updatePreview();
            }
        }

        function updateDataX(index, newValue) {
            const value = parseFloat(newValue);
            if (!isNaN(value)) {
                dataItems[index].x = value;
                updateDataList();
                updatePreview();
            }
        }

        function updateDataY(index, newValue) {
            const value = parseFloat(newValue);
            if (!isNaN(value)) {
                dataItems[index].y = value;
                updateDataList();
                updatePreview();
            }
        }

        let editingDataIndex = -1;

        function editDataColor(index) {
            editingDataIndex = index;
            const item = dataItems[index];

            document.getElementById('colorInput').value = item.color;
            document.getElementById('patternInput').value = item.pattern;

            const hsl = hexToHsl(item.color);
            currentHue = hsl.h;
            currentSaturation = hsl.s;
            currentLightness = hsl.l;

            document.getElementById('hexInput').value = item.color.toUpperCase();
            document.getElementById('colorDisplaySmall').style.backgroundColor = item.color;

            document.querySelectorAll('.edit-popup-pattern').forEach(p => {
                p.classList.remove('selected');
                if (p.dataset.pattern === item.pattern) {
                    p.classList.add('selected');
                }
            });

            modalSelectedPattern = item.pattern;
            const popup = document.getElementById('editPopup');
            popup.classList.add('active');

            // Update pattern previews with current color
            updatePopupPatternPreviews(item.color);

            setTimeout(() => {
                const previewElement = document.getElementById(`data-preview-${index}`);
                const rect = previewElement.getBoundingClientRect();
                popup.style.left = rect.left + 'px';
                popup.style.top = (rect.bottom + 5) + 'px';
            }, 0);

            if (!popup.dataset.initialized) {
                initializeColorPicker();
                popup.dataset.initialized = 'true';
            } else {
                drawColorPicker();
            }
        }

        function updateDataList() {
            const dataList = document.getElementById('dataList');
            if (dataItems.length === 0) {
                dataList.innerHTML = '<div class="no-data-message">No data items yet</div>';
                return;
            }

            let tableHTML = '';

            // Different table headers based on chart type
            if (currentChartType === 'scatter') {
                // Scatter: Label, X, Y, Background
                tableHTML = `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th class="th-width-28">Label</th>
                                <th class="th-width-16">X</th>
                                <th class="th-width-16">Y</th>
                                <th class="th-width-24">Background</th>
                                <th class="th-width-10"></th>
                                <th class="th-width-12"></th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                `;
            } else if (currentChartType === 'area') {
                // Area: Label, Value only (no background column)
                tableHTML = `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th class="th-width-50">Label</th>
                                <th class="th-width-28">Value</th>
                                <th class="th-width-10"></th>
                                <th class="th-width-12"></th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                `;
            } else {
                // Standard: Label, Value, Background
                tableHTML = `
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th class="th-width-32">Label</th>
                                <th class="th-width-18">Value</th>
                                <th class="th-width-28">Background</th>
                                <th class="th-width-10"></th>
                                <th class="th-width-12"></th>
                            </tr>
                        </thead>
                        <tbody id="dataTableBody">
                `;
            }

            dataItems.forEach((item, index) => {
                const previewId = `data-preview-${index}`;

                if (currentChartType === 'scatter') {
                    // Scatter row: Label, X, Y, Background, Move, Delete
                    tableHTML += `
                        <tr data-index="${index}" draggable="true"
                            ondragstart="handleDragStart(event, ${index})"
                            ondragend="handleDragEnd(event)"
                            ondragover="handleDragOver(event)"
                            ondrop="handleDrop(event, ${index})"
                            class="cursor-move">
                            <td>
                                <input type="text" value="${item.label}"
                                    onchange="updateDataLabel(${index}, this.value)" class="cursor-text">
                            </td>
                            <td>
                                <input type="number" value="${item.x !== undefined ? item.x : 0}" step="any"
                                    onchange="updateDataX(${index}, this.value)" class="cursor-text" style="min-width: 50px; width: 100%;">
                            </td>
                            <td>
                                <input type="number" value="${item.y !== undefined ? item.y : 0}" step="any"
                                    onchange="updateDataY(${index}, this.value)" class="cursor-text" style="min-width: 50px; width: 100%;">
                            </td>
                            <td onclick="editDataColor(${index})" class="cursor-pointer" style="padding: 6px;">
                                <svg id="${previewId}"
                                    style="width: 100%; height: 36px; border: 1px solid #e0e7ff; border-radius: 4px; pointer-events: none;"
                                    title="Click to edit"></svg>
                            </td>
                            <td class="text-center">
                                <svg class="move-icon" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;">
                                    <line x1="3" y1="6" x2="21" y2="6"></line>
                                    <line x1="3" y1="12" x2="21" y2="12"></line>
                                    <line x1="3" y1="18" x2="21" y2="18"></line>
                                </svg>
                            </td>
                            <td class="text-center">
                                <svg class="trash-icon" onclick="removeData(${index})" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2">
                                    <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14z"/>
                                    <path d="M10 11v6M14 11v6"/>
                                </svg>
                            </td>
                        </tr>
                    `;
                } else if (currentChartType === 'area') {
                    // Area row: Label, Value, Move, Delete (no background)
                    tableHTML += `
                        <tr data-index="${index}" draggable="true"
                            ondragstart="handleDragStart(event, ${index})"
                            ondragend="handleDragEnd(event)"
                            ondragover="handleDragOver(event)"
                            ondrop="handleDrop(event, ${index})"
                            class="cursor-move">
                            <td>
                                <input type="text" value="${item.label}"
                                    onchange="updateDataLabel(${index}, this.value)" class="cursor-text">
                            </td>
                            <td>
                                <input type="number" value="${item.value}" min="0"
                                    onchange="updateDataValue(${index}, this.value)" class="cursor-text">
                            </td>
                            <td class="text-center">
                                <svg class="move-icon" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;">
                                    <line x1="3" y1="6" x2="21" y2="6"></line>
                                    <line x1="3" y1="12" x2="21" y2="12"></line>
                                    <line x1="3" y1="18" x2="21" y2="18"></line>
                                </svg>
                            </td>
                            <td class="text-center">
                                <svg class="trash-icon" onclick="removeData(${index})" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2">
                                    <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14z"/>
                                    <path d="M10 11v6M14 11v6"/>
                                </svg>
                            </td>
                        </tr>
                    `;
                } else {
                    // Standard row: Label, Value, Background, Move, Delete
                    tableHTML += `
                        <tr data-index="${index}" draggable="true"
                            ondragstart="handleDragStart(event, ${index})"
                            ondragend="handleDragEnd(event)"
                            ondragover="handleDragOver(event)"
                            ondrop="handleDrop(event, ${index})"
                            class="cursor-move">
                            <td>
                                <input type="text" value="${item.label}"
                                    onchange="updateDataLabel(${index}, this.value)" class="cursor-text">
                            </td>
                            <td>
                                <input type="number" value="${item.value}" min="0"
                                    onchange="updateDataValue(${index}, this.value)" class="cursor-text">
                            </td>
                            <td onclick="editDataColor(${index})" class="cursor-pointer" style="padding: 6px;">
                                <svg id="${previewId}"
                                    style="width: 100%; height: 36px; border: 1px solid #e0e7ff; border-radius: 4px; pointer-events: none;"
                                    title="Click to edit"></svg>
                            </td>
                            <td class="text-center">
                                <svg class="move-icon" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="pointer-events: none;">
                                    <line x1="3" y1="6" x2="21" y2="6"></line>
                                    <line x1="3" y1="12" x2="21" y2="12"></line>
                                    <line x1="3" y1="18" x2="21" y2="18"></line>
                                </svg>
                            </td>
                            <td class="text-center">
                                <svg class="trash-icon" onclick="removeData(${index})" viewBox="0 0 24 24" fill="none" stroke="#9ca3af" stroke-width="2">
                                    <path d="M3 6h18M8 6V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2m3 0v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6h14z"/>
                                    <path d="M10 11v6M14 11v6"/>
                                </svg>
                            </td>
                        </tr>
                    `;
                }
            });

            tableHTML += `
                    </tbody>
                </table>
            `;

            dataList.innerHTML = tableHTML;

            dataItems.forEach((item, index) => {
                setTimeout(() => {
                    const previewId = `data-preview-${index}`;
                    const svgElement = document.getElementById(previewId);
                    if (svgElement) {
                        svgElement.innerHTML = '';
                        const roughSvg = rough.svg(svgElement);
                        const hachureGap = item.pattern === 'dots' ? 12 : (item.pattern === 'solid' ? 1 : 6);
                        const rect = roughSvg.rectangle(2, 2, svgElement.clientWidth - 4, 32, {
                            fill: item.color,
                            fillStyle: item.pattern,
                            roughness: 2,
                            strokeWidth: 2,
                            stroke: '#333',
                            fillWeight: 2,
                            hachureAngle: 60,
                            hachureGap: hachureGap
                        });
                        svgElement.appendChild(rect);
                    }
                }, 0);
            });
        }

        // Update the static preview (final frame without animation)
        function updatePreview() {
            const svg = document.getElementById('chartSvg');
            const emptyState = document.getElementById('emptyState');

            // Update font family CSS variable
            const fontFamily = document.getElementById('fontFamily')?.value || 'Noteworthy, sans-serif';
            document.documentElement.style.setProperty('--chart-font-family', fontFamily);

            if (dataItems.length === 0) {
                svg.style.display = 'none';
                emptyState.style.display = 'block';
                emptyState.innerHTML = '<div class="empty-icon"><img src="images/data.png" alt="Chart icon" style="width: 27px; height: auto; opacity: 0.6;"></div><div>Add data items to see preview</div>';
                return;
            }

            // Show static preview
            svg.style.display = 'block';
            emptyState.style.display = 'none';
            svg.innerHTML = '';

            // Set up SVG dimensions based on aspect ratio (same as animation)
            const canvasDims = getCanvasDimensions();
            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;

            // Remove any existing dimension attributes first
            svg.removeAttribute('width');
            svg.removeAttribute('height');

            // Reset all SVG styles to match animation initial state
            svg.style.width = '';
            svg.style.height = '';
            svg.style.maxWidth = '';

            // Set viewBox and styles (exactly matching animation approach)
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            // Reinitialize RoughJS after clearing SVG
            rc = rough.svg(svg);

            // Render the static chart (final frame)
            if (currentChartType === 'bar') {
                updateBarChart(svg);
            } else if (currentChartType === 'pie') {
                updatePieChart(svg);
            } else if (currentChartType === 'line') {
                updateLineChart(svg);
            } else if (currentChartType === 'area') {
                updateAreaChart(svg);
            } else if (currentChartType === 'scatter') {
                updateScatterChart(svg);
            } else if (currentChartType === 'hbar') {
                updateHorizontalBarChart(svg);
            }
        }

        function updateBarChart(svg) {
            // Get dimensions from viewBox if available, otherwise use defaults
            const viewBox = svg.getAttribute('viewBox');
            let svgWidth, svgHeight;
            if (viewBox) {
                const dims = viewBox.split(' ');
                svgWidth = parseFloat(dims[2]);
                svgHeight = parseFloat(dims[3]);
            } else {
                svgWidth = svg.clientWidth || 900;
                svgHeight = svg.clientHeight || 550;
            }
            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            // Scale fonts to keep visual size consistent across aspect ratios (matching animation)
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            // Get padding from chart size settings (matching animation)
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();
            const minPadding = { horizontal: 60, vertical: 40 };

            // Calculate padding - minimum needed for axis/labels + chart size setting
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60; // Extra for Y-axis labels
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const maxValue = Math.max(...dataItems.map(item => item.value));
            const barCount = dataItems.length;

            // Calculate bar sizing to center bars in available space
            const availableWidth = svgWidth - leftPadding - rightPadding;
            // Adjust spacing based on aspect ratio: horizontal needs less spacing
            const spacingRatio = currentAspectRatio === '16:9' ? 0.2 : 0.3;
            const totalSpacingWidth = availableWidth * spacingRatio;
            const barSpacing = totalSpacingWidth / (barCount + 1);
            const totalBarWidth = availableWidth - totalSpacingWidth;
            const barWidth = totalBarWidth / barCount;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const xAxisEnd = svgWidth - rightPadding;
            const dataLabelFontSize = axisFontSize; // Use same font size as axis
            const yAxisExtension = dataLabelFontSize + 20; // Extra space for data labels above bars

            const axisY = rc.line(
                leftPadding,
                topPadding - yAxisExtension,
                leftPadding,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisY);

            const axisX = rc.line(
                leftPadding,
                svgHeight - bottomPadding,
                xAxisEnd,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const xAxisCenter = (leftPadding + xAxisEnd) / 2;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xAxisCenter);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            // Draw the actual bars for static preview
            dataItems.forEach((item, index) => {
                const barHeight = (item.value / maxValue) * chartHeight;
                const barX = leftPadding + barSpacing + (barWidth + barSpacing) * index;
                const barY = svgHeight - bottomPadding - barHeight;

                // Draw white background first
                const whiteBackground = rc.rectangle(barX, barY, barWidth, barHeight, {
                    fill: '#ffffff',
                    fillStyle: 'solid',
                    roughness: roughness,
                    strokeWidth: 0,
                    stroke: 'transparent'
                });
                svg.appendChild(whiteBackground);

                // Draw the bar
                const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);
                const rect = rc.rectangle(barX, barY, barWidth, barHeight, {
                    fill: item.color,
                    fillStyle: item.pattern,
                    roughness: roughness,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                svg.appendChild(rect);

                // Draw bar label
                const barLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                barLabel.setAttribute('x', barX + barWidth / 2);
                barLabel.setAttribute('y', svgHeight - bottomPadding + 50);
                barLabel.setAttribute('text-anchor', 'middle');
                barLabel.setAttribute('class', 'bar-label');
                barLabel.style.fontSize = axisFontSize + 'px';
                barLabel.style.fontWeight = '600';
                barLabel.textContent = item.label;
                svg.appendChild(barLabel);

                // Draw data value label on top of bar
                const dataLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                dataLabel.setAttribute('x', barX + barWidth / 2);
                dataLabel.setAttribute('y', barY - 10);
                dataLabel.setAttribute('text-anchor', 'middle');
                dataLabel.setAttribute('class', 'bar-label');
                dataLabel.style.fontSize = dataLabelFontSize + 'px';
                dataLabel.style.fontWeight = '600';
                dataLabel.textContent = item.value;
                svg.appendChild(dataLabel);
            });
        }

        function updatePieChart(svg) {
            // Get dimensions from viewBox if available, otherwise use defaults
            const viewBox = svg.getAttribute('viewBox');
            let svgWidth, svgHeight;
            if (viewBox) {
                const dims = viewBox.split(' ');
                svgWidth = parseFloat(dims[2]);
                svgHeight = parseFloat(dims[3]);
            } else {
                svgWidth = svg.clientWidth || 900;
                svgHeight = svg.clientHeight || 550;
            }
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const basePieDataLabelFontSize = parseInt(document.getElementById('pieDataLabelFontSize').value) || 35;
            // Scale fonts to keep visual size consistent across aspect ratios
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const titleFontSize = baseTitleFontSize * fontScale;
            const pieDataLabelFontSize = basePieDataLabelFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            // Get padding from chart size settings (matching animation)
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();
            const minPadding = { horizontal: 60, vertical: 40 };
            const totalHorizontalPadding = minPadding.horizontal + padding.horizontal;
            const totalVerticalPadding = minPadding.vertical + padding.vertical;
            const topOffset = chartTitle ? titleFontSize + 20 : 0;

            // Calculate radius based on available space (chart size affects this)
            const availableSize = Math.min(
                svgWidth - totalHorizontalPadding * 2,
                svgHeight - totalVerticalPadding * 2 - topOffset
            );
            const radius = availableSize / 2.8;

            const centerX = svgWidth / 2;
            const totalValue = dataItems.reduce((sum, item) => sum + item.value, 0);

            // Center the entire pie chart (title + chart) vertically in canvas
            let titleYPosition, centerY;
            if (chartTitle) {
                // Calculate total height needed: title + gap + pie diameter
                const totalContentHeight = titleFontSize + 80 + (radius * 2);
                // Center this content block vertically
                const contentStartY = (svgHeight - totalContentHeight) / 2;
                titleYPosition = contentStartY + titleFontSize;
                centerY = titleYPosition + 80 + radius;
            } else {
                // No title - just center the pie
                centerY = svgHeight / 2;
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', titleYPosition);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            let currentAngle = -Math.PI / 2;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);

            dataItems.forEach((item, index) => {
                const sliceAngle = (item.value / totalValue) * 2 * Math.PI;
                const startAngle = currentAngle;
                const endAngle = currentAngle + sliceAngle;
                currentAngle = endAngle;

                // Draw white background arc first
                const whiteArc = rc.arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, true, {
                    fill: '#ffffff',
                    fillStyle: 'solid',
                    roughness: roughness,
                    strokeWidth: 0,
                    stroke: 'transparent'
                });
                svg.appendChild(whiteArc);

                // Draw pie slice
                const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);
                const arc = rc.arc(centerX, centerY, radius * 2, radius * 2, startAngle, endAngle, true, {
                    fill: item.color,
                    fillStyle: item.pattern,
                    roughness: roughness,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                svg.appendChild(arc);

                // Draw label
                const midAngle = (startAngle + endAngle) / 2;
                const labelRadius = radius * 0.7;
                const labelX = centerX + Math.cos(midAngle) * labelRadius;
                const labelY = centerY + Math.sin(midAngle) * labelRadius;
                const percentage = ((item.value / totalValue) * 100).toFixed(1);

                // Add white background for label
                const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const labelText = `${item.label}\n${percentage}%`;
                const bgWidth = labelText.length * pieDataLabelFontSize * 0.6;
                const bgHeight = pieDataLabelFontSize * 1.4;
                labelBg.setAttribute('x', labelX - bgWidth / 2);
                labelBg.setAttribute('y', labelY - bgHeight / 2);
                labelBg.setAttribute('width', bgWidth);
                labelBg.setAttribute('height', bgHeight);
                labelBg.setAttribute('fill', 'white');
                labelBg.setAttribute('rx', '8');
                svg.appendChild(labelBg);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', labelX);
                label.setAttribute('y', labelY);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('class', 'bar-label');
                label.style.fontSize = pieDataLabelFontSize + 'px';
                label.style.fontWeight = '700';
                label.textContent = labelText;
                svg.appendChild(label);
            });
        }

        function updateLineChart(svg) {
            // Get dimensions from viewBox if available, otherwise use defaults
            const viewBox = svg.getAttribute('viewBox');
            let svgWidth, svgHeight;
            if (viewBox) {
                const dims = viewBox.split(' ');
                svgWidth = parseFloat(dims[2]);
                svgHeight = parseFloat(dims[3]);
            } else {
                svgWidth = svg.clientWidth || 900;
                svgHeight = svg.clientHeight || 550;
            }
            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            // Scale fonts to keep visual size consistent across aspect ratios (matching animation)
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            // Get padding from chart size settings (matching animation)
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();
            const minPadding = { horizontal: 60, vertical: 40 };

            // Calculate padding - minimum needed for axis/labels + chart size setting
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60;
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const maxValue = Math.max(...dataItems.map(item => item.value));
            const pointCount = dataItems.length;

            // Calculate spacing to fit in available width
            const pointOffset = 80; // Initial offset from y-axis for first point
            const availableWidth = svgWidth - leftPadding - rightPadding - pointOffset;
            const pointSpacing = availableWidth / Math.max(1, pointCount - 1);
            const xAxisEnd = leftPadding + pointOffset + ((pointCount - 1) * pointSpacing) + 20; // Extend x-axis to last point + margin
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize; // Use same font size as axis
            const yAxisExtension = dataLabelFontSize + 20; // Extra space for data labels above points

            const axisY = rc.line(
                leftPadding,
                topPadding - yAxisExtension,
                leftPadding,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisY);

            const axisX = rc.line(
                leftPadding,
                svgHeight - bottomPadding,
                xAxisEnd,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const xAxisCenter = (leftPadding + xAxisEnd) / 2;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xAxisCenter);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const datapointShape = document.getElementById('datapointShape').value;
            const points = [];

            // Draw line connecting points
            dataItems.forEach((item, index) => {
                const x = leftPadding + pointOffset + (index * pointSpacing);
                const y = svgHeight - bottomPadding - ((item.value / maxValue) * chartHeight);
                points.push({ x, y, item, index });
            });

            // Draw the line
            if (points.length > 1) {
                for (let i = 0; i < points.length - 1; i++) {
                    const line = rc.line(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, {
                        roughness: roughness,
                        strokeWidth: 3,
                        stroke: '#333'
                    });
                    svg.appendChild(line);
                }
            }

            // Draw data points
            points.forEach(({ x, y, item, index }) => {
                // Draw the shape
                const shapeSize = 15;
                let whiteShape, shape;

                // Draw white background first
                if (datapointShape === 'circle') {
                    whiteShape = rc.circle(x, y, shapeSize * 2, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    svg.appendChild(whiteShape);

                    shape = rc.circle(x, y, shapeSize * 2, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                } else if (datapointShape === 'square') {
                    whiteShape = rc.rectangle(x - shapeSize, y - shapeSize, shapeSize * 2, shapeSize * 2, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    svg.appendChild(whiteShape);

                    shape = rc.rectangle(x - shapeSize, y - shapeSize, shapeSize * 2, shapeSize * 2, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                } else if (datapointShape === 'diamond') {
                    const points = [
                        [x, y - shapeSize],
                        [x + shapeSize, y],
                        [x, y + shapeSize],
                        [x - shapeSize, y]
                    ];
                    whiteShape = rc.polygon(points, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    svg.appendChild(whiteShape);

                    shape = rc.polygon(points, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                } else { // triangle
                    const points = [
                        [x, y - shapeSize],
                        [x + shapeSize, y + shapeSize],
                        [x - shapeSize, y + shapeSize]
                    ];
                    whiteShape = rc.polygon(points, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    svg.appendChild(whiteShape);

                    shape = rc.polygon(points, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                }
                svg.appendChild(shape);

                // Draw label below point
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', svgHeight - bottomPadding + 50);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'bar-label');
                label.style.fontSize = axisFontSize + 'px';
                label.style.fontWeight = '600';
                label.textContent = item.label;
                svg.appendChild(label);

                // Draw value above point
                const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                valueLabel.setAttribute('x', x);
                valueLabel.setAttribute('y', y - 20);
                valueLabel.setAttribute('text-anchor', 'middle');
                valueLabel.setAttribute('class', 'bar-label');
                valueLabel.style.fontSize = dataLabelFontSize + 'px';
                valueLabel.style.fontWeight = '600';
                valueLabel.textContent = item.value;
                svg.appendChild(valueLabel);
            });
        }

        function updateAreaChart(svg) {
            // Get dimensions from viewBox if available, otherwise use defaults
            const viewBox = svg.getAttribute('viewBox');
            let svgWidth, svgHeight;
            if (viewBox) {
                const dims = viewBox.split(' ');
                svgWidth = parseFloat(dims[2]);
                svgHeight = parseFloat(dims[3]);
            } else {
                svgWidth = svg.clientWidth || 900;
                svgHeight = svg.clientHeight || 550;
            }
            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();
            const minPadding = { horizontal: 60, vertical: 40 };

            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60;
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const maxValue = Math.max(...dataItems.map(item => item.value));
            const pointCount = dataItems.length;

            const pointOffset = 80;
            const availableWidth = svgWidth - leftPadding - rightPadding - pointOffset;
            const pointSpacing = availableWidth / Math.max(1, pointCount - 1);
            const xAxisEnd = leftPadding + pointOffset + ((pointCount - 1) * pointSpacing) + 20;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize;
            const yAxisExtension = dataLabelFontSize + 20;

            const axisY = rc.line(
                leftPadding,
                topPadding - yAxisExtension,
                leftPadding,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisY);

            const axisX = rc.line(
                leftPadding,
                svgHeight - bottomPadding,
                xAxisEnd,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const xAxisCenter = (leftPadding + xAxisEnd) / 2;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xAxisCenter);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const datapointShape = document.getElementById('datapointShape').value;
            const points = [];

            // Calculate points
            dataItems.forEach((item, index) => {
                const x = leftPadding + pointOffset + (index * pointSpacing);
                const y = svgHeight - bottomPadding - ((item.value / maxValue) * chartHeight);
                points.push({ x, y, item, index });
            });

            // Draw filled area under the line
            if (points.length > 0) {
                // Build polygon path for the area
                const areaPoints = [];
                // Start from bottom-left
                areaPoints.push([points[0].x, svgHeight - bottomPadding]);
                // Add all data points
                points.forEach(p => areaPoints.push([p.x, p.y]));
                // End at bottom-right
                areaPoints.push([points[points.length - 1].x, svgHeight - bottomPadding]);

                // Use the first item's color and pattern for the area
                const firstItem = dataItems[0];
                const hachureGap = firstItem.pattern === 'dots' ? 24 : (firstItem.pattern === 'solid' ? 1 : 12);

                const area = rc.polygon(areaPoints, {
                    fill: firstItem.color,
                    fillStyle: firstItem.pattern,
                    roughness: roughness,
                    strokeWidth: 0,
                    fillWeight: 1.5,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                svg.appendChild(area);
            }

            // Draw the line on top of area
            if (points.length > 1) {
                for (let i = 0; i < points.length - 1; i++) {
                    const line = rc.line(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, {
                        roughness: roughness,
                        strokeWidth: 3,
                        stroke: '#333'
                    });
                    svg.appendChild(line);
                }
            }

            // Draw data points
            points.forEach(({ x, y, item, index }) => {
                const shapeSize = 15;
                let shape;
                if (datapointShape === 'circle') {
                    shape = rc.circle(x, y, shapeSize * 2, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                } else if (datapointShape === 'square') {
                    shape = rc.rectangle(x - shapeSize, y - shapeSize, shapeSize * 2, shapeSize * 2, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                } else if (datapointShape === 'diamond') {
                    const diamondPoints = [
                        [x, y - shapeSize],
                        [x + shapeSize, y],
                        [x, y + shapeSize],
                        [x - shapeSize, y]
                    ];
                    shape = rc.polygon(diamondPoints, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                } else {
                    const trianglePoints = [
                        [x, y - shapeSize],
                        [x + shapeSize, y + shapeSize],
                        [x - shapeSize, y + shapeSize]
                    ];
                    shape = rc.polygon(trianglePoints, {
                        fill: item.color,
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333'
                    });
                }
                svg.appendChild(shape);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', svgHeight - bottomPadding + 50);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'bar-label');
                label.style.fontSize = axisFontSize + 'px';
                label.style.fontWeight = '600';
                label.textContent = item.label;
                svg.appendChild(label);

                const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                valueLabel.setAttribute('x', x);
                valueLabel.setAttribute('y', y - 20);
                valueLabel.setAttribute('text-anchor', 'middle');
                valueLabel.setAttribute('class', 'bar-label');
                valueLabel.style.fontSize = dataLabelFontSize + 'px';
                valueLabel.style.fontWeight = '600';
                valueLabel.textContent = item.value;
                svg.appendChild(valueLabel);
            });
        }

        function updateScatterChart(svg) {
            // Get dimensions from viewBox if available, otherwise use defaults
            const viewBox = svg.getAttribute('viewBox');
            let svgWidth, svgHeight;
            if (viewBox) {
                const dims = viewBox.split(' ');
                svgWidth = parseFloat(dims[2]);
                svgHeight = parseFloat(dims[3]);
            } else {
                svgWidth = svg.clientWidth || 900;
                svgHeight = svg.clientHeight || 550;
            }
            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();
            const minPadding = { horizontal: 60, vertical: 40 };

            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60;
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const chartWidth = svgWidth - leftPadding - rightPadding;

            // For scatter plots, use X and Y values
            const maxX = Math.max(...dataItems.map(item => item.x || 0));
            const maxY = Math.max(...dataItems.map(item => item.y || 0));
            const minX = Math.min(...dataItems.map(item => item.x || 0), 0);
            const minY = Math.min(...dataItems.map(item => item.y || 0), 0);

            const xAxisEnd = svgWidth - rightPadding;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize;
            const yAxisExtension = dataLabelFontSize + 20;

            const axisY = rc.line(
                leftPadding,
                topPadding - yAxisExtension,
                leftPadding,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisY);

            const axisX = rc.line(
                leftPadding,
                svgHeight - bottomPadding,
                xAxisEnd,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const xAxisCenter = (leftPadding + xAxisEnd) / 2;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xAxisCenter);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            // Calculate points based on X/Y values
            dataItems.forEach((item, index) => {
                const x = leftPadding + ((item.x - minX) / (maxX - minX || 1)) * chartWidth;
                const y = svgHeight - bottomPadding - ((item.y - minY) / (maxY - minY || 1)) * chartHeight;

                const shapeSize = 20; // Slightly larger for scatter plots
                const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);

                // Draw white background circle first
                const whiteCircle = rc.circle(x, y, shapeSize * 2, {
                    fill: '#ffffff',
                    fillStyle: 'solid',
                    roughness: roughness,
                    strokeWidth: 0,
                    stroke: 'transparent'
                });
                svg.appendChild(whiteCircle);

                let shape = rc.circle(x, y, shapeSize * 2, {
                    fill: item.color,
                    fillStyle: item.pattern,
                    roughness: roughness,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                svg.appendChild(shape);

                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', x);
                label.setAttribute('y', y - 30);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'bar-label');
                label.style.fontSize = axisFontSize + 'px';
                label.style.fontWeight = '600';
                label.textContent = item.label;
                svg.appendChild(label);
            });
        }

        function updateHorizontalBarChart(svg) {
            // Get dimensions from viewBox if available, otherwise use defaults
            const viewBox = svg.getAttribute('viewBox');
            let svgWidth, svgHeight;
            if (viewBox) {
                const dims = viewBox.split(' ');
                svgWidth = parseFloat(dims[2]);
                svgHeight = parseFloat(dims[3]);
            } else {
                svgWidth = svg.clientWidth || 900;
                svgHeight = svg.clientHeight || 550;
            }
            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();
            const minPadding = { horizontal: 60, vertical: 40 };

            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + 60;
            const leftPadding = minPadding.horizontal + padding.horizontal + 150; // More space for labels
            const rightPadding = minPadding.horizontal + padding.horizontal + (axisFontSize + 100);

            const chartWidth = svgWidth - leftPadding - rightPadding;
            const chartHeight = svgHeight - topPadding - bottomPadding;
            const maxValue = Math.max(...dataItems.map(item => item.value));
            const barCount = dataItems.length;

            const availableHeight = chartHeight;
            const spacingRatio = currentAspectRatio === '16:9' ? 0.2 : 0.3;
            const totalSpacingHeight = availableHeight * spacingRatio;
            const barSpacing = totalSpacingHeight / (barCount + 1);
            const barHeight = (availableHeight - totalSpacingHeight) / barCount;

            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize;
            const xAxisExtension = dataLabelFontSize + 20;

            // Draw Y-axis (vertical, on left)
            const axisY = rc.line(
                leftPadding,
                topPadding,
                leftPadding,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisY);

            // Draw X-axis (horizontal, at bottom)
            const xAxisEnd = svgWidth - rightPadding + xAxisExtension;
            const axisX = rc.line(
                leftPadding,
                svgHeight - bottomPadding,
                xAxisEnd,
                svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' }
            );
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', (leftPadding + xAxisEnd) / 2);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 80);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 100);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            // Draw horizontal bars
            dataItems.forEach((item, index) => {
                const barY = topPadding + barSpacing * (index + 1) + barHeight * index;
                const barWidth = (item.value / maxValue) * chartWidth;
                const barX = leftPadding;

                // Draw white background first
                const whiteBackground = rc.rectangle(barX, barY, barWidth, barHeight, {
                    fill: '#ffffff',
                    fillStyle: 'solid',
                    roughness: roughness,
                    strokeWidth: 0,
                    stroke: 'transparent'
                });
                svg.appendChild(whiteBackground);

                const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);
                const rect = rc.rectangle(barX, barY, barWidth, barHeight, {
                    fill: item.color,
                    fillStyle: item.pattern,
                    roughness: roughness,
                    strokeWidth: 2,
                    stroke: '#333',
                    fillWeight: 2,
                    hachureAngle: 60,
                    hachureGap: hachureGap
                });
                svg.appendChild(rect);

                // Draw bar label (on the left)
                const barLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                barLabel.setAttribute('x', leftPadding - 15);
                barLabel.setAttribute('y', barY + barHeight / 2);
                barLabel.setAttribute('text-anchor', 'end');
                barLabel.setAttribute('dominant-baseline', 'middle');
                barLabel.setAttribute('class', 'bar-label');
                barLabel.style.fontSize = axisFontSize + 'px';
                barLabel.style.fontWeight = '600';
                barLabel.textContent = item.label;
                svg.appendChild(barLabel);

                // Draw data value label at end of bar
                const dataLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                dataLabel.setAttribute('x', barX + barWidth + 15);
                dataLabel.setAttribute('y', barY + barHeight / 2);
                dataLabel.setAttribute('text-anchor', 'start');
                dataLabel.setAttribute('dominant-baseline', 'middle');
                dataLabel.setAttribute('class', 'bar-label');
                dataLabel.style.fontSize = dataLabelFontSize + 'px';
                dataLabel.style.fontWeight = '600';
                dataLabel.textContent = item.value;
                svg.appendChild(dataLabel);
            });
        }

        let currentHue = 0;
        let currentSaturation = 100;
        let currentLightness = 50;

        function openEditPopup(event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            const popup = document.getElementById('editPopup');
            const currentColor = document.getElementById('colorInput').value;
            const currentPattern = document.getElementById('patternInput').value;

            const hsl = hexToHsl(currentColor);
            currentHue = hsl.h;
            currentSaturation = hsl.s;
            currentLightness = hsl.l;

            document.getElementById('hexInput').value = currentColor.toUpperCase();
            document.getElementById('colorDisplaySmall').style.backgroundColor = currentColor;

            document.querySelectorAll('.edit-popup-pattern').forEach(p => {
                p.classList.remove('selected');
                if (p.dataset.pattern === currentPattern) {
                    p.classList.add('selected');
                }
            });

            modalSelectedPattern = currentPattern;
            popup.classList.add('active');

            // Update pattern previews with current color
            updatePopupPatternPreviews(currentColor);

            setTimeout(() => {
                const rect = document.getElementById('colorPatternPreview').getBoundingClientRect();
                popup.style.left = rect.left + 'px';
                popup.style.top = (rect.bottom + 5) + 'px';
            }, 0);

            if (!popup.dataset.initialized) {
                initializeColorPicker();
                popup.dataset.initialized = 'true';
            } else {
                drawColorPicker();
            }
        }

        function closeEditPopup() {
            document.getElementById('editPopup').classList.remove('active');
            editingDataIndex = -1;
        }

        function openAreaColorPopup(event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            const popup = document.getElementById('editPopup');
            editingDataIndex = -1; // Not editing a specific item, but all area items

            const currentColor = document.getElementById('colorInput').value;
            const currentPattern = document.getElementById('patternInput').value;

            document.getElementById('hexInput').value = currentColor.toUpperCase();
            document.getElementById('colorDisplaySmall').style.backgroundColor = currentColor;

            document.querySelectorAll('.edit-popup-pattern').forEach(p => {
                p.classList.remove('selected');
                if (p.dataset.pattern === currentPattern) {
                    p.classList.add('selected');
                }
            });

            modalSelectedPattern = currentPattern;
            popup.classList.add('active');

            updatePopupPatternPreviews(currentColor);

            setTimeout(() => {
                const rect = document.getElementById('areaColorPatternPreview').getBoundingClientRect();
                popup.style.left = rect.left + 'px';
                popup.style.top = (rect.bottom + 5) + 'px';
            }, 0);

            if (!popup.dataset.initialized) {
                initializeColorPicker();
                popup.dataset.initialized = 'true';
            } else {
                drawColorPicker();
            }

            // When closing, update all area items
            const originalClose = closeEditPopup;
            closeEditPopup = function() {
                const newColor = document.getElementById('colorInput').value;
                const newPattern = document.getElementById('patternInput').value;
                if (currentChartType === 'area') {
                    dataItems.forEach(item => {
                        item.color = newColor;
                        item.pattern = newPattern;
                    });
                    updateAreaPatternPreview();
                    updateDataList();
                    updatePreview();
                }
                originalClose();
                closeEditPopup = originalClose;
            };
        }

        function updateAreaPatternPreview() {
            const svg = document.getElementById('areaPatternPreview');
            if (!svg) return;

            const color = document.getElementById('colorInput').value;
            const pattern = document.getElementById('patternInput').value;

            svg.innerHTML = '';
            svg.setAttribute('width', '60');
            svg.setAttribute('height', '44');
            svg.setAttribute('viewBox', '0 0 60 44');

            const tempRc = rough.svg(svg);
            const hachureGap = pattern === 'dots' ? 12 : (pattern === 'solid' ? 1 : 6);

            // Draw rectangle with border and fill (matching the style of other previews)
            const rect = tempRc.rectangle(3, 3, 54, 38, {
                fill: color,
                fillStyle: pattern,
                roughness: 2,
                strokeWidth: 2,
                stroke: '#333',
                fillWeight: 2,
                hachureAngle: 60,
                hachureGap: hachureGap
            });
            svg.appendChild(rect);
        }

        function selectPopupPattern(patternName, element) {
            document.querySelectorAll('.edit-popup-pattern').forEach(p => {
                p.classList.remove('selected');
            });
            element.classList.add('selected');
            modalSelectedPattern = patternName;
            document.getElementById('patternInput').value = patternName;

            if (editingDataIndex >= 0) {
                // For area charts, sync pattern across all data items
                if (currentChartType === 'area') {
                    dataItems.forEach(item => item.pattern = patternName);
                } else {
                    dataItems[editingDataIndex].pattern = patternName;
                }
                updateDataList();
                updatePreview(); // Pattern change doesn't need re-animation
            } else {
                updateCurrentPatternPreview();
                // If editing area chart from main preview, update immediately
                if (currentChartType === 'area') {
                    dataItems.forEach(item => item.pattern = patternName);
                    updateAreaPatternPreview();
                    updateDataList();
                    updatePreview();
                }
            }
        }

        function hslToHex(h, s, l) {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`.toUpperCase();
        }

        function hexToHsl(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!result) return { h: 0, s: 0, l: 0 };

            let r = parseInt(result[1], 16) / 255;
            let g = parseInt(result[2], 16) / 255;
            let b = parseInt(result[3], 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return {
                h: Math.round(h * 360),
                s: Math.round(s * 100),
                l: Math.round(l * 100)
            };
        }

        function drawColorPicker() {
            const canvas = document.getElementById('colorCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            for (let row = 0; row < height; row++) {
                const lightness = (1 - row / height) * 100;
                for (let col = 0; col < width; col++) {
                    const saturation = (col / width) * 100;
                    ctx.fillStyle = `hsl(${currentHue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(col, row, 1, 1);
                }
            }
        }

        function drawHueSlider() {
            const canvas = document.getElementById('hueSlider');
            const ctx = canvas.getContext('2d');
            const height = canvas.height;

            for (let i = 0; i < height; i++) {
                const hue = (i / height) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(0, i, 20, 1);
            }
        }

        function initializeColorPicker() {
            drawHueSlider();
            drawColorPicker();

            const colorCanvas = document.getElementById('colorCanvas');
            colorCanvas.addEventListener('click', function(e) {
                const rect = colorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                currentSaturation = (x / colorCanvas.width) * 100;
                currentLightness = (1 - y / colorCanvas.height) * 100;

                const hex = hslToHex(currentHue, currentSaturation, currentLightness);
                document.getElementById('hexInput').value = hex;
                document.getElementById('colorDisplaySmall').style.backgroundColor = hex;
                document.getElementById('colorInput').value = hex;
                updatePopupPatternPreviews(hex);

                if (editingDataIndex >= 0) {
                    // For area charts, sync color across all data items
                    if (currentChartType === 'area') {
                        dataItems.forEach(item => item.color = hex);
                    } else {
                        dataItems[editingDataIndex].color = hex;
                    }
                    updateDataList();
                    updatePreview(); // Color change doesn't need re-animation
                } else {
                    updateCurrentPatternPreview();
                    // If editing area chart from main preview, update immediately
                    if (currentChartType === 'area') {
                        dataItems.forEach(item => item.color = hex);
                        updateAreaPatternPreview();
                        updateDataList();
                        updatePreview();
                    }
                }
            });

            const hueSlider = document.getElementById('hueSlider');
            hueSlider.addEventListener('click', function(e) {
                const rect = hueSlider.getBoundingClientRect();
                const y = e.clientY - rect.top;

                currentHue = (y / hueSlider.height) * 360;
                drawColorPicker();

                const hex = hslToHex(currentHue, currentSaturation, currentLightness);
                document.getElementById('hexInput').value = hex;
                document.getElementById('colorDisplaySmall').style.backgroundColor = hex;
                document.getElementById('colorInput').value = hex;
                updatePopupPatternPreviews(hex);

                if (editingDataIndex >= 0) {
                    // For area charts, sync color across all data items
                    if (currentChartType === 'area') {
                        dataItems.forEach(item => item.color = hex);
                    } else {
                        dataItems[editingDataIndex].color = hex;
                    }
                    updateDataList();
                    updatePreview(); // Color change doesn't need re-animation
                } else {
                    updateCurrentPatternPreview();
                    // If editing area chart from main preview, update immediately
                    if (currentChartType === 'area') {
                        dataItems.forEach(item => item.color = hex);
                        updateAreaPatternPreview();
                        updateDataList();
                        updatePreview();
                    }
                }
            });
        }

        function updateColorFromHex() {
            let hex = document.getElementById('hexInput').value;
            if (!hex.startsWith('#')) hex = '#' + hex;

            if (/^#[0-9A-F]{6}$/i.test(hex)) {
                const hsl = hexToHsl(hex);
                currentHue = hsl.h;
                currentSaturation = hsl.s;
                currentLightness = hsl.l;

                document.getElementById('colorDisplaySmall').style.backgroundColor = hex;
                document.getElementById('colorInput').value = hex;
                drawColorPicker();
                updateCurrentPatternPreview();
                updatePopupPatternPreviews(hex);

                // For area charts, sync color across all data items when editing
                if (editingDataIndex >= 0 && currentChartType === 'area') {
                    dataItems.forEach(item => item.color = hex);
                    updateDataList();
                    updatePreview();
                } else if (editingDataIndex >= 0) {
                    dataItems[editingDataIndex].color = hex;
                    updateDataList();
                    updatePreview();
                } else if (currentChartType === 'area') {
                    // If editing area chart from main preview, update immediately
                    dataItems.forEach(item => item.color = hex);
                    updateAreaPatternPreview();
                    updateDataList();
                    updatePreview();
                }
            }
        }

        let bgCurrentHue = 0;
        let bgCurrentSaturation = 0;
        let bgCurrentLightness = 100;

        function openBgColorPicker() {
            const popup = document.getElementById('bgColorPickerPopup');
            const bgColorDisplay = document.getElementById('bgColorDisplay');
            const currentBgColor = document.getElementById('bgColor').value;

            const hsl = hexToHsl(currentBgColor);
            bgCurrentHue = hsl.h;
            bgCurrentSaturation = hsl.s;
            bgCurrentLightness = hsl.l;

            document.getElementById('bgHexInput').value = currentBgColor.toUpperCase();
            document.getElementById('bgColorDisplaySmall').style.backgroundColor = currentBgColor;

            // Update pattern selection visual state
            const currentPattern = document.getElementById('bgPattern').value;
            document.querySelectorAll('.bg-pattern-option').forEach(opt => {
                const optPattern = opt.getAttribute('data-pattern');
                if (optPattern === currentPattern) {
                    opt.style.borderColor = '#6366f1';
                    opt.style.transform = 'scale(1.05)';
                } else {
                    opt.style.borderColor = '#e0e7ff';
                    opt.style.transform = 'scale(1)';
                }
            });

            popup.classList.add('active');

            setTimeout(() => {
                const rect = bgColorDisplay.getBoundingClientRect();
                const popupHeight = 600; // Estimated max height
                const viewportHeight = window.innerHeight;

                // Position below if there's space, otherwise position above
                let top = rect.bottom + 5;
                if (top + popupHeight > viewportHeight) {
                    top = Math.max(10, rect.top - popupHeight - 5);
                }

                // Ensure it doesn't go off the right edge
                let left = rect.left;
                const popupWidth = 400;
                if (left + popupWidth > window.innerWidth) {
                    left = window.innerWidth - popupWidth - 10;
                }

                popup.style.left = left + 'px';
                popup.style.top = top + 'px';
            }, 0);

            if (!popup.dataset.initialized) {
                initializeBgColorPicker();
                popup.dataset.initialized = 'true';
            } else {
                drawBgColorPicker();
            }
        }

        function closeBgColorPicker() {
            document.getElementById('bgColorPickerPopup').classList.remove('active');
        }

        function updateBgColorFromHex() {
            let hex = document.getElementById('bgHexInput').value;
            if (!hex.startsWith('#')) hex = '#' + hex;

            if (/^#[0-9A-F]{6}$/i.test(hex)) {
                const hsl = hexToHsl(hex);
                bgCurrentHue = hsl.h;
                bgCurrentSaturation = hsl.s;
                bgCurrentLightness = hsl.l;

                document.getElementById('bgColorDisplaySmall').style.backgroundColor = hex;
                drawBgColorPicker();

                document.getElementById('bgColor').value = hex;
                document.getElementById('bgColorDisplay').style.backgroundColor = hex;
                updateChartBackground();
            }
        }

        function drawBgColorPicker() {
            const canvas = document.getElementById('bgColorCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            for (let row = 0; row < height; row++) {
                const lightness = (1 - row / height) * 100;
                for (let col = 0; col < width; col++) {
                    const saturation = (col / width) * 100;
                    ctx.fillStyle = `hsl(${bgCurrentHue}, ${saturation}%, ${lightness}%)`;
                    ctx.fillRect(col, row, 1, 1);
                }
            }
        }

        function drawBgHueSlider() {
            const canvas = document.getElementById('bgHueSlider');
            const ctx = canvas.getContext('2d');
            const height = canvas.height;

            for (let i = 0; i < height; i++) {
                const hue = (i / height) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(0, i, 20, 1);
            }
        }

        function initializeBgColorPicker() {
            drawBgHueSlider();
            drawBgColorPicker();

            const colorCanvas = document.getElementById('bgColorCanvas');
            colorCanvas.addEventListener('click', function(e) {
                const rect = colorCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                bgCurrentSaturation = (x / colorCanvas.width) * 100;
                bgCurrentLightness = (1 - y / colorCanvas.height) * 100;

                const hex = hslToHex(bgCurrentHue, bgCurrentSaturation, bgCurrentLightness);
                document.getElementById('bgHexInput').value = hex;
                document.getElementById('bgColorDisplaySmall').style.backgroundColor = hex;

                document.getElementById('bgColor').value = hex;
                document.getElementById('bgColorDisplay').style.backgroundColor = hex;
                updateChartBackground();
            });

            const hueSlider = document.getElementById('bgHueSlider');
            hueSlider.addEventListener('click', function(e) {
                const rect = hueSlider.getBoundingClientRect();
                const y = e.clientY - rect.top;

                bgCurrentHue = (y / hueSlider.height) * 360;
                drawBgColorPicker();

                const hex = hslToHex(bgCurrentHue, bgCurrentSaturation, bgCurrentLightness);
                document.getElementById('bgHexInput').value = hex;
                document.getElementById('bgColorDisplaySmall').style.backgroundColor = hex;

                document.getElementById('bgColor').value = hex;
                document.getElementById('bgColorDisplay').style.backgroundColor = hex;
                updateChartBackground();
            });
        }

        document.addEventListener('click', function(e) {
            const popup = document.getElementById('editPopup');
            const isClickInside = popup.contains(e.target);
            const isPreviewClick = e.target.id === 'colorPatternPreview' || e.target.closest('#colorPatternPreview');
            const isTablePreviewClick = e.target.closest('td[onclick*="editDataColor"]');

            if (!isClickInside && !isPreviewClick && !isTablePreviewClick && popup.classList.contains('active')) {
                closeEditPopup();
            }

            const bgPopup = document.getElementById('bgColorPickerPopup');
            const isBgClickInside = bgPopup.contains(e.target);
            const isBgDisplayClick = e.target.id === 'bgColorDisplay' || e.target.closest('#bgColorDisplay');

            if (!isBgClickInside && !isBgDisplayClick && bgPopup.classList.contains('active')) {
                closeBgColorPicker();
            }
        });

        let isCreatingGif = false;

        function getCanvasDimensions() {
            // Calculate canvas dimensions based on aspect ratio
            const baseWidth = currentAspectRatio === '16:9' ? 1920 : 1080;
            const baseHeight = currentAspectRatio === '16:9' ? 1080 : 1920;

            return {
                width: baseWidth,
                height: baseHeight,
                // Calculate padding based on chart type
                // For pie chart: use chartSizePercent for both dimensions
                // For bar and line charts: use chartWidthPercent and chartHeightPercent separately
                getPadding: function() {
                    let horizontalPaddingPercent, verticalPaddingPercent;

                    if (currentChartType === 'pie') {
                        // Pie chart uses same percentage for both dimensions
                        const paddingPercent = (100 - chartSizePercent) / 2;
                        horizontalPaddingPercent = paddingPercent;
                        verticalPaddingPercent = paddingPercent;
                    } else {
                        // Bar and Line charts use separate percentages
                        horizontalPaddingPercent = (100 - chartWidthPercent) / 2;
                        verticalPaddingPercent = (100 - chartHeightPercent) / 2;
                    }

                    return {
                        horizontal: (this.width * horizontalPaddingPercent) / 100,
                        vertical: (this.height * verticalPaddingPercent) / 100
                    };
                }
            };
        }

        function animateChart() {
            if (dataItems.length === 0) return;

            const svg = document.getElementById('chartSvg');
            const emptyState = document.getElementById('emptyState');

            // Show SVG and hide empty state when animation starts
            svg.style.display = 'block';
            emptyState.style.display = 'none';

            // Disable download button until animation completes
            const downloadBtn = document.getElementById('downloadGifBtn');
            if (downloadBtn) downloadBtn.disabled = true;

            svg.innerHTML = '';

            if (currentChartType === 'bar') {
                animateBarChart();
            } else if (currentChartType === 'pie') {
                animatePieChart();
            } else if (currentChartType === 'line') {
                animateLineChart();
            } else if (currentChartType === 'area') {
                animateAreaChart();
            } else if (currentChartType === 'scatter') {
                animateScatterChart();
            } else if (currentChartType === 'hbar') {
                animateHorizontalBarChart();
            }
        }

        function animateBarChart() {
            const svg = document.getElementById('chartSvg');
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();

            // Set SVG to canvas dimensions
            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            // Scale fonts to keep visual size consistent across aspect ratios
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            // Calculate padding - minimum needed for axis/labels + chart size setting
            const minPadding = { horizontal: 60, vertical: 40 };
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60; // Extra for Y-axis labels
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const maxValue = Math.max(...dataItems.map(item => item.value));
            const barCount = dataItems.length;

            // Calculate bar sizing to center bars in available space
            const availableWidth = svgWidth - leftPadding - rightPadding;
            // Adjust spacing based on aspect ratio: horizontal needs less spacing
            const spacingRatio = currentAspectRatio === '16:9' ? 0.2 : 0.3;
            const totalSpacingWidth = availableWidth * spacingRatio;
            const barSpacing = totalSpacingWidth / (barCount + 1);
            const totalBarWidth = availableWidth - totalSpacingWidth;
            const barWidth = totalBarWidth / barCount;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const xAxisEnd = svgWidth - rightPadding;
            const duration = parseInt(document.getElementById('durationSlider').value);
            const sketchInterval = 80; // Fixed speed

            const axisY = rc.line(leftPadding, topPadding, leftPadding, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisY);

            const axisX = rc.line(leftPadding, svgHeight - bottomPadding, xAxisEnd, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const xAxisCenter = (leftPadding + xAxisEnd) / 2;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xAxisCenter);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const bars = dataItems.map((item, index) => {
                const barHeight = (item.value / maxValue) * chartHeight;
                const barX = leftPadding + barSpacing + (barWidth + barSpacing) * index;
                const barY = svgHeight - bottomPadding - barHeight;

                const barGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                svg.appendChild(barGroup);

                const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', barX + barWidth / 2);
                labelText.setAttribute('y', svgHeight - bottomPadding + 50);
                labelText.setAttribute('text-anchor', 'middle');
                labelText.setAttribute('class', 'bar-label');
                labelText.style.fontSize = axisFontSize + 'px';
                labelText.textContent = item.label;
                svg.appendChild(labelText);

                return { barGroup, barX, barY, barWidth, barHeight, item, index };
            });

            let startTime = null;
            let animationFrame;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                bars.forEach(({ barGroup, barX, barY, barWidth, barHeight, item, index }) => {
                    const currentHeight = barHeight * progress;
                    const currentY = svgHeight - bottomPadding - currentHeight;

                    barGroup.innerHTML = '';

                    // Draw white background first
                    const whiteBackground = rc.rectangle(barX, currentY, barWidth, currentHeight, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    barGroup.appendChild(whiteBackground);

                    const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);
                    const bar = rc.rectangle(barX, currentY, barWidth, currentHeight, {
                        fill: item.color,
                        fillStyle: item.pattern,
                        roughness: roughness,
                        strokeWidth: 2.5,
                        stroke: '#333',
                        fillWeight: 2,
                        hachureAngle: 60,
                        hachureGap: hachureGap
                    });
                    barGroup.appendChild(bar);

                    if (progress === 1) {
                        const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        valueText.setAttribute('x', barX + barWidth / 2);
                        valueText.setAttribute('y', currentY - 30);
                        valueText.setAttribute('text-anchor', 'middle');
                        valueText.setAttribute('class', 'bar-value');
                        valueText.style.fontSize = axisFontSize + 'px';
                        valueText.textContent = item.value;
                        barGroup.appendChild(valueText);
                    }
                });

                if (progress < 1) {
                    setTimeout(() => {
                        animationFrame = requestAnimationFrame(animate);
                    }, sketchInterval);
                } else {
                    // Animation complete - enable download button
                    const downloadBtn = document.getElementById('downloadGifBtn');
                    if (downloadBtn) downloadBtn.disabled = false;
                }
            }

            animationFrame = requestAnimationFrame(animate);
        }

        function animatePieChart() {
            const svg = document.getElementById('chartSvg');
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();

            // Set SVG to canvas dimensions
            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const basePieDataLabelFontSize = parseInt(document.getElementById('pieDataLabelFontSize').value) || 35;
            // Scale fonts to keep visual size consistent across aspect ratios
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const titleFontSize = baseTitleFontSize * fontScale;
            const pieDataLabelFontSize = basePieDataLabelFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            // Calculate padding for pie chart
            const minPadding = { horizontal: 60, vertical: 40 };
            const totalHorizontalPadding = minPadding.horizontal + padding.horizontal;
            const totalVerticalPadding = minPadding.vertical + padding.vertical;
            const topOffset = chartTitle ? titleFontSize + 20 : 0;

            // Calculate radius based on available space (chart size affects this)
            const availableSize = Math.min(
                svgWidth - totalHorizontalPadding * 2,
                svgHeight - totalVerticalPadding * 2 - topOffset
            );
            const radius = availableSize / 2.8; // Leave room for labels
            const labelRadius = radius + Math.min(pieDataLabelFontSize * 3, radius * 0.4); // Space for labels outside

            const centerX = svgWidth / 2;
            const totalValue = dataItems.reduce((sum, item) => sum + item.value, 0);
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const duration = parseInt(document.getElementById('durationSlider').value);
            const sketchInterval = 80; // Fixed speed

            // Center the entire pie chart (title + chart) vertically in canvas
            let titleYPosition, centerY;
            if (chartTitle) {
                // Calculate total height needed: title + gap + pie diameter
                const totalContentHeight = titleFontSize + 80 + (radius * 2);
                // Center this content block vertically
                const contentStartY = (svgHeight - totalContentHeight) / 2;
                titleYPosition = contentStartY + titleFontSize;
                centerY = titleYPosition + 80 + radius;
            } else {
                // No title - just center the pie
                centerY = svgHeight / 2;
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', titleYPosition);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            let currentAngle = -Math.PI / 2;
            const slices = dataItems.map((item, index) => {
                const sliceAngle = (item.value / totalValue) * 2 * Math.PI;
                const startAngle = currentAngle;
                const endAngle = currentAngle + sliceAngle;
                const sliceGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                svg.appendChild(sliceGroup);
                currentAngle = endAngle;
                return { sliceGroup, startAngle, endAngle, item, sliceAngle };
            });

            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                slices.forEach(({ sliceGroup, startAngle, endAngle, item, sliceAngle }) => {
                    sliceGroup.innerHTML = '';

                    const currentEndAngle = startAngle + (sliceAngle * progress);
                    if (currentEndAngle > startAngle) {
                        const x1 = centerX + radius * Math.cos(startAngle);
                        const y1 = centerY + radius * Math.sin(startAngle);
                        const x2 = centerX + radius * Math.cos(currentEndAngle);
                        const y2 = centerY + radius * Math.sin(currentEndAngle);
                        const largeArcFlag = (currentEndAngle - startAngle) > Math.PI ? 1 : 0;

                        const pathData = `M ${centerX} ${centerY} L ${x1} ${y1} A ${radius} ${radius} 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', pathData);

                        // Draw white background first
                        const whitePath = rc.path(pathData, {
                            fill: '#ffffff',
                            fillStyle: 'solid',
                            roughness: roughness,
                            strokeWidth: 0,
                            stroke: 'transparent'
                        });
                        sliceGroup.appendChild(whitePath);

                        const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);
                        const roughPath = rc.path(pathData, {
                            fill: item.color,
                            fillStyle: item.pattern,
                            roughness: roughness,
                            strokeWidth: 2.5,
                            stroke: '#333',
                            fillWeight: 2,
                            hachureAngle: 60,
                            hachureGap: hachureGap
                        });
                        sliceGroup.appendChild(roughPath);

                        if (progress === 1) {
                            const midAngle = (startAngle + endAngle) / 2;
                            const labelRadius = radius * 0.7; // Position labels inside the pie
                            const labelX = centerX + labelRadius * Math.cos(midAngle);
                            const labelY = centerY + labelRadius * Math.sin(midAngle);

                            const percentage = ((item.value / totalValue) * 100).toFixed(1);
                            const labelTextContent = `${item.label} (${percentage}%)`;

                            // Add white background for label
                            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            const bgWidth = labelTextContent.length * pieDataLabelFontSize * 0.6;
                            const bgHeight = pieDataLabelFontSize * 1.4;
                            labelBg.setAttribute('x', labelX - bgWidth / 2);
                            labelBg.setAttribute('y', labelY - bgHeight / 2);
                            labelBg.setAttribute('width', bgWidth);
                            labelBg.setAttribute('height', bgHeight);
                            labelBg.setAttribute('fill', 'white');
                            labelBg.setAttribute('rx', '8');
                            sliceGroup.appendChild(labelBg);

                            const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            labelText.setAttribute('x', labelX);
                            labelText.setAttribute('y', labelY);
                            labelText.setAttribute('text-anchor', 'middle');
                            labelText.setAttribute('dominant-baseline', 'middle');
                            labelText.setAttribute('class', 'bar-label');
                            labelText.style.fontSize = pieDataLabelFontSize + 'px';
                            labelText.style.fontWeight = '700';
                            labelText.textContent = labelTextContent;
                            sliceGroup.appendChild(labelText);
                        }
                    }
                });

                if (progress < 1) {
                    setTimeout(() => {
                        requestAnimationFrame(animate);
                    }, sketchInterval);
                } else {
                    // Animation complete - enable download button
                    const downloadBtn = document.getElementById('downloadGifBtn');
                    if (downloadBtn) downloadBtn.disabled = false;
                }
            }

            requestAnimationFrame(animate);
        }

        function animateLineChart() {
            const svg = document.getElementById('chartSvg');
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();

            // Set SVG to canvas dimensions
            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            // Scale fonts to keep visual size consistent across aspect ratios
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            // Calculate padding - minimum needed for axis/labels + chart size setting
            const minPadding = { horizontal: 60, vertical: 40 };
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60; // Extra for Y-axis labels
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const maxValue = Math.max(...dataItems.map(item => item.value));
            const pointCount = dataItems.length;

            // Calculate point spacing based on available space
            const pointOffset = 80; // Initial offset from y-axis for first point
            const availableWidth = svgWidth - leftPadding - rightPadding - pointOffset;
            const pointSpacing = pointCount > 1 ? availableWidth / (pointCount - 1) : availableWidth;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const xAxisEnd = leftPadding + pointOffset + ((pointCount - 1) * pointSpacing) + 20; // Extend x-axis to last point + margin
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const duration = parseInt(document.getElementById('durationSlider').value);
            const sketchInterval = 80; // Fixed speed
            const datapointShape = document.getElementById('datapointShape')?.value || 'circle';

            const axisY = rc.line(leftPadding, topPadding, leftPadding, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisY);

            const axisX = rc.line(leftPadding, svgHeight - bottomPadding, xAxisEnd, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;
            const xAxisCenter = (leftPadding + xAxisEnd) / 2;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', xAxisCenter);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const points = dataItems.map((item, index) => {
                const x = leftPadding + pointOffset + (index * pointSpacing);
                const y = svgHeight - bottomPadding - ((item.value / maxValue) * chartHeight);

                const labelText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                labelText.setAttribute('x', x);
                labelText.setAttribute('y', svgHeight - bottomPadding + 50);
                labelText.setAttribute('text-anchor', 'middle');
                labelText.setAttribute('class', 'bar-label');
                labelText.style.fontSize = axisFontSize + 'px';
                labelText.textContent = item.label;
                svg.appendChild(labelText);

                return { x, y, item, index };
            });

            const lineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(lineGroup);

            const pointGroups = points.map(() => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                svg.appendChild(g);
                return g;
            });

            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                lineGroup.innerHTML = '';
                pointGroups.forEach(g => g.innerHTML = '');

                const visiblePoints = Math.ceil(progress * points.length);

                for (let i = 0; i < visiblePoints - 1; i++) {
                    const line = rc.line(points[i].x, points[i].y, points[i + 1].x, points[i + 1].y, {
                        roughness: roughness,
                        strokeWidth: 3,
                        stroke: points[i].item.color
                    });
                    lineGroup.appendChild(line);
                }

                for (let i = 0; i < visiblePoints; i++) {
                    const hachureGap = points[i].item.pattern === 'dots' ? 24 : (points[i].item.pattern === 'solid' ? 1 : 12);
                    let whiteShape, shape;

                    if (datapointShape === 'circle') {
                        // Draw white background first
                        whiteShape = rc.circle(points[i].x, points[i].y, 16, {
                            fill: '#ffffff',
                            fillStyle: 'solid',
                            roughness: roughness,
                            strokeWidth: 0,
                            stroke: 'transparent'
                        });
                        pointGroups[i].appendChild(whiteShape);

                        shape = rc.circle(points[i].x, points[i].y, 16, {
                            fill: points[i].item.color,
                            fillStyle: points[i].item.pattern,
                            roughness: roughness,
                            strokeWidth: 2.5,
                            stroke: '#333',
                            fillWeight: 2,
                            hachureAngle: 60,
                            hachureGap: hachureGap
                        });
                    } else if (datapointShape === 'square') {
                        // Draw white background first
                        whiteShape = rc.rectangle(points[i].x - 8, points[i].y - 8, 16, 16, {
                            fill: '#ffffff',
                            fillStyle: 'solid',
                            roughness: roughness,
                            strokeWidth: 0,
                            stroke: 'transparent'
                        });
                        pointGroups[i].appendChild(whiteShape);

                        shape = rc.rectangle(points[i].x - 8, points[i].y - 8, 16, 16, {
                            fill: points[i].item.color,
                            fillStyle: points[i].item.pattern,
                            roughness: roughness,
                            strokeWidth: 2.5,
                            stroke: '#333',
                            fillWeight: 2,
                            hachureAngle: 60,
                            hachureGap: hachureGap
                        });
                    } else if (datapointShape === 'diamond') {
                        const path = `M ${points[i].x} ${points[i].y - 10} L ${points[i].x + 10} ${points[i].y} L ${points[i].x} ${points[i].y + 10} L ${points[i].x - 10} ${points[i].y} Z`;

                        // Draw white background first
                        whiteShape = rc.path(path, {
                            fill: '#ffffff',
                            fillStyle: 'solid',
                            roughness: roughness,
                            strokeWidth: 0,
                            stroke: 'transparent'
                        });
                        pointGroups[i].appendChild(whiteShape);

                        shape = rc.path(path, {
                            fill: points[i].item.color,
                            fillStyle: points[i].item.pattern,
                            roughness: roughness,
                            strokeWidth: 2.5,
                            stroke: '#333',
                            fillWeight: 2,
                            hachureAngle: 60,
                            hachureGap: hachureGap
                        });
                    } else if (datapointShape === 'triangle') {
                        const path = `M ${points[i].x} ${points[i].y - 10} L ${points[i].x + 10} ${points[i].y + 8} L ${points[i].x - 10} ${points[i].y + 8} Z`;

                        // Draw white background first
                        whiteShape = rc.path(path, {
                            fill: '#ffffff',
                            fillStyle: 'solid',
                            roughness: roughness,
                            strokeWidth: 0,
                            stroke: 'transparent'
                        });
                        pointGroups[i].appendChild(whiteShape);

                        shape = rc.path(path, {
                            fill: points[i].item.color,
                            fillStyle: points[i].item.pattern,
                            roughness: roughness,
                            strokeWidth: 2.5,
                            stroke: '#333',
                            fillWeight: 2,
                            hachureAngle: 60,
                            hachureGap: hachureGap
                        });
                    }

                    pointGroups[i].appendChild(shape);

                    if (progress === 1) {
                        const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        valueText.setAttribute('x', points[i].x);
                        valueText.setAttribute('y', points[i].y - 40);
                        valueText.setAttribute('text-anchor', 'middle');
                        valueText.setAttribute('class', 'bar-value');
                        valueText.style.fontSize = axisFontSize + 'px';
                        valueText.textContent = points[i].item.value;
                        pointGroups[i].appendChild(valueText);
                    }
                }

                if (progress < 1) {
                    setTimeout(() => {
                        requestAnimationFrame(animate);
                    }, sketchInterval);
                } else {
                    // Animation complete - enable download button
                    const downloadBtn = document.getElementById('downloadGifBtn');
                    if (downloadBtn) downloadBtn.disabled = false;
                }
            }

            requestAnimationFrame(animate);
        }

        function animateAreaChart() {
            // Area chart animation is similar to line chart but with filled area
            const svg = document.getElementById('chartSvg');
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();

            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            rc = rough.svg(svg);

            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            const minPadding = { horizontal: 60, vertical: 40 };
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60;
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const maxValue = Math.max(...dataItems.map(item => item.value));
            const pointCount = dataItems.length;
            const pointOffset = 80;
            const availableWidth = svgWidth - leftPadding - rightPadding - pointOffset;
            const pointSpacing = availableWidth / Math.max(1, pointCount - 1);
            const xAxisEnd = leftPadding + pointOffset + ((pointCount - 1) * pointSpacing) + 20;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize;
            const yAxisExtension = dataLabelFontSize + 20;
            const duration = parseInt(document.getElementById('durationSlider').value);
            const sketchInterval = 16;

            // Draw axes
            const axisY = rc.line(leftPadding, topPadding - yAxisExtension, leftPadding, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisY);

            const axisX = rc.line(leftPadding, svgHeight - bottomPadding, xAxisEnd, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', (leftPadding + xAxisEnd) / 2);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const datapointShape = document.getElementById('datapointShape').value;
            const points = dataItems.map((item, index) => {
                const x = leftPadding + pointOffset + (index * pointSpacing);
                const y = svgHeight - bottomPadding - ((item.value / maxValue) * chartHeight);
                return { x, y, item, index };
            });

            const areaGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(areaGroup);

            const lineGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            svg.appendChild(lineGroup);

            const pointGroups = points.map(() => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                svg.appendChild(g);
                return g;
            });

            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                areaGroup.innerHTML = '';
                lineGroup.innerHTML = '';
                pointGroups.forEach(g => g.innerHTML = '');

                // Calculate which segment we're on and how far along
                const totalProgress = progress * (points.length - 1);
                const currentSegment = Math.floor(totalProgress);
                const segmentProgress = totalProgress - currentSegment;

                // Build array of visible points (including partial progress)
                const visiblePoints = [];
                for (let i = 0; i <= currentSegment && i < points.length; i++) {
                    visiblePoints.push(points[i]);
                }

                // Add interpolated point if we're mid-segment
                if (currentSegment < points.length - 1 && segmentProgress > 0) {
                    const p1 = points[currentSegment];
                    const p2 = points[currentSegment + 1];
                    const interpolatedX = p1.x + (p2.x - p1.x) * segmentProgress;
                    const interpolatedY = p1.y + (p2.y - p1.y) * segmentProgress;
                    visiblePoints.push({
                        x: interpolatedX,
                        y: interpolatedY,
                        item: p1.item,
                        isInterpolated: true
                    });
                }

                // Draw filled area
                if (visiblePoints.length > 0) {
                    const areaPoints = [];
                    areaPoints.push([visiblePoints[0].x, svgHeight - bottomPadding]);
                    visiblePoints.forEach(p => areaPoints.push([p.x, p.y]));
                    areaPoints.push([visiblePoints[visiblePoints.length - 1].x, svgHeight - bottomPadding]);

                    const firstItem = dataItems[0];
                    const hachureGap = firstItem.pattern === 'dots' ? 24 : (firstItem.pattern === 'solid' ? 1 : 12);
                    const area = rc.polygon(areaPoints, {
                        fill: firstItem.color,
                        fillStyle: firstItem.pattern,
                        roughness: roughness,
                        strokeWidth: 0,
                        fillWeight: 1.5,
                        hachureAngle: 60,
                        hachureGap: hachureGap
                    });
                    areaGroup.appendChild(area);
                }

                // Draw line segments
                for (let i = 0; i < visiblePoints.length - 1; i++) {
                    const line = rc.line(visiblePoints[i].x, visiblePoints[i].y, visiblePoints[i + 1].x, visiblePoints[i + 1].y, {
                        roughness: roughness,
                        strokeWidth: 3,
                        stroke: '#333'
                    });
                    lineGroup.appendChild(line);
                }

                // Draw points and labels (only for complete points, not interpolated)
                for (let i = 0; i <= currentSegment && i < points.length; i++) {
                    const { x, y, item } = points[i];
                    const shapeSize = 15;
                    let shape;

                    if (datapointShape === 'circle') {
                        shape = rc.circle(x, y, shapeSize * 2, {
                            fill: item.color, fillStyle: 'solid', roughness: roughness,
                            strokeWidth: 2, stroke: '#333'
                        });
                    } else if (datapointShape === 'square') {
                        shape = rc.rectangle(x - shapeSize, y - shapeSize, shapeSize * 2, shapeSize * 2, {
                            fill: item.color, fillStyle: 'solid', roughness: roughness,
                            strokeWidth: 2, stroke: '#333'
                        });
                    } else if (datapointShape === 'diamond') {
                        const pts = [[x, y - shapeSize], [x + shapeSize, y], [x, y + shapeSize], [x - shapeSize, y]];
                        shape = rc.polygon(pts, {
                            fill: item.color, fillStyle: 'solid', roughness: roughness,
                            strokeWidth: 2, stroke: '#333'
                        });
                    } else {
                        const pts = [[x, y - shapeSize], [x + shapeSize, y + shapeSize], [x - shapeSize, y + shapeSize]];
                        shape = rc.polygon(pts, {
                            fill: item.color, fillStyle: 'solid', roughness: roughness,
                            strokeWidth: 2, stroke: '#333'
                        });
                    }
                    pointGroups[i].appendChild(shape);

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x);
                    label.setAttribute('y', svgHeight - bottomPadding + 50);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('class', 'bar-label');
                    label.style.fontSize = axisFontSize + 'px';
                    label.style.fontWeight = '600';
                    label.textContent = item.label;
                    pointGroups[i].appendChild(label);

                    const valueText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    valueText.setAttribute('x', x);
                    valueText.setAttribute('y', y - 20);
                    valueText.setAttribute('text-anchor', 'middle');
                    valueText.setAttribute('class', 'bar-label');
                    valueText.style.fontSize = dataLabelFontSize + 'px';
                    valueText.style.fontWeight = '600';
                    valueText.textContent = item.value;
                    pointGroups[i].appendChild(valueText);
                }

                if (progress < 1) {
                    setTimeout(() => requestAnimationFrame(animate), sketchInterval);
                } else {
                    const downloadBtn = document.getElementById('downloadGifBtn');
                    if (downloadBtn) downloadBtn.disabled = false;
                }
            }

            requestAnimationFrame(animate);
        }

        function animateScatterChart() {
            // Scatter chart shows points appearing one by one
            const svg = document.getElementById('chartSvg');
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();

            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            rc = rough.svg(svg);

            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            const minPadding = { horizontal: 60, vertical: 40 };
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + (axisFontSize + 120);
            const leftPadding = minPadding.horizontal + padding.horizontal + 60;
            const rightPadding = minPadding.horizontal + padding.horizontal;

            const chartHeight = svgHeight - topPadding - bottomPadding;
            const chartWidth = svgWidth - leftPadding - rightPadding;

            // For scatter plots, use X and Y values
            const maxX = Math.max(...dataItems.map(item => item.x || 0));
            const maxY = Math.max(...dataItems.map(item => item.y || 0));
            const minX = Math.min(...dataItems.map(item => item.x || 0), 0);
            const minY = Math.min(...dataItems.map(item => item.y || 0), 0);

            const xAxisEnd = svgWidth - rightPadding;
            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize;
            const yAxisExtension = dataLabelFontSize + 20;
            const duration = parseInt(document.getElementById('durationSlider').value);
            const sketchInterval = 16;

            const axisY = rc.line(leftPadding, topPadding - yAxisExtension, leftPadding, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisY);

            const axisX = rc.line(leftPadding, svgHeight - bottomPadding, xAxisEnd, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', (leftPadding + xAxisEnd) / 2);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 150);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 40);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const points = dataItems.map((item, index) => {
                const x = leftPadding + ((item.x - minX) / (maxX - minX || 1)) * chartWidth;
                const y = svgHeight - bottomPadding - ((item.y - minY) / (maxY - minY || 1)) * chartHeight;
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                svg.appendChild(g);
                return { x, y, item, index, group: g };
            });

            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                points.forEach(p => p.group.innerHTML = '');

                const visiblePointCount = Math.ceil(progress * points.length);

                for (let i = 0; i < visiblePointCount; i++) {
                    const { x, y, item, group } = points[i];
                    const shapeSize = 20;
                    const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);

                    // Draw white background circle first
                    const whiteCircle = rc.circle(x, y, shapeSize * 2, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    group.appendChild(whiteCircle);

                    const shape = rc.circle(x, y, shapeSize * 2, {
                        fill: item.color,
                        fillStyle: item.pattern,
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333',
                        fillWeight: 2,
                        hachureAngle: 60,
                        hachureGap: hachureGap
                    });
                    group.appendChild(shape);

                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x);
                    label.setAttribute('y', y - 30);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('class', 'bar-label');
                    label.style.fontSize = axisFontSize + 'px';
                    label.style.fontWeight = '600';
                    label.textContent = item.label;
                    group.appendChild(label);
                }

                if (progress < 1) {
                    setTimeout(() => requestAnimationFrame(animate), sketchInterval);
                } else {
                    const downloadBtn = document.getElementById('downloadGifBtn');
                    if (downloadBtn) downloadBtn.disabled = false;
                }
            }

            requestAnimationFrame(animate);
        }

        function animateHorizontalBarChart() {
            const svg = document.getElementById('chartSvg');
            const canvasDims = getCanvasDimensions();
            const padding = canvasDims.getPadding();

            const svgWidth = canvasDims.width;
            const svgHeight = canvasDims.height;
            svg.setAttribute('viewBox', `0 0 ${svgWidth} ${svgHeight}`);
            svg.style.width = 'auto';
            svg.style.maxWidth = '100%';

            rc = rough.svg(svg);

            const baseAxisFontSize = parseInt(document.getElementById('axisFontSize').value) || 35;
            const baseTitleFontSize = parseInt(document.getElementById('titleFontSize').value) || 50;
            const fontScale = currentAspectRatio === '16:9' ? 1.0 : 1.5;
            const axisFontSize = baseAxisFontSize * fontScale;
            const titleFontSize = baseTitleFontSize * fontScale;
            const chartTitle = document.getElementById('chartTitle').value;

            const minPadding = { horizontal: 60, vertical: 40 };
            const topPadding = minPadding.vertical + padding.vertical + (chartTitle ? titleFontSize + 200 : 0);
            const bottomPadding = minPadding.vertical + padding.vertical + 60;
            const leftPadding = minPadding.horizontal + padding.horizontal + 150;
            const rightPadding = minPadding.horizontal + padding.horizontal + (axisFontSize + 100);

            const chartWidth = svgWidth - leftPadding - rightPadding;
            const chartHeight = svgHeight - topPadding - bottomPadding;
            const maxValue = Math.max(...dataItems.map(item => item.value));
            const barCount = dataItems.length;

            const availableHeight = chartHeight;
            const spacingRatio = currentAspectRatio === '16:9' ? 0.2 : 0.3;
            const totalSpacingHeight = availableHeight * spacingRatio;
            const barSpacing = totalSpacingHeight / (barCount + 1);
            const barHeight = (availableHeight - totalSpacingHeight) / barCount;

            const roughness = parseFloat(document.getElementById('roughnessSlider').value);
            const dataLabelFontSize = axisFontSize;
            const xAxisExtension = dataLabelFontSize + 20;
            const duration = parseInt(document.getElementById('durationSlider').value);
            const sketchInterval = 16;

            const axisY = rc.line(leftPadding, topPadding, leftPadding, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisY);

            const xAxisEnd = svgWidth - rightPadding + xAxisExtension;
            const axisX = rc.line(leftPadding, svgHeight - bottomPadding, xAxisEnd, svgHeight - bottomPadding,
                { roughness: roughness, strokeWidth: 2.5, stroke: '#333' });
            svg.appendChild(axisX);

            const xAxisLabel = document.getElementById('xAxisLabel').value;
            const yAxisLabel = document.getElementById('yAxisLabel').value;

            if (xAxisLabel) {
                const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                xLabel.setAttribute('x', (leftPadding + xAxisEnd) / 2);
                xLabel.setAttribute('y', svgHeight - bottomPadding + axisFontSize + 80);
                xLabel.setAttribute('text-anchor', 'middle');
                xLabel.setAttribute('class', 'bar-label');
                xLabel.style.fontSize = axisFontSize + 'px';
                xLabel.style.fontWeight = '600';
                xLabel.textContent = xAxisLabel;
                svg.appendChild(xLabel);
            }

            if (yAxisLabel) {
                const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                yLabel.setAttribute('x', -(topPadding + chartHeight / 2));
                yLabel.setAttribute('y', leftPadding - 100);
                yLabel.setAttribute('text-anchor', 'middle');
                yLabel.setAttribute('transform', 'rotate(-90)');
                yLabel.setAttribute('class', 'bar-label');
                yLabel.style.fontSize = axisFontSize + 'px';
                yLabel.style.fontWeight = '600';
                yLabel.textContent = yAxisLabel;
                svg.appendChild(yLabel);
            }

            if (chartTitle) {
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', svgWidth / 2);
                title.setAttribute('y', topPadding - titleFontSize - 100);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'bar-label');
                title.style.fontSize = titleFontSize + 'px';
                title.style.fontWeight = '700';
                title.textContent = chartTitle;
                svg.appendChild(title);
            }

            const bars = dataItems.map((item, index) => {
                const barY = topPadding + barSpacing * (index + 1) + barHeight * index;
                const barWidth = (item.value / maxValue) * chartWidth;
                const barX = leftPadding;
                const barGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                svg.appendChild(barGroup);
                return { barGroup, barX, barY, barWidth, barHeight, item, index };
            });

            let startTime = null;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = Math.min((timestamp - startTime) / duration, 1);

                bars.forEach(({ barGroup, barX, barY, barWidth, barHeight, item }) => {
                    const currentWidth = barWidth * progress;
                    barGroup.innerHTML = '';

                    // Draw white background first
                    const whiteBackground = rc.rectangle(barX, barY, currentWidth, barHeight, {
                        fill: '#ffffff',
                        fillStyle: 'solid',
                        roughness: roughness,
                        strokeWidth: 0,
                        stroke: 'transparent'
                    });
                    barGroup.appendChild(whiteBackground);

                    const hachureGap = item.pattern === 'dots' ? 24 : (item.pattern === 'solid' ? 1 : 12);
                    const rect = rc.rectangle(barX, barY, currentWidth, barHeight, {
                        fill: item.color,
                        fillStyle: item.pattern,
                        roughness: roughness,
                        strokeWidth: 2,
                        stroke: '#333',
                        fillWeight: 2,
                        hachureAngle: 60,
                        hachureGap: hachureGap
                    });
                    barGroup.appendChild(rect);

                    const barLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    barLabel.setAttribute('x', leftPadding - 15);
                    barLabel.setAttribute('y', barY + barHeight / 2);
                    barLabel.setAttribute('text-anchor', 'end');
                    barLabel.setAttribute('dominant-baseline', 'middle');
                    barLabel.setAttribute('class', 'bar-label');
                    barLabel.style.fontSize = axisFontSize + 'px';
                    barLabel.style.fontWeight = '600';
                    barLabel.textContent = item.label;
                    barGroup.appendChild(barLabel);

                    const dataLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    dataLabel.setAttribute('x', barX + currentWidth + 15);
                    dataLabel.setAttribute('y', barY + barHeight / 2);
                    dataLabel.setAttribute('text-anchor', 'start');
                    dataLabel.setAttribute('dominant-baseline', 'middle');
                    dataLabel.setAttribute('class', 'bar-label');
                    dataLabel.style.fontSize = dataLabelFontSize + 'px';
                    dataLabel.style.fontWeight = '600';
                    dataLabel.textContent = item.value;
                    barGroup.appendChild(dataLabel);
                });

                if (progress < 1) {
                    setTimeout(() => requestAnimationFrame(animate), sketchInterval);
                } else {
                    const downloadBtn = document.getElementById('downloadGifBtn');
                    if (downloadBtn) downloadBtn.disabled = false;
                }
            }

            requestAnimationFrame(animate);
        }

        // Prevent Chart Settings panel clicks from opening data popup
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize font family on page load
            const fontFamily = document.getElementById('fontFamily')?.value || 'Noteworthy, sans-serif';
            document.documentElement.style.setProperty('--chart-font-family', fontFamily);

            const chartSettingsPanel = document.getElementById('chartSettingsPanel');
            if (chartSettingsPanel) {
                chartSettingsPanel.addEventListener('click', function(e) {
                    // Allow background color picker button to open (don't stop propagation)
                    const isBgDisplayClick = e.target.id === 'bgColorDisplay' || e.target.closest('#bgColorDisplay');
                    if (isBgDisplayClick) {
                        return; // Let it bubble to open the picker
                    }

                    // Check if background popup is open
                    const bgPopup = document.getElementById('bgColorPickerPopup');
                    const isBgPopupOpen = bgPopup && bgPopup.classList.contains('active');
                    const isBgClickInside = bgPopup && bgPopup.contains(e.target);

                    // If popup is open and click is inside popup, don't stop propagation
                    if (isBgPopupOpen && isBgClickInside) {
                        return; // Let clicks inside popup work normally
                    }

                    // If popup is open and click is elsewhere in settings panel, close it
                    if (isBgPopupOpen && !isBgClickInside) {
                        closeBgColorPicker();
                    }

                    // For all other clicks in chart settings panel, stop propagation
                    e.stopPropagation();
                }, false); // Use bubble phase, not capture
            }
        });

        // Download GIF functionality
        const downloadGifBtn = document.getElementById('downloadGifBtn');
        if (downloadGifBtn) {
            downloadGifBtn.addEventListener('click', async () => {
                downloadGifBtn.disabled = true;
                downloadGifBtn.textContent = 'Creating GIF...';
                isCreatingGif = true;

                try {
                    await captureChartAnimationAsGif();
                    downloadGifBtn.textContent = 'GIF Downloaded!';
                    setTimeout(() => {
                        downloadGifBtn.textContent = 'Download as GIF';
                        downloadGifBtn.disabled = false;
                        isCreatingGif = false;
                    }, 2000);
                } catch (error) {
                    console.error('Error creating GIF:', error);
                    downloadGifBtn.textContent = 'Error: ' + (error.message || 'Failed');
                    setTimeout(() => {
                        downloadGifBtn.textContent = 'Download as GIF';
                        downloadGifBtn.disabled = false;
                        isCreatingGif = false;
                    }, 3000);
                }
            });
        }

        async function captureChartAnimationAsGif() {
            if (typeof gifshot === 'undefined') {
                throw new Error('gifshot library not loaded');
            }

            if (dataItems.length === 0) {
                throw new Error('No data to animate');
            }

            // Ensure fonts are loaded before capturing
            if (document.fonts) {
                await document.fonts.ready;
                await new Promise(resolve => setTimeout(resolve, 500));
            }

            // System fonts are used, no need to load custom fonts

            // Preload background pattern if present
            const bgPattern = document.getElementById('bgPattern').value;
            if (bgPattern) {
                await new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => {
                        resolve();
                    };
                    img.onerror = () => {
                        console.warn('Background pattern failed to load, continuing anyway');
                        resolve(); // Continue even if pattern fails to load
                    };
                    img.src = bgPattern;
                    // Timeout after 5 seconds
                    setTimeout(() => {
                        console.warn('Background pattern load timeout, continuing anyway');
                        resolve();
                    }, 5000);
                });
            }

            const animDuration = parseFloat(document.getElementById('durationSlider').value); // in milliseconds
            const fps = 10;
            const captureInterval = 1000 / fps;
            const totalFrames = Math.ceil((animDuration / 1000) * fps); // Convert ms to seconds

            const chartContainer = document.querySelector('.chart-container');
            if (!chartContainer) {
                throw new Error('Chart container not found');
            }

            const userBgColor = document.getElementById('bgColor').value || '#ffffff';

            const images = [];

            // Start the animation to set up SVG viewBox
            animateChart();

            // Wait for first frame setup (SVG viewBox gets set)
            await new Promise(resolve => setTimeout(resolve, 50));

            // Get dimensions from canvas settings (aspect ratio and size)
            const canvasDims = getCanvasDimensions();
            const canvasWidth = canvasDims.width;
            const canvasHeight = canvasDims.height;

            // Restart animation from beginning for clean capture
            animateChart();

            // Small wait for first render of restarted animation
            await new Promise(resolve => setTimeout(resolve, 50));

            // Get the actual rendered size of the container
            const containerRect = chartContainer.getBoundingClientRect();
            const displayWidth = Math.round(containerRect.width);
            const displayHeight = Math.round(containerRect.height);

            // Capture frames during animation
            for (let i = 0; i < totalFrames; i++) {
                // Capture first, then wait (so we capture frame 0)
                try {
                    // Get the SVG element to verify viewBox
                    const svg = document.getElementById('chartSvg');
                    const viewBox = svg.getAttribute('viewBox');

                    const canvas = await html2canvas(chartContainer, {
                        backgroundColor: userBgColor,
                        scale: canvasWidth / displayWidth, // Scale up to target resolution
                        logging: false,
                        useCORS: true,
                        allowTaint: true,
                        foreignObjectRendering: false,
                        imageTimeout: 15000,
                        removeContainer: true,
                        onclone: function(clonedDoc) {
                            const selectedFont = document.getElementById('fontFamily')?.value || 'Noteworthy, sans-serif';

                            // Remove visual artifacts only - don't change dimensions
                            const clonedContainer = clonedDoc.querySelector('.chart-container');

                            if (clonedContainer) {
                                // Remove visual artifacts
                                clonedContainer.style.boxShadow = 'none';
                                clonedContainer.style.borderRadius = '0';
                            }

                            const style = clonedDoc.createElement('style');
                            style.textContent = `
                                * {
                                    font-family: ${selectedFont} !important;
                                }
                                .bar-label, .bar-value, text {
                                    font-family: ${selectedFont} !important;
                                }
                                .chart-container {
                                    background-color: ${userBgColor} !important;
                                    box-shadow: none !important;
                                    border-radius: 0 !important;
                                }
                            `;
                            clonedDoc.head.appendChild(style);
                        }
                    });

                    if (canvas && canvas.width > 0 && canvas.height > 0) {
                        // If dimensions don't match exactly, resize the canvas
                        if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
                            const resizedCanvas = document.createElement('canvas');
                            resizedCanvas.width = canvasWidth;
                            resizedCanvas.height = canvasHeight;
                            const ctx = resizedCanvas.getContext('2d');
                            ctx.drawImage(canvas, 0, 0, canvasWidth, canvasHeight);
                            images.push(resizedCanvas.toDataURL('image/png'));
                        } else {
                            images.push(canvas.toDataURL('image/png'));
                        }
                    } else {
                        console.error(`Frame ${i + 1} canvas is invalid`);
                        throw new Error(`Failed to capture frame ${i + 1}: Invalid canvas`);
                    }
                } catch (error) {
                    console.error('Error capturing frame:', error);
                    throw new Error(`Failed to capture frame ${i + 1}: ${error.message}`);
                }

                // Wait before next capture (except after last frame)
                if (i < totalFrames - 1) {
                    await new Promise(resolve => setTimeout(resolve, captureInterval));
                }
            }

            if (images.length === 0) {
                throw new Error('No frames captured');
            }

            return new Promise((resolve, reject) => {
                const gifOptions = {
                    images: images,
                    gifWidth: canvasWidth,
                    gifHeight: canvasHeight,
                    interval: 0.1,
                    sampleInterval: 10,
                    numWorkers: 2
                };

                gifshot.createGIF(gifOptions, (obj) => {
                    if (!obj.error) {
                        const a = document.createElement('a');
                        a.href = obj.image;
                        a.download = 'chart-animation.gif';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        resolve();
                    } else {
                        console.error('GIF creation error:', obj.error);
                        reject(new Error(obj.error));
                    }
                });
            });
        }
    </script>
</body>
</html>
